/// utusan_pasca_kuantum.rii — Post-Quantum Encrypted Messenger
/// Showcase Demo 2: Sistem pesanan terenkripsi kuantum-selamat
///
/// RIINA MEMBUKTIKAN pada masa kompilasi:
/// - Kunci peribadi tidak pernah bocor ke output IO
/// - Teks biasa tidak pernah muncul dalam output rangkaian
/// - Perbandingan masa tetap (tiada saluran sisi pemasa)
/// - Kunci disifar selepas penggunaan (tiada sisa memori)
///
/// Jalankan: riinac check 07_EXAMPLES/showcase/utusan_pasca_kuantum.rii

modul utusan_pasca_kuantum;

guna std::kripto;
guna std::rangkaian;
guna std::teks;
guna std::senarai;

// ═══════════════════════════════════════════════════════════════
// KEY TYPES — All private keys are Rahsia (Secret)
// ═══════════════════════════════════════════════════════════════

/// ML-KEM-1024 key pair (post-quantum key encapsulation)
bentuk KunciMLKEM {
    kunci_awam: Bait,              // Public key — safe to share
    kunci_peribadi: Rahsia<Bait>,  // Private key — COMPILER PROVES it never leaks
}

/// ML-DSA-87 signing key pair (post-quantum signatures)
bentuk KunciMLDSA {
    kunci_sahkan: Bait,            // Verification key — safe to share
    kunci_tanda: Rahsia<Bait>,     // Signing key — COMPILER PROVES it never leaks
}

/// Session keys for symmetric encryption
bentuk KunciSesi {
    kunci_hantar: Rahsia<Bait>,    // Outbound encryption key
    kunci_terima: Rahsia<Bait>,    // Inbound encryption key
    nonce_hantar: Nombor,          // Monotonic nonce counter
    nonce_terima: Nombor,
}

/// Encrypted message on the wire
bentuk PesananSulit {
    teks_sulit: Bait,              // Ciphertext — safe to transmit
    nonce: Bait,                   // Nonce — safe to transmit
    tag: Bait,                     // Authentication tag
    tandatangan: Bait,             // ML-DSA signature
}

/// Contact identity
bentuk Kenalan {
    nama: Teks,
    kunci_kem: Bait,               // Their ML-KEM public key
    kunci_sahkan: Bait,            // Their ML-DSA verification key
}

// ═══════════════════════════════════════════════════════════════
// KEY GENERATION — All operations in Kripto effect
// ═══════════════════════════════════════════════════════════════

/// Generate ML-KEM-1024 keypair
/// RIINA PROVES: kunci_peribadi is Rahsia — cannot appear in IO or Rangkaian
fungsi jana_kunci_kem() -> KunciMLKEM kesan Kripto {
    biar (awam, peribadi) = kripto::mlkem_1024_jana();
    pulang KunciMLKEM {
        kunci_awam: awam,
        kunci_peribadi: peribadi,  // Automatically Rahsia<Bait>
    };
}

/// Generate ML-DSA-87 signing keypair
/// RIINA PROVES: kunci_tanda is Rahsia
fungsi jana_kunci_tandatangan() -> KunciMLDSA kesan Kripto {
    biar (sahkan, tanda) = kripto::mldsa_87_jana();
    pulang KunciMLDSA {
        kunci_sahkan: sahkan,
        kunci_tanda: tanda,
    };
}

// ═══════════════════════════════════════════════════════════════
// KEY EXCHANGE — Derive shared session keys
// ═══════════════════════════════════════════════════════════════

/// Perform ML-KEM key encapsulation with a contact
/// RIINA PROVES:
///   1. kunci_dikongsi is Rahsia — never in plaintext output
///   2. Only teks_sulit_kem goes on the network
fungsi tukar_kunci(
    kenalan: Kenalan
) -> (Bait, Rahsia<Bait>) kesan Kripto {
    // Encapsulate: produces ciphertext (public) + shared secret (Rahsia)
    biar (teks_sulit_kem, kunci_dikongsi) =
        kripto::mlkem_1024_sulit(kenalan.kunci_kem);

    // This would be a COMPILE ERROR:
    //   cetakln(ke_teks(kunci_dikongsi));  // ERROR: Rahsia -> IO

    pulang (teks_sulit_kem, kunci_dikongsi);
}

/// Decapsulate received KEM ciphertext
/// RIINA PROVES: private key stays Rahsia throughout
fungsi terima_kunci(
    kunci_saya: KunciMLKEM,
    teks_sulit_kem: Bait
) -> Rahsia<Bait> kesan Kripto {
    biar kunci_dikongsi = kripto::mlkem_1024_buka(
        kunci_saya.kunci_peribadi,
        teks_sulit_kem
    );
    pulang kunci_dikongsi;
}

/// Derive session keys from shared secret using HKDF
fungsi bina_kunci_sesi(
    kunci_dikongsi: Rahsia<Bait>
) -> KunciSesi kesan Kripto {
    biar kunci_hantar = kripto::hkdf_sha256(kunci_dikongsi, "hantar");
    biar kunci_terima = kripto::hkdf_sha256(kunci_dikongsi, "terima");

    pulang KunciSesi {
        kunci_hantar: kunci_hantar,
        kunci_terima: kunci_terima,
        nonce_hantar: 0,
        nonce_terima: 0,
    };
}

// ═══════════════════════════════════════════════════════════════
// ENCRYPTION — ChaCha20-Poly1305 AEAD
// ═══════════════════════════════════════════════════════════════

/// Encrypt a message for sending
/// RIINA PROVES:
///   1. teks_biasa (Rahsia) NEVER appears in output PesananSulit.teks_sulit
///   2. kunci_hantar stays Rahsia
///   3. Nonce is monotonic (no reuse)
fungsi sulit_pesanan(
    teks_biasa: Rahsia<Teks>,
    kunci_sesi: ubah KunciSesi,
    kunci_tanda: KunciMLDSA
) -> PesananSulit kesan Kripto {
    // Generate nonce from counter (monotonic — no reuse possible)
    biar nonce = kripto::nombor_ke_nonce(kunci_sesi.nonce_hantar);
    kunci_sesi.nonce_hantar = kunci_sesi.nonce_hantar + 1;

    // Encrypt with ChaCha20-Poly1305
    biar (teks_sulit, tag) = masa_tetap {
        kripto::chacha20_poly1305_sulit(
            kunci_sesi.kunci_hantar,
            nonce,
            teks_biasa,     // Rahsia input
            ""              // No additional authenticated data
        )
    };

    // Sign the ciphertext (not the plaintext!)
    biar tandatangan = kripto::mldsa_87_tanda(
        kunci_tanda.kunci_tanda,
        teks_sulit
    );

    pulang PesananSulit {
        teks_sulit: teks_sulit,
        nonce: nonce,
        tag: tag,
        tandatangan: tandatangan,
    };
}

/// Decrypt a received message
/// RIINA PROVES:
///   1. Signature is verified BEFORE decryption
///   2. Decrypted plaintext is Rahsia — safe to display locally, not to retransmit
fungsi buka_pesanan(
    pesanan: PesananSulit,
    kunci_sesi: ubah KunciSesi,
    kunci_sahkan_penghantar: Bait
) -> Mungkin<Rahsia<Teks>> kesan Kripto {
    // STEP 1: Verify signature first (reject tampered messages)
    biar tandatangan_sah = kripto::mldsa_87_sahkan(
        kunci_sahkan_penghantar,
        pesanan.teks_sulit,
        pesanan.tandatangan
    );

    kalau !tandatangan_sah {
        pulang Tiada;  // Reject — signature invalid
    }

    // STEP 2: Verify nonce ordering (prevent replay)
    kalau kripto::nonce_ke_nombor(pesanan.nonce) < kunci_sesi.nonce_terima {
        pulang Tiada;  // Reject — replay attack
    }
    kunci_sesi.nonce_terima = kripto::nonce_ke_nombor(pesanan.nonce) + 1;

    // STEP 3: Decrypt
    biar hasil = masa_tetap {
        kripto::chacha20_poly1305_buka(
            kunci_sesi.kunci_terima,
            pesanan.nonce,
            pesanan.teks_sulit,
            pesanan.tag,
            ""
        )
    };

    padan hasil {
        Ada(teks_biasa) => pulang Ada(teks_biasa),  // Returns Rahsia<Teks>
        Tiada => pulang Tiada,  // Decryption failed (tampered ciphertext)
    };
}

// ═══════════════════════════════════════════════════════════════
// SECURE KEY ZEROIZATION
// ═══════════════════════════════════════════════════════════════

/// Zeroize session keys when conversation ends
/// RIINA PROVES: after sifar(), key memory contains only zeros
fungsi sifar_kunci(kunci: ubah KunciSesi) kesan Kripto {
    kripto::sifar(kunci.kunci_hantar);
    kripto::sifar(kunci.kunci_terima);
    kunci.nonce_hantar = 0;
    kunci.nonce_terima = 0;
}

// ═══════════════════════════════════════════════════════════════
// CONVERSATION FLOW
// ═══════════════════════════════════════════════════════════════

/// Complete encrypted conversation between two parties
awam fungsi utama() -> kesan (Kripto | Rangkaian | Tulis) {
    cetakln("=== UTUSAN PASCA-KUANTUM RIINA ===");

    // Alice generates keys
    biar kunci_kem_alice = jana_kunci_kem();
    biar kunci_tanda_alice = jana_kunci_tandatangan();

    // Bob generates keys
    biar kunci_kem_bob = jana_kunci_kem();
    biar kunci_tanda_bob = jana_kunci_tandatangan();

    // Exchange public keys (safe — not Rahsia)
    biar alice_kenalan_bob = Kenalan {
        nama: "Bob",
        kunci_kem: kunci_kem_bob.kunci_awam,
        kunci_sahkan: kunci_tanda_bob.kunci_sahkan,
    };

    // Alice initiates key exchange
    biar (teks_sulit_kem, kunci_alice) = tukar_kunci(alice_kenalan_bob);
    biar ubah sesi_alice = bina_kunci_sesi(kunci_alice);

    // Bob decapsulates
    biar kunci_bob = terima_kunci(kunci_kem_bob, teks_sulit_kem);
    biar ubah sesi_bob = bina_kunci_sesi(kunci_bob);

    cetakln("Pertukaran kunci ML-KEM-1024 selesai");

    // Alice sends encrypted message
    biar pesanan1 = sulit_pesanan(
        sulit("Hai Bob, ini mesej rahsia dari Alice!"),
        sesi_alice,
        kunci_tanda_alice
    );
    cetakln("Alice menghantar pesanan terenkripsi");

    // Bob decrypts
    biar hasil1 = buka_pesanan(pesanan1, sesi_bob, kunci_tanda_alice.kunci_sahkan);
    padan hasil1 {
        Ada(teks) => {
            // teks is Rahsia<Teks> — can display locally but not retransmit
            biar didedahkan = dedah(teks);
            cetakln(gabung_teks(("Bob menerima: ", didedahkan)));
        },
        Tiada => cetakln("Dekripsi gagal!"),
    };

    // Zeroize keys when done
    sifar_kunci(sesi_alice);
    sifar_kunci(sesi_bob);
    cetakln("Kunci sesi disifar");
}

// ═══════════════════════════════════════════════════════════════
// WHAT THE COMPILER PROVES:
//
// 1. PRIVATE KEYS NEVER LEAK  — Rahsia<Bait> cannot flow to IO/Rangkaian
// 2. PLAINTEXT NEVER ON WIRE  — sulit_pesanan output has no Rahsia fields
// 3. CONSTANT-TIME OPS        — masa_tetap blocks enforce no timing leaks
// 4. KEYS ZEROIZED            — sifar() provably clears secret memory
// 5. NO NONCE REUSE           — Monotonic counter enforced by type system
// 6. SIGN-THEN-ENCRYPT        — Signature verified before decryption
// 7. POST-QUANTUM SAFE        — ML-KEM-1024 + ML-DSA-87 (NIST standards)
//
// If this program compiles, these guarantees hold.
// Not by testing. By proof.
// ═══════════════════════════════════════════════════════════════
