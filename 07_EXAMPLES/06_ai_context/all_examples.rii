// === 07_EXAMPLES/00_basics/arithmetic.rii ===
/// ARITHMETIC.RII - Arithmetic Operations
/// Operasi matematik dalam RIINA
/// Demonstrates: +, -, *, /, %, operator precedence

fungsi operasiMatematik() -> Nombor kesan Bersih {
    /// Penambahan
    biar penambahan = 5 + 3;        /// Addition: 8

    /// Penolakan
    biar penolakan = 10 - 4;         /// Subtraction: 6

    /// Pendaraban
    biar pendaraban = 6 * 7;         /// Multiplication: 42

    /// Pembahagian
    biar pembahagian = 20 / 4;       /// Division: 5

    /// Modulo (sisa)
    biar sisa = 17 % 5;              /// Modulo: 2

    /// Gabung operasi dengan preseden
    /// Combine operations with precedence
    biar gabung = 2 + 3 * 4;         /// 2 + (3*4) = 14

    /// Gunakan kurungan untuk ubah preseden
    /// Use parentheses to change precedence
    biar ubahPreseden = (2 + 3) * 4; /// (2+3)*4 = 20

    /// Operasi rantaian
    /// Chained operations
    biar rantai = 100 - 25 + 15 / 3;

    pulang gabung + ubahPreseden;
}

fungsi utama() -> Nombor kesan Tulis {
    biar hasil = operasiMatematik();
    cetak("Hasil: ");
    cetak(hasil);
    cetak("\n");
    pulang 0;
}

/// NUMERIC TYPES: Nombor is a fixed-width integer type.
/// All operations are on machine integers with defined overflow semantics.
/// For arbitrary precision, use the Nombor.Besar type (future).

// === 07_EXAMPLES/00_basics/booleans.rii ===
/// BOOLEANS.RII - Boolean Operations and Logic
/// Operasi logik dalam RIINA menggunakan betul/salah
/// Demonstrates: true/false, &&, ||, !, comparisons

fungsi operasiLogik() -> Benar kesan Bersih {
    /// Nilai boolean asli
    /// Native boolean values
    biar betulnya = betul;           /// true
    biar salahnya = salah;            /// false

    /// Operasi AND (&&)
    biar dan = betul && betul;        /// true
    biar danFalse = betul && salah;   /// false

    /// Operasi OR (||)
    biar atau = betul || salah;       /// true
    biar auSemua = salah || salah;    /// false

    /// Operasi NOT (!)
    biar tidak = !betul;              /// false
    biar tidakFalse = !salah;         /// true

    pulang betul;
}

fungsi perbandingan() -> Benar kesan Bersih {
    biar x = 5;
    biar y = 10;

    /// Sama dengan
    biar samadengan = x == y;         /// false

    /// Tidak sama dengan
    biar tidakSama = x != y;          /// true

    /// Lebih besar
    biar lebihBesar = x > y;          /// false

    /// Lebih kecil
    biar lebihKecil = x < y;          /// true

    /// Lebih besar atau sama
    biar lebihBesarSama = x >= y;     /// false

    /// Lebih kecil atau sama
    biar lebihKecilSama = x <= y;     /// true

    pulang lebihKecilSama;
}

fungsi utama() -> Nombor kesan Tulis {
    biar hasil = operasiLogik();
    cetak("Boolean result: ");
    cetak(hasil);
    cetak("\n");
    pulang 0;
}

/// GRAMMAR NOTE: betul/salah are keywords for true/false.
/// Logical operators: && (and), || (or), ! (not)
/// Comparison operators work on all comparable types.

// === 07_EXAMPLES/00_basics/closures.rii ===
/// CLOSURES.RII - Closures and Captured Variables
/// Penutup (closure) yang menangkap pembolehubah
/// Demonstrates: variable capture, lexical scope, closures in containers

fungsi buat_pencacah() -> Fn() -> Nombor kesan Bersih {
    /// Buat penutup yang menangkap ubah
    /// Create closure capturing mutable variable
    biar ubah kiraan = 0;

    /// Kembalikan fungsi yang mengakses kiraan
    /// Return function that accesses kiraan
    fungsi cacah() -> Nombor {
        kiraan = kiraan + 1;
        pulang kiraan;
    }

    pulang cacah;
}

fungsi buat_pengganda(faktor: Nombor) -> Fn(Nombor) -> Nombor kesan Bersih {
    /// Buat penutup dengan parameter
    /// Create closure with parameter
    fungsi darab(x: Nombor) -> Nombor {
        pulang x * faktor;
    }

    pulang darab;
}

fungsi penutup_berganda() -> Fn(Nombor) -> Fn(Nombor) -> Nombor kesan Bersih {
    /// Penutup yang mengembalikan penutup
    /// Closure returning closure
    fungsi pembuat_penambah(n: Nombor) -> Fn(Nombor) -> Nombor {
        fungsi tambah(x: Nombor) -> Nombor {
            pulang x + n;
        }
        pulang tambah;
    }

    pulang pembuat_penambah;
}

fungsi penutup_dalam_senarai() -> Senarai<Fn(Nombor) -> Nombor> kesan Bersih {
    /// Buat senarai penutup
    /// Create list of closures
    biar ubah penutup_senarai: Senarai<Fn(Nombor) -> Nombor> = [];

    untuk i dalam 0..5 {
        /// Setiap penutup menangkap i yang berbeza
        /// Each closure captures different i
        fungsi kelipatan(x: Nombor) -> Nombor {
            pulang x * i;
        }
        penutup_senarai = penutup_senarai.tambah(kelipatan);
    }

    pulang penutup_senarai;
}

fungsi penutup_dengan_peta() -> Senarai<Fn(Nombor) -> Nombor> kesan Bersih {
    /// Gunakan peta untuk membuat penutup
    /// Use map to create closures
    biar faktor_senarai = [2, 3, 4, 5];

    biar penutup = faktor_senarai.peta(fungsi(f: Nombor) -> Fn(Nombor) -> Nombor {
        fungsi kelipatan(x: Nombor) -> Nombor {
            pulang x * f;
        }
        pulang kelipatan;
    });

    pulang penutup;
}

fungsi penutup_kurang() -> Fn(Nombor) -> Nombor kesan Bersih {
    /// Penutup yang menangkap rujukan
    /// Closure capturing reference
    biar ubah terhenti = salah;

    fungsi kurangkan(x: Nombor) -> Nombor {
        kalau !terhenti {
            terhenti = betul;
            pulang x - 1;
        }
        pulang x;
    }

    pulang kurangkan;
}

fungsi tutup_dengan_kadir() -> (Fn(Nombor) -> Nombor, Fn() -> Nombor) kesan Bersih {
    /// Penutup yang berkongsi keadaan
    /// Closure sharing state
    biar ubah jumlah = 0;
    biar ubah kiraan = 0;

    fungsi tambah(x: Nombor) -> Nombor {
        jumlah = jumlah + x;
        kiraan = kiraan + 1;
        pulang jumlah;
    }

    fungsi ambil_purata() -> Nombor {
        kalau kiraan > 0 {
            pulang jumlah / kiraan;
        }
        pulang 0;
    }

    pulang (tambah, ambil_purata);
}

fungsi utama() -> Nombor kesan Tulis {
    /// Contoh 1: Pencacah
    /// Example 1: Counter
    biar pencacah = buat_pencacah();
    cetak("Cacah 1: ");
    cetak(pencacah());
    cetak("\n");

    cetak("Cacah 2: ");
    cetak(pencacah());
    cetak("\n");

    cetak("Cacah 3: ");
    cetak(pencacah());
    cetak("\n\n");

    /// Contoh 2: Pengganda
    /// Example 2: Multiplier
    biar darab_dua = buat_pengganda(2);
    biar darab_tiga = buat_pengganda(3);

    cetak("2 * 5 = ");
    cetak(darab_dua(5));
    cetak("\n");

    cetak("3 * 5 = ");
    cetak(darab_tiga(5));
    cetak("\n\n");

    /// Contoh 3: Penutup berganda
    /// Example 3: Double closure
    biar pembuat = penutup_berganda();
    biar tambah_10 = pembuat(10);
    biar tambah_20 = pembuat(20);

    cetak("5 + 10 = ");
    cetak(tambah_10(5));
    cetak("\n");

    cetak("5 + 20 = ");
    cetak(tambah_20(5));
    cetak("\n\n");

    /// Contoh 4: Penutup berkongsi keadaan
    /// Example 4: Closure sharing state
    biar (tambah, ambil_purata) = tutup_dengan_kadir();

    cetak("Jumlah: ");
    cetak(tambah(10));
    cetak("\n");

    cetak("Jumlah: ");
    cetak(tambah(20));
    cetak("\n");

    cetak("Purata: ");
    cetak(ambil_purata());
    cetak("\n");

    pulang 0;
}

/// GRAMMAR NOTE: Closures capture variables from enclosing scope.
/// Captured variables are moved into closure unless borrowed.
/// Mutable captures allow modification visible to all closures.
/// Closures are first-class values (can be stored, returned, passed).

// === 07_EXAMPLES/00_basics/conditionals.rii ===
/// CONDITIONALS.RII - If-Else Control Flow
/// Kawalan aliran dengan kalau dan lain
/// Demonstrates: if, else-if, else, conditional expressions

fungsi periksaBilangan(x: Nombor) -> Teks kesan Bersih {
    /// Bentuk mudah kalau-lain
    /// Simple if-else
    kalau x > 0 {
        pulang "positif";
    } lain kalau x < 0 {
        pulang "negatif";
    } lain {
        pulang "kosong";
    }
}

fungsi periksaNama(nama: Teks) -> Benar kesan Bersih {
    /// Kalau tanpa lain
    /// If without else
    kalau nama == "Ahmad" {
        pulang betul;
    }

    /// Jatuh keluar - pulang salah secara tersirat
    /// Falls through to implicit return false
    pulang salah;
}

fungsi getDiscount(umur: Nombor) -> Nombor kesan Bersih {
    /// Kalau sebagai expression (dalam assignment)
    /// If as expression (in assignment)
    biar diskaun = kalau umur > 60 {
        50      /// Diskaun untuk warga emas (senior discount)
    } lain kalau umur < 18 {
        25      /// Diskaun untuk belia (youth discount)
    } lain {
        0       /// Tiada diskaun (no discount)
    };

    pulang diskaun;
}

fungsi periksaBilangan2(x: Nombor, y: Nombor) -> Teks kesan Bersih {
    /// Kalau bersarang (nested if)
    /// Nested if statements
    kalau x > 0 {
        kalau y > 0 {
            pulang "kedua positif";
        } lain {
            pulang "x positif, y negatif";
        }
    } lain {
        pulang "x tidak positif";
    }
}

fungsi utama() -> Nombor kesan Tulis {
    biar hasil = periksaBilangan(42);
    cetak(hasil);
    cetak("\n");

    biar diskaun = getDiscount(65);
    cetak("Diskaun: ");
    cetak(diskaun);
    cetak("%\n");

    pulang 0;
}

/// GRAMMAR NOTE: kalau/lain (if/else) keywords.
/// If-else can be expression or statement.
/// Multiple else-if branches are chained with `lain kalau`.
/// Implicit return of last expression in each branch.

// === 07_EXAMPLES/00_basics/functions.rii ===
/// FUNCTIONS.RII - Function Declarations and Calls
/// Menunjukkan deklarasi dan panggilan fungsi
/// Demonstrates: function syntax, parameters, return types, overloading

/// Fungsi tanpa parameter
/// Function with no parameters
fungsi ambilNilaiTetap() -> Nombor kesan Bersih {
    pulang 42;
}

/// Fungsi dengan satu parameter
/// Function with one parameter
fungsi tambahSatu(x: Nombor) -> Nombor kesan Bersih {
    pulang x + 1;
}

/// Fungsi dengan banyak parameter
/// Function with multiple parameters
fungsi tambah(x: Nombor, y: Nombor) -> Nombor kesan Bersih {
    pulang x + y;
}

/// Fungsi dengan beberapa efek
/// Function with multiple effects
fungsi cetakDanKira(x: Nombor) -> Nombor kesan (Tulis, Bersih) {
    cetak("Nilai: ");
    cetak(x);
    cetak("\n");
    pulang x * 2;
}

fungsi utama() -> Nombor kesan Tulis {
    /// Panggil fungsi tanpa parameter
    biar a = ambilNilaiTetap();

    /// Panggil dengan satu parameter
    biar b = tambahSatu(a);

    /// Panggil dengan banyak parameter
    biar c = tambah(a, b);

    /// Cetak hasil
    cetak("Hasil: ");
    cetak(c);
    cetak("\n");

    pulang 0;
}

/// GRAMMAR NOTE: Functions use `fungsi` keyword.
/// Return type syntax: `-> ReturnType`
/// Effects listed as: `kesan (Effect1, Effect2, ...)`
/// Implicit return for expression statements.

// === 07_EXAMPLES/00_basics/functions_higher.rii ===
/// FUNCTIONS_HIGHER.RII - Higher-Order Functions
/// Fungsi yang mengambil atau mengembalikan fungsi lain
/// Demonstrates: function parameters, function returns, closures

/// Fungsi yang mengambil fungsi sebagai parameter
/// Function taking function as parameter
fungsi gunakan_pada_senarai(
    senarai: Senarai<Nombor>,
    f: Fn(Nombor) -> Nombor
) -> Senarai<Nombor> kesan Bersih {
    /// Gunakan f untuk mengubah setiap elemen
    /// Use f to transform each element
    senarai.peta(f)
}

/// Fungsi yang mengembalikan fungsi
/// Function returning function
fungsi buat_pengadun(n: Nombor) -> Fn(Nombor) -> Nombor kesan Bersih {
    /// Kembalikan fungsi yang menambah n
    /// Return function that adds n
    fungsi pengadun(x: Nombor) -> Nombor {
        pulang x + n;
    }

    pulang pengadun;
}

/// Fungsi komposisi
/// Function composition
fungsi komposisi(
    f: Fn(Nombor) -> Nombor,
    g: Fn(Nombor) -> Nombor
) -> Fn(Nombor) -> Nombor kesan Bersih {
    /// Kembalikan f(g(x))
    /// Return f composed with g
    fungsi hasil(x: Nombor) -> Nombor {
        pulang f(g(x));
    }

    pulang hasil;
}

/// Fungsi dengan dua parameter fungsi
/// Function with two function parameters
fungsi gunakan_dua(
    x: Nombor,
    f: Fn(Nombor) -> Nombor,
    g: Fn(Nombor) -> Nombor
) -> Nombor kesan Bersih {
    /// Gunakan f dan g pada x
    /// Apply f and g to x
    biar hasil1 = f(x);
    biar hasil2 = g(hasil1);
    pulang hasil2;
}

/// Fungsi pembawa (currying)
/// Curried function
fungsi tambah_dibawa(x: Nombor) -> Fn(Nombor) -> Nombor kesan Bersih {
    /// Kembalikan fungsi yang menambah x pada parameter berikutnya
    /// Return function that adds x
    fungsi tambah_y(y: Nombor) -> Nombor {
        pulang x + y;
    }

    pulang tambah_y;
}

/// Filter dengan predikat
/// Filter with predicate
fungsi tapis_dengan(
    senarai: Senarai<Nombor>,
    predikat: Fn(Nombor) -> Benar
) -> Senarai<Nombor> kesan Bersih {
    /// Tapis senarai menggunakan predikat
    /// Filter list using predicate
    senarai.tapis(predikat)
}

/// Ulang operasi n kali
/// Apply operation n times
fungsi ulang_n_kali(
    n: Nombor,
    f: Fn(Nombor) -> Nombor,
    awal: Nombor
) -> Nombor kesan Bersih {
    /// Gunakan f n kali bermula dari awal
    /// Apply f n times starting from initial value
    biar ubah hasil = awal;

    untuk i dalam 0..n {
        hasil = f(hasil);
    }

    pulang hasil;
}

/// Pengurangan nilai
/// Reduce/fold operation
fungsi kurangkan_dengan(
    senarai: Senarai<Nombor>,
    f: Fn(Nombor, Nombor) -> Nombor,
    awal: Nombor
) -> Nombor kesan Bersih {
    /// Kurangkan senarai menggunakan f
    /// Reduce list using f
    senarai.lipat(awal, f)
}

fungsi utama() -> Nombor kesan Tulis {
    /// Contoh 1: Gunakan fungsi pada senarai
    /// Example 1: Use function on list
    biar senarai = [1, 2, 3, 4, 5];
    biar ubahan = gunakan_pada_senarai(senarai, fungsi(x: Nombor) -> Nombor {
        pulang x * 2;
    });

    cetak("Ubahan: ");
    cetak(ubahan);
    cetak("\n");

    /// Contoh 2: Buat dan gunakan fungsi pembawa
    /// Example 2: Create and use curried function
    biar tambah_lima = buat_pengadun(5);
    biar hasil = tambah_lima(10);

    cetak("10 + 5 = ");
    cetak(hasil);
    cetak("\n");

    /// Contoh 3: Komposisi fungsi
    /// Example 3: Function composition
    biar kurangkan = fungsi(x: Nombor) -> Nombor { x - 1 };
    biar darab = fungsi(x: Nombor) -> Nombor { x * 2 };
    biar komposit = komposisi(darab, kurangkan);

    biar hasil2 = komposit(5);    /// (5-1)*2 = 8
    cetak("Komposisi: ");
    cetak(hasil2);
    cetak("\n");

    /// Contoh 4: Ulang operasi
    /// Example 4: Apply operation repeatedly
    biar hasil3 = ulang_n_kali(3, fungsi(x: Nombor) -> Nombor { x * 2 }, 1);
    cetak("2^3 = ");
    cetak(hasil3);
    cetak("\n");

    /// Contoh 5: Tapis dengan predikat
    /// Example 5: Filter with predicate
    biar ganjil = tapis_dengan(senarai, fungsi(x: Nombor) -> Benar {
        pulang x % 2 != 0;
    });

    cetak("Ganjil: ");
    cetak(ganjil);
    cetak("\n");

    pulang 0;
}

/// GRAMMAR NOTE: Fn(T1, T2, ...) -> ReturnType is function type.
/// Functions are first-class values.
/// Closures capture variables from enclosing scope.
/// Lambda syntax: fungsi(params) { body } or shorter form when possible.

// === 07_EXAMPLES/00_basics/guard_clauses.rii ===
/// GUARD_CLAUSES.RII - Guard Clauses and Assertions
/// Klausa penjaga (guard) untuk validasi input
/// Demonstrates: pastikan (guard), preconditions, assertions

fungsi bahagi_dengan_penjaga(x: Nombor, y: Nombor) -> Nombor kesan Bersih {
    /// Penjaga untuk pastikan y tidak sifar
    /// Guard to ensure y is not zero
    pastikan y != 0 "Pembahagi tidak boleh sifar";

    pulang x / y;
}

fungsi ambil_elemen_aman(senarai: Senarai<Nombor>, indeks: Nombor) -> Mungkin<Nombor> kesan Bersih {
    /// Penjaga untuk pastikan indeks sah
    /// Guard to ensure index is valid
    pastikan indeks >= 0 "Indeks tidak boleh negatif";
    pastikan indeks < senarai.panjang() "Indeks melebihi batas";

    pulang Ada(senarai[indeks]);
}

fungsi log_dengan_penjaga(n: Nombor) -> Nombor kesan Bersih {
    /// Penjaga untuk log (hanya untuk positif)
    /// Guard for logarithm (only positive)
    pastikan n > 0 "Log hanya untuk nombor positif";

    /// Log calculation (simplified)
    pulang 0;
}

fungsi tukar_elemen(ubah senarai: Senarai<Nombor>, indeks: Nombor, nilai: Nombor) -> Nombor kesan Bersih {
    /// Penjaga untuk verifikasi indeks
    /// Guard to verify index
    pastikan indeks >= 0 "Indeks tidak boleh negatif";
    pastikan indeks < senarai.panjang() "Indeks melebihi batas";

    senarai = senarai;  /// Update (simplified)
    pulang nilai;
}

fungsi cek_umur_sah(umur: Nombor) -> Benar kesan Bersih {
    /// Penjaga untuk umur yang munasabah
    /// Guard for reasonable age
    pastikan umur >= 0 "Umur tidak boleh negatif";
    pastikan umur <= 150 "Umur terlalu tinggi";

    pulang betul;
}

fungsi operasi_dengan_keadaan(x: Nombor, y: Nombor, mod: Teks) -> Nombor kesan Bersih {
    /// Penjaga pelbagai dalam keadaan
    /// Multiple guards in conditions
    padan mod {
        "tambah" -> {
            pastikan x >= 0 "x mesti bukan negatif";
            pastikan y >= 0 "y mesti bukan negatif";
            pulang x + y;
        },
        "bahagi" -> {
            pastikan x >= 0 "x mesti bukan negatif";
            pastikan y > 0 "y mesti positif";
            pulang x / y;
        },
        _ -> {
            pastikan salah "Mod tidak sah";
            pulang 0;
        },
    }
}

fungsi proses_data_dengan_penjaga(
    nama: Teks,
    umur: Nombor,
    emel: Teks
) -> Benar kesan Bersih {
    /// Penjaga bersarang untuk validasi data
    /// Nested guards for data validation
    pastikan nama != "" "Nama tidak boleh kosong";

    kalau nama.panjang() > 100 {
        pastikan salah "Nama terlalu panjang";
    }

    pastikan umur > 0 "Umur mesti positif";
    pastikan umur < 150 "Umur mesti munasabah";

    pastikan emel.ada("@") "Emel mesti mengandungi @";
    pastikan emel.ada(".") "Emel mesti mempunyai domain";

    pulang betul;
}

fungsi fungsi_dengan_penjaga_awal(x: Nombor, y: Nombor) -> Nombor kesan Bersih {
    /// Penjaga awal - keluar terus jika tidak memenuhi
    /// Early guard - exit immediately if condition not met
    pastikan x > 0 "x mesti positif";
    pastikan y > 0 "y mesti positif";

    /// Jika tiba di sini, x dan y dijamin positif
    /// If we reach here, x and y are guaranteed positive
    pulang x + y;
}

fungsi panjang_teks_sah(t: Teks) -> Nombor kesan Bersih {
    /// Penjaga untuk teks bukan kosong
    /// Guard for non-empty text
    pastikan t != "" "Teks tidak boleh kosong";
    pastikan t.panjang() <= 1000 "Teks terlalu panjang";

    pulang t.panjang();
}

fungsi utama() -> Nombor kesan Tulis {
    /// Contoh 1: Bahagi dengan penjaga
    /// Example 1: Division with guard
    kalau bahagi_dengan_penjaga(10, 2) == 5 {
        cetak("Bahagi berjaya\n");
    }

    /// Contoh 2: Ambil elemen aman
    /// Example 2: Safe element retrieval
    biar senarai = [1, 2, 3, 4, 5];
    padan ambil_elemen_aman(senarai, 0) {
        Ada(n) -> {
            cetak("Elemen: ");
            cetak(n);
            cetak("\n");
        },
        Tidak -> {
            cetak("Indeks tidak sah\n");
        },
    }

    /// Contoh 3: Cek umur
    /// Example 3: Check age
    kalau cek_umur_sah(25) {
        cetak("Umur sah\n");
    }

    /// Contoh 4: Proses data
    /// Example 4: Process data
    kalau proses_data_dengan_penjaga("Ahmad", 25, "ahmad@example.com") {
        cetak("Data sah\n");
    }

    pulang 0;
}

/// GRAMMAR NOTE: pastikan (guard/require) for preconditions.
/// Guard statement: pastikan condition "error message";
/// Assertion fails program execution with error message if condition false.
/// Used to validate function preconditions and invariants.

// === 07_EXAMPLES/00_basics/hello.rii ===
/// HELLO.RII - Hello World
/// Contoh paling mudah dalam RIINA - mencetak ke konsol
/// Demonstrates: basic I/O, simple expressions

fungsi utama() -> Nombor kesan Tulis {
    /// Cetak mesej sambutan
    /// Print greeting message to console
    cetak("Selamat pagi, dunia!");

    /// Pulang nilai 0 untuk berjaya
    /// Return 0 for success (exit code)
    pulang 0;
}

/// GRAMMAR NOTE: This file demonstrates pure I/O with the Tulis effect.
/// The `fungsi utama()` is the entry point, similar to `main()` in C/Rust.
/// `kesan Tulis` declares that this function performs output.
/// `cetak(...)` is a builtin that outputs to stdout.

// === 07_EXAMPLES/00_basics/lists.rii ===
/// LISTS.RII - List Operations and Manipulation
/// Operasi senarai (list) dalam RIINA
/// Demonstrates: list literals, methods, iteration, functional ops

fungsi buat_senarai() -> Senarai<Nombor> kesan Bersih {
    /// Senarai literal dengan elemen awal
    /// List literal with initial elements
    biar senarai = [1, 2, 3, 4, 5];

    /// Senarai kosong
    /// Empty list
    biar kosong: Senarai<Nombor> = [];

    /// Senarai dengan satu jenis elemen
    /// List with string elements
    biar nama_nama = ["Ahmad", "Siti", "Budi"];

    pulang senarai;
}

fungsi operasi_senarai() -> Nombor kesan Bersih {
    /// Panjang senarai (method call)
    /// List length
    biar senarai = [1, 2, 3, 4, 5];
    biar panjang = senarai.panjang();   /// 5

    /// Akses elemen dengan indeks
    /// Access element by index
    biar pertama = senarai[0];          /// 1
    biar terakhir = senarai[4];         /// 5

    /// Tambah elemen (returns new list)
    /// Add element (returns new list)
    biar senarai2 = senarai.tambah(6);

    /// Singkirkan elemen pertama
    /// Remove first element
    biar senarai3 = senarai.ekor();     /// [2, 3, 4, 5]

    pulang panjang;
}

fungsi ubah_senarai() -> Senarai<Nombor> kesan Bersih {
    /// Ubah setiap elemen dengan peta (map)
    /// Transform each element with map
    biar senarai = [1, 2, 3, 4, 5];

    biar ubahan = senarai.peta(fungsi(x: Nombor) -> Nombor {
        pulang x * 2;
    });

    /// ubahan = [2, 4, 6, 8, 10]

    pulang ubahan;
}

fungsi tapis_senarai() -> Senarai<Nombor> kesan Bersih {
    /// Tapis elemen dengan syarat (filter)
    /// Filter elements with condition
    biar senarai = [1, 2, 3, 4, 5, 6];

    biar ganjil = senarai.tapis(fungsi(x: Nombor) -> Benar {
        pulang x % 2 != 0;
    });

    /// ganjil = [1, 3, 5]

    pulang ganjil;
}

fungsi lipat_senarai() -> Nombor kesan Bersih {
    /// Lipat senarai ke nilai tunggal (fold/reduce)
    /// Fold list to single value
    biar senarai = [1, 2, 3, 4, 5];

    biar jumlah = senarai.lipat(0, fungsi(akum: Nombor, x: Nombor) -> Nombor {
        pulang akum + x;
    });

    /// jumlah = 15

    pulang jumlah;
}

fungsi cari_dalam_senarai() -> Mungkin<Nombor> kesan Bersih {
    /// Cari elemen pertama yang memenuhi syarat
    /// Find first element matching condition
    biar senarai = [1, 2, 3, 4, 5];

    biar hasil = senarai.cari(fungsi(x: Nombor) -> Benar {
        pulang x > 3;
    });

    /// hasil = Ada(4)

    pulang hasil;
}

fungsi gabung_senarai() -> Senarai<Nombor> kesan Bersih {
    /// Gabung dua senarai
    /// Concatenate two lists
    biar senarai1 = [1, 2, 3];
    biar senarai2 = [4, 5, 6];

    biar gabungan = senarai1.gabung(senarai2);

    /// gabungan = [1, 2, 3, 4, 5, 6]

    pulang gabungan;
}

fungsi potong_senarai() -> Senarai<Nombor> kesan Bersih {
    /// Ambil sebahagian daripada senarai (slice)
    /// Take a slice of list
    biar senarai = [1, 2, 3, 4, 5, 6, 7];

    biar potongan = senarai.potong(2, 5);    /// [3, 4, 5]

    pulang potongan;
}

fungsi iterasi_senarai() -> Nombor kesan Tulis {
    /// Iterasi dengan untuk-dalam
    /// Iterate with for-in
    biar senarai = [10, 20, 30];

    untuk (indeks, nilai) dalam senarai.indeks_dan_item() {
        cetak("Indeks ");
        cetak(indeks);
        cetak(": ");
        cetak(nilai);
        cetak("\n");
    }

    pulang 0;
}

fungsi utama() -> Nombor kesan Tulis {
    biar senarai = [1, 2, 3, 4, 5];
    cetak("Panjang: ");
    cetak(senarai.panjang());
    cetak("\n");

    biar ubahan = senarai.peta(fungsi(x: Nombor) -> Nombor { x * 2 });
    cetak("Ubahan: ");
    cetak(ubahan);
    cetak("\n");

    iterasi_senarai();

    pulang 0;
}

/// GRAMMAR NOTE: Senarai<T> is the list type.
/// List literals: [expr1, expr2, ...]
/// Empty list requires type annotation: []: Senarai<T>
/// Common methods: panjang, peta, tapis, lipat, cari, gabung, potong
/// Indexing: senarai[i] (returns element or panics if out of bounds)

// === 07_EXAMPLES/00_basics/loops_for.rii ===
/// LOOPS_FOR.RII - For Loop Over Collections
/// Gelung untuk (for) untuk iterasi koleksi
/// Demonstrates: for-in loops, ranges, iteration

fungsi gelung_senarai() -> Nombor kesan Tulis {
    /// Untuk-dalam gelung atas senarai
    /// For-in loop over list
    biar senarai = [1, 2, 3, 4, 5];

    untuk item dalam senarai {
        cetak("Item: ");
        cetak(item);
        cetak("\n");
    }

    pulang 0;
}

fungsi gelung_julat() -> Nombor kesan Tulis {
    /// Gelung atas julat 0..10 (tidak termasuk 10)
    /// Loop over range 0..10 (exclusive end)
    untuk i dalam 0..10 {
        cetak("Nombor: ");
        cetak(i);
        cetak("\n");
    }

    /// Gelung dengan julat termasuk (0..=10)
    /// Loop with inclusive range 0..=10
    untuk j dalam 0..=5 {
        cetak("Inklusif: ");
        cetak(j);
        cetak("\n");
    }

    pulang 0;
}

fungsi hitung_jumlah_senarai() -> Nombor kesan Bersih {
    /// Hitung jumlah elemen dalam senarai
    /// Sum elements in list
    biar senarai = [1, 2, 3, 4, 5];
    biar ubah jumlah = 0;

    untuk x dalam senarai {
        jumlah = jumlah + x;
    }

    pulang jumlah;    /// Result: 15
}

fungsi format_senarai() -> Nombor kesan Tulis {
    /// Format senarai dengan indeks
    /// Format list with indices
    biar nama_nama = ["Ahmad", "Siti", "Budi"];

    untuk (indeks, nama) dalam nama_nama.indeks_dan_item() {
        cetak("Indeks ");
        cetak(indeks);
        cetak(": ");
        cetak(nama);
        cetak("\n");
    }

    pulang 0;
}

fungsi gelung_bersarang() -> Nombor kesan Tulis {
    /// Gelung bersarang (nested loops)
    /// Nested loops
    untuk i dalam 1..3 {
        untuk j dalam 1..3 {
            cetak("(");
            cetak(i);
            cetak(",");
            cetak(j);
            cetak(") ");
        }
        cetak("\n");
    }

    pulang 0;
}

fungsi utama() -> Nombor kesan Tulis {
    gelung_senarai();
    cetak("---\n");
    gelung_julat();
    cetak("---\n");
    hitung_jumlah_senarai();
    cetak("---\n");
    gelung_bersarang();

    pulang 0;
}

/// GRAMMAR NOTE: untuk (for) with dalam (in) keyword.
/// Ranges: 0..10 (exclusive) or 0..=10 (inclusive).
/// Collections are iterable: senarai, strings, ranges, etc.
/// Destructuring in for loops: untuk (x, y) dalam ... {}

// === 07_EXAMPLES/00_basics/loops_infinite.rii ===
/// LOOPS_INFINITE.RII - Infinite Loops with Break
/// Gelung tak terhingga dengan ulang dan putus
/// Demonstrates: infinite loops, break, continue, loop control

fungsi gelung_tak_terhingga_mudah() -> Nombor kesan Tulis {
    /// Gelung tak terhingga dengan break
    /// Infinite loop with explicit break
    biar ubah i = 0;

    ulang {
        cetak("Gelung: ");
        cetak(i);
        cetak("\n");

        i = i + 1;

        /// Keluar dari gelung apabila i >= 5
        /// Break when i >= 5
        kalau i >= 5 {
            putus;
        }
    }

    cetak("Selesai!\n");
    pulang 0;
}

fungsi proses_amalan() -> Nombor kesan (Tulis, Baca) {
    /// Gelung tak terhingga dengan input
    /// Infinite loop with user input
    ulang {
        cetak("Masukkan perintah (q untuk keluar): ");
        biar perintah = baca_garisan();

        kalau perintah == "q" {
            putus;
        }

        cetak("Anda masukkan: ");
        cetak(perintah);
        cetak("\n");
    }

    pulang 0;
}

fungsi lanjut_contoh() -> Nombor kesan Tulis {
    /// Gunakan lanjut untuk langkau iterasi
    /// Use continue to skip iteration
    ulang {
        biar ubah x = 0;

        ulang {
            x = x + 1;

            /// Langkau jika genap
            /// Skip if even
            kalau x % 2 == 0 {
                lanjut;
            }

            cetak("Ganjil: ");
            cetak(x);
            cetak("\n");

            kalau x >= 9 {
                putus;
            }
        }

        /// Putus dari gelung luar
        /// Break from outer loop
        putus;
    }

    pulang 0;
}

fungsi bendera_keluar() -> Nombor kesan Tulis {
    /// Gunakan bendera untuk kontrol gelung
    /// Use flag for loop control
    biar ubah terus = betul;
    biar ubah kiraan = 0;

    ulang {
        kalau !terus {
            putus;
        }

        cetak("Kiraan: ");
        cetak(kiraan);
        cetak("\n");

        kiraan = kiraan + 1;

        kalau kiraan >= 10 {
            terus = salah;
        }
    }

    pulang 0;
}

fungsi gelung_bersarang_keluar() -> Nombor kesan Tulis {
    /// Gelung bersarang dengan keluar
    /// Nested loops with break
    biar ubah keluar = salah;

    ulang {
        biar ubah i = 0;

        ulang {
            cetak("(");
            cetak(i);
            cetak(") ");

            i = i + 1;

            kalau i >= 3 {
                cetak("\n");
                putus;
            }
        }

        keluar = betul;
        putus;
    }

    pulang 0;
}

fungsi utama() -> Nombor kesan Tulis {
    gelung_tak_terhingga_mudah();
    cetak("---\n");

    lanjut_contoh();
    cetak("---\n");

    bendera_keluar();

    pulang 0;
}

/// GRAMMAR NOTE: ulang (loop) for infinite loops.
/// putus (break) to exit loop.
/// lanjut (continue) to skip to next iteration.
/// Labeled breaks for nested loops may be supported: `putus 'label`.

// === 07_EXAMPLES/00_basics/loops_while.rii ===
/// LOOPS_WHILE.RII - While Loops for Conditional Iteration
/// Gelung selagi (while) untuk iterasi bersyarat
/// Demonstrates: while loops, conditions, loop control

fungsi gelung_selagi_mudah() -> Nombor kesan Tulis {
    /// Gelung selagi dengan syarat
    /// While loop with condition
    biar ubah i = 0;

    selagi i < 5 {
        cetak("Nilai i: ");
        cetak(i);
        cetak("\n");
        i = i + 1;
    }

    pulang 0;
}

fungsi hitung_dengan_syarat() -> Nombor kesan Bersih {
    /// Hitung dengan syarat kompleks
    /// Count with complex condition
    biar ubah bilangan = 1;
    biar ubah kuasa = 1;

    selagi kuasa < 100 {
        kuasa = kuasa * 2;
        bilangan = bilangan + 1;
    }

    pulang bilangan;    /// Bilangan bagi 2^n < 100
}

fungsi cari_elemen() -> Nombor kesan Bersih {
    /// Cari indeks elemen dalam senarai
    /// Find index of element in list
    biar senarai = [10, 20, 30, 40, 50];
    biar ubah indeks = 0;
    biar ubah didapati = salah;

    selagi indeks < senarai.panjang() {
        kalau senarai[indeks] == 30 {
            didapati = betul;
            /// Keluar dari gelung dengan break (jika disokong)
            /// Break from loop if supported
            putus;
        }
        indeks = indeks + 1;
    }

    pulang indeks;
}

fungsi baca_sehingga_selesai() -> Nombor kesan Baca {
    /// Gelung selagi dengan pembacaan
    /// While loop with input (pseudo-code)
    biar ubah garisan = baca_garisan();

    selagi garisan != "selesai" {
        cetak("Anda masukkan: ");
        cetak(garisan);
        cetak("\n");
        garisan = baca_garisan();
    }

    cetak("Selesai!\n");
    pulang 0;
}

fungsi selagi_dengan_atau() -> Nombor kesan Bersih {
    /// Gelung dengan OR dalam syarat
    /// While loop with OR condition
    biar ubah x = 0;
    biar ubah y = 10;

    selagi x < 5 || y > 0 {
        x = x + 1;
        y = y - 1;
    }

    pulang x + y;
}

fungsi selagi_dengan_tidak() -> Nombor kesan Bersih {
    /// Gelung dengan NOT dalam syarat
    /// While loop with NOT condition
    biar ubah selesai = salah;

    selagi !selesai {
        cetak("Bekerja...\n");
        selesai = betul;
    }

    pulang 0;
}

fungsi utama() -> Nombor kesan Tulis {
    gelung_selagi_mudah();
    cetak("---\n");

    biar hasil = hitung_dengan_syarat();
    cetak("Hasil: ");
    cetak(hasil);
    cetak("\n");

    pulang 0;
}

/// GRAMMAR NOTE: selagi (while) with condition.
/// Loop continues while condition is true.
/// Use putus (break) to exit loop early.
/// Use lanjut (continue) to skip to next iteration.

// === 07_EXAMPLES/00_basics/options.rii ===
/// OPTIONS.RII - Optional Values with Mungkin Type
/// Nilai opsional dengan jenis Mungkin (Maybe/Option)
/// Demonstrates: Option/Maybe type, pattern matching, unwrapping

fungsi ambil_mungkin() -> Mungkin<Nombor> kesan Bersih {
    /// Kembalikan Ada (Some value)
    /// Return Ada (Some)
    pulang Ada(42);
}

fungsi ambil_tiada() -> Mungkin<Teks> kesan Bersih {
    /// Kembalikan Tidak (None)
    /// Return Tidak (None)
    pulang Tidak;
}

fungsi padan_mungkin(m: Mungkin<Nombor>) -> Teks kesan Bersih {
    /// Corak padankan dengan Mungkin
    /// Pattern match with Mungkin
    padan m {
        Ada(n) -> "Ada nilai: {n}",
        Tidak -> "Tiada nilai",
    }
}

fungsi gelap_mungkin(m: Mungkin<Nombor>) -> Teks kesan Bersih {
    /// Gelang (wrap) nilai dalam Mungkin
    /// Wrap value in Mungkin
    biar hasil = m.peta(fungsi(x: Nombor) -> Nombor {
        pulang x * 2;
    });

    padan hasil {
        Ada(n) -> "Dua kali: {n}",
        Tidak -> "Tiada untuk diubah",
    }
}

fungsi dapatkan_atau_lalai(m: Mungkin<Nombor>, lalai: Nombor) -> Nombor kesan Bersih {
    /// Dapatkan nilai atau gunakan lalai
    /// Get value or use default
    padan m {
        Ada(n) -> n,
        Tidak -> lalai,
    }
}

fungsi gabung_mungkin(m1: Mungkin<Nombor>, m2: Mungkin<Nombor>) -> Mungkin<Nombor> kesan Bersih {
    /// Gabung dua Mungkin
    /// Combine two Mungkin values
    padan (m1, m2) {
        (Ada(a), Ada(b)) -> Ada(a + b),
        _ -> Tidak,
    }
}

fungsi rantai_mungkin() -> Mungkin<Nombor> kesan Bersih {
    /// Rantai operasi pada Mungkin
    /// Chain operations on Mungkin
    biar m = Ada(5);

    biar hasil = m
        .peta(fungsi(x: Nombor) -> Nombor { x * 2 })    /// Ada(10)
        .peta(fungsi(x: Nombor) -> Nombor { x + 3 })    /// Ada(13)
        ;

    pulang hasil;
}

fungsi selamat_pembukaan(m: Mungkin<Teks>) -> Teks kesan Bersih {
    /// Buka dengan selamat (safe unwrap)
    /// Safe unwrap with default
    padan m {
        Ada(t) -> t,
        Tidak -> "kosong",
    }
}

fungsi paksa_pembukaan(m: Mungkin<Nombor>) -> Nombor kesan Bersih {
    /// Buka dengan paksa (panics jika Tidak)
    /// Forced unwrap (panics if Tidak)
    padan m {
        Ada(n) -> n,
        Tidak -> {
            cetak("RALAT: Percubaan membuka Tidak!\n");
            /// Dalam implementasi sebenar, ini akan panic
            /// In real implementation, this would panic
            pulang 0;
        }
    }
}

fungsi saring_ada(senarai: Senarai<Mungkin<Nombor>>) -> Senarai<Nombor> kesan Bersih {
    /// Saring hanya elemen Ada
    /// Filter only Ada values
    senarai.tapis(fungsi(m: Mungkin<Nombor>) -> Benar {
        padan m {
            Ada(_) -> betul,
            Tidak -> salah,
        }
    }).peta(fungsi(m: Mungkin<Nombor>) -> Nombor {
        padan m {
            Ada(n) -> n,
            _ -> 0,    /// Tidak boleh terjadi
        }
    })
}

fungsi cari_mungkin(senarai: Senarai<Nombor>) -> Mungkin<Nombor> kesan Bersih {
    /// Cari elemen dalam senarai, kembalikan Mungkin
    /// Search list, return Mungkin
    untuk x dalam senarai {
        kalau x > 10 {
            pulang Ada(x);
        }
    }

    pulang Tidak;
}

fungsi utama() -> Nombor kesan Tulis {
    biar m1 = Ada(42);
    biar hasil1 = padan_mungkin(m1);
    cetak(hasil1);
    cetak("\n");

    biar m2 = Tidak;
    biar hasil2 = padan_mungkin(m2);
    cetak(hasil2);
    cetak("\n");

    biar nilai = dapatkan_atau_lalai(Ada(10), 0);
    cetak("Nilai: ");
    cetak(nilai);
    cetak("\n");

    biar lalai = dapatkan_atau_lalai(Tidak, 99);
    cetak("Lalai: ");
    cetak(lalai);
    cetak("\n");

    pulang 0;
}

/// GRAMMAR NOTE: Mungkin<T> is the Option/Maybe type.
/// Variants: Ada(T) for Some, Tidak for None.
/// Pattern matching handles both cases.
/// Method chaining with peta, tapis, lipat for functional operations.

// === 07_EXAMPLES/00_basics/pairs.rii ===
/// PAIRS.RII - Tuples and Pair Operations
/// Pasangan (tuple) dan operasi padanya
/// Demonstrates: pair/tuple creation, destructuring, nested tuples

fungsi buat_pasangan() -> (Nombor, Teks) kesan Bersih {
    /// Buat pasangan (tuple) dengan dua elemen
    /// Create a pair (2-tuple)
    biar pasangan = (42, "Ahmad");

    /// Akses elemen pasangan dengan indeks (dot notation)
    /// Access tuple elements
    biar pertama = pasangan.0;       /// 42
    biar kedua = pasangan.1;         /// "Ahmad"

    pulang pasangan;
}

fungsi struktur_pasangan() -> Nombor kesan Bersih {
    /// Buat pasangan tiga elemen (triple)
    /// Create a 3-tuple
    biar triple = (1, 2, 3);

    /// Nyahstruktur pasangan dalam let binding
    /// Destructure tuple in let binding
    biar (a, b, c) = triple;

    pulang a + b + c;    /// 6
}

fungsi pasangan_bersarang() -> Nombor kesan Bersih {
    /// Pasangan bersarang (nested tuples)
    /// Nested tuples
    biar bersarang = ((1, 2), (3, 4));

    /// Nyahstruktur bersarang
    /// Destructure nested
    biar ((a, b), (c, d)) = bersarang;

    pulang a + b + c + d;    /// 10
}

fungsi kembalikan_berbilang() -> (Teks, Nombor, Benar) kesan Bersih {
    /// Kembalikan pasangan dengan berbilang nilai
    /// Return multiple values as tuple
    pulang ("Berjaya", 42, betul);
}

fungsi gunakan_kembalian() -> Nombor kesan Tulis {
    /// Nyahstruktur hasil
    /// Destructure the result
    biar (mesej, nombor, ok) = kembalikan_berbilang();

    cetak(mesej);
    cetak(": ");
    cetak(nombor);
    cetak(" (");
    cetak(ok);
    cetak(")\n");

    pulang nombor;
}

fungsi pasangan_dalam_padan() -> Teks kesan Bersih {
    /// Gunakan pasangan dalam padan (match)
    /// Use tuple in pattern matching
    biar p = (10, 20);

    padan p {
        (0, 0) -> "Kedua kosong",
        (x, 0) -> "Kedua kosong",
        (x, y) kalau x == y -> "Sama",
        (x, y) -> "Berbeza: {x} != {y}",
    }
}

fungsi pertukaran_pasangan() -> (Teks, Nombor) kesan Bersih {
    /// Pertukaran elemen pasangan
    /// Swap elements of tuple
    biar (nama, umur) = ("Ahmad", 25);

    /// Buat pasangan baru dengan urutan terbalik
    /// Create new tuple with swapped order
    pulang (umur, nama);    /// (25, "Ahmad")
}

/// Struct dengan tiga medan
/// Struct with three fields
jenis Titik {
    x: Nombor,
    y: Nombor,
    z: Nombor,
}

fungsi titik_ke_pasangan(t: Titik) -> (Nombor, Nombor, Nombor) kesan Bersih {
    /// Tukar struct ke pasangan
    /// Convert struct to tuple
    pulang (t.x, t.y, t.z);
}

fungsi pasangan_ke_titik(p: (Nombor, Nombor, Nombor)) -> Titik kesan Bersih {
    /// Tukar pasangan ke struct
    /// Convert tuple to struct
    biar (x, y, z) = p;
    pulang Titik { x: x, y: y, z: z };
}

fungsi utama() -> Nombor kesan Tulis {
    biar (teks, nombor, bol) = kembalikan_berbilang();
    cetak("Tiga nilai: ");
    cetak(teks);
    cetak(", ");
    cetak(nombor);
    cetak(", ");
    cetak(bol);
    cetak("\n");

    gunakan_kembalian();

    pulang 0;
}

/// GRAMMAR NOTE: Tuples use (T1, T2, ..., Tn) syntax.
/// Access with dot notation: tuple.0, tuple.1, etc.
/// Destructuring with (a, b, c) = tuple_expr
/// Empty tuple () is the unit type.

// === 07_EXAMPLES/00_basics/pattern_match.rii ===
/// PATTERN_MATCH.RII - Pattern Matching with padan
/// Pemadanan corak dengan padan (match)
/// Demonstrates: match expressions, exhaustiveness, destructuring

fungsi periksaNombor(x: Nombor) -> Teks kesan Bersih {
    /// Padan dengan nilai literal
    /// Match with literal values
    padan x {
        0 -> "kosong",
        1 -> "satu",
        2 -> "dua",
        3 -> "tiga",
        _ -> "lain",    /// Wildcard pattern
    }
}

fungsi padanBenar(b: Benar) -> Teks kesan Bersih {
    /// Padan boolean
    /// Match boolean
    padan b {
        betul -> "Benar",
        salah -> "Salah",
    }
}

fungsi periksaMungkin(m: Mungkin<Nombor>) -> Teks kesan Bersih {
    /// Padan dengan Option/Maybe type
    /// Match with Option type
    padan m {
        Ada(n) -> "Ada nombor: {n}",
        Tidak -> "Tiada nilai",
    }
}

fungsi periksaHasil(h: Hasil<Nombor, Teks>) -> Teks kesan Bersih {
    /// Padan dengan Result type
    /// Match with Result type
    padan h {
        Ok(n) -> "Berjaya: {n}",
        Ralat(e) -> "Ralat: {e}",
    }
}

fungsi padanTeks(nama: Teks) -> Teks kesan Bersih {
    /// Padan dengan string
    /// Match with string
    padan nama {
        "Ahmad" -> "Selamat pagi Ahmad!",
        "Siti" -> "Selamat pagi Siti!",
        "Budi" -> "Selamat pagi Budi!",
        _ -> "Selamat pagi, {nama}!",
    }
}

fungsi padanGanda(x: Nombor, y: Nombor) -> Teks kesan Bersih {
    /// Padan dengan tuple (pasangan)
    /// Match with tuple
    padan (x, y) {
        (0, 0) -> "Kedua kosong",
        (0, _) -> "x kosong",
        (_, 0) -> "y kosong",
        (a, b) -> "x={a}, y={b}",
    }
}

fungsi padanRujukan(r: Ruj<Nombor>@Awam) -> Teks kesan Bersih {
    /// Padan dengan rujukan (reference)
    /// Match with reference
    padan r {
        ruj(0) -> "Rujuk ke kosong",
        ruj(x) -> "Rujuk ke {x}",
    }
}

fungsi padanListEmpty(s: Senarai<Nombor>) -> Teks kesan Bersih {
    /// Padan dengan senarai
    /// Match with list
    padan s {
        [] -> "Senarai kosong",
        [x] -> "Satu elemen: {x}",
        [x, y] -> "Dua elemen: {x}, {y}",
        [x, y, ..rest] -> "Banyak elemen",
    }
}

/// Enum dengan data berlainan
/// Enum with associated data
jenis Bentuk {
    Bulatan(jejari: Nombor),
    Segi(panjang: Nombor, lebar: Nombor),
    Segitiga(a: Nombor, b: Nombor, c: Nombor),
}

fungsi luas_bentuk(b: Bentuk) -> Nombor kesan Bersih {
    /// Padan dengan enum yang mempunyai data
    /// Match with enum containing data
    padan b {
        Bulatan(r) -> 3 * r * r,
        Segi(p, l) -> p * l,
        Segitiga(a, b, c) -> {
            /// Formula Heron (simplified)
            biar s = (a + b + c) / 2;
            s * (s - a) * (s - b) * (s - c)
        }
    }
}

fungsi utama() -> Nombor kesan Tulis {
    biar hasil1 = periksaNombor(2);
    cetak(hasil1);
    cetak("\n");

    biar hasil2 = padanTeks("Ahmad");
    cetak(hasil2);
    cetak("\n");

    biar hasil3 = padanGanda(5, 10);
    cetak(hasil3);
    cetak("\n");

    pulang 0;
}

/// GRAMMAR NOTE: padan (match) expression.
/// Patterns are exhaustive â€” compiler checks all cases.
/// _ is wildcard pattern matching anything.
/// Patterns with guards: `padan { ... if condition -> ...}`

// === 07_EXAMPLES/00_basics/pipe_operator.rii ===
/// PIPE_OPERATOR.RII - Pipe Operator for Function Chaining
/// Pengendali paip (|>) untuk rantai fungsi
/// Demonstrates: pipe operator, readability, functional composition

fungsi darab_dua(x: Nombor) -> Nombor kesan Bersih {
    pulang x * 2;
}

fungsi tambah_satu(x: Nombor) -> Nombor kesan Bersih {
    pulang x + 1;
}

fungsi kurang_tiga(x: Nombor) -> Nombor kesan Bersih {
    pulang x - 3;
}

fungsi format_teks(x: Nombor) -> Teks kesan Bersih {
    pulang "Hasil: {x}";
}

fungsi operasi_bersarang() -> Teks kesan Bersih {
    /// Cara tradisional - bersarang
    /// Traditional way - nested
    biar hasil = format_teks(kurang_tiga(tambah_satu(darab_dua(5))));
    /// 5 * 2 = 10 -> 10 + 1 = 11 -> 11 - 3 = 8

    pulang hasil;
}

fungsi operasi_dengan_paip() -> Teks kesan Bersih {
    /// Menggunakan paip - lebih jelas
    /// Using pipe - more readable
    biar hasil = 5
        |> darab_dua
        |> tambah_satu
        |> kurang_tiga
        |> format_teks;

    pulang hasil;
}

fungsi dengan_paip_dan_lambda() -> Teks kesan Bersih {
    /// Paip dengan ungkapan lambda
    /// Pipe with lambda expressions
    biar hasil = 10
        |> fungsi(x: Nombor) -> Nombor { x + 5 }
        |> fungsi(x: Nombor) -> Nombor { x * 2 }
        |> format_teks;

    pulang hasil;
}

fungsi paip_pada_senarai() -> Senarai<Nombor> kesan Bersih {
    /// Paip dengan operasi senarai
    /// Pipe with list operations
    biar hasil = [1, 2, 3, 4, 5]
        |> fungsi(s: Senarai<Nombor>) -> Senarai<Nombor> {
            s.peta(fungsi(x: Nombor) -> Nombor { x * 2 })
        }
        |> fungsi(s: Senarai<Nombor>) -> Senarai<Nombor> {
            s.tapis(fungsi(x: Nombor) -> Benar { x > 4 })
        };

    pulang hasil;    /// [6, 8, 10]
}

fungsi paip_kompleks() -> Nombor kesan Bersih {
    /// Paip dengan berbilang langkah dan terjemahan
    /// Complex pipe with multiple steps
    biar hasil = [1, 2, 3, 4, 5]
        |> fungsi(s: Senarai<Nombor>) -> Senarai<Nombor> {
            /// Gandakan setiap elemen
            s.peta(fungsi(x: Nombor) -> Nombor { x * 2 })
        }
        |> fungsi(s: Senarai<Nombor>) -> Senarai<Nombor> {
            /// Saring elemen ganjil
            s.tapis(fungsi(x: Nombor) -> Benar { x % 2 == 1 })
        }
        |> fungsi(s: Senarai<Nombor>) -> Nombor {
            /// Hitung jumlah
            s.lipat(0, fungsi(a: Nombor, b: Nombor) -> Nombor { a + b })
        };

    pulang hasil;
}

fungsi paip_dengan_kesan() -> Nombor kesan (Tulis, Bersih) {
    /// Paip dengan operasi yang mempunyai kesan samping
    /// Pipe with side-effect operations
    biar hasil = 42
        |> fungsi(x: Nombor) -> Nombor {
            cetak("Awal: ");
            cetak(x);
            cetak("\n");
            pulang x;
        }
        |> darab_dua
        |> fungsi(x: Nombor) -> Nombor {
            cetak("Selepas darab: ");
            cetak(x);
            cetak("\n");
            pulang x;
        }
        |> tambah_satu
        |> fungsi(x: Nombor) -> Nombor {
            cetak("Akhir: ");
            cetak(x);
            cetak("\n");
            pulang x;
        };

    pulang hasil;
}

fungsi utama() -> Nombor kesan Tulis {
    cetak("=== Cara Tradisional ===\n");
    biar hasil1 = operasi_bersarang();
    cetak(hasil1);
    cetak("\n\n");

    cetak("=== Dengan Paip ===\n");
    biar hasil2 = operasi_dengan_paip();
    cetak(hasil2);
    cetak("\n\n");

    cetak("=== Paip pada Senarai ===\n");
    biar hasil3 = paip_pada_senarai();
    cetak(hasil3);
    cetak("\n\n");

    cetak("=== Paip Kompleks ===\n");
    biar hasil4 = paip_kompleks();
    cetak("Jumlah: ");
    cetak(hasil4);
    cetak("\n\n");

    cetak("=== Paip dengan Kesan ===\n");
    paip_dengan_kesan();

    pulang 0;
}

/// GRAMMAR NOTE: |> is the pipe operator.
/// Pipes value from left expression into right function.
/// Equivalent to function application but reads left-to-right.
/// Improves readability of functional compositions.
/// Works with any function: f |> g |> h is equivalent to h(g(f))

// === 07_EXAMPLES/00_basics/recursion.rii ===
/// RECURSION.RII - Recursive Functions
/// Fungsi rekursif dalam RIINA
/// Demonstrates: base case, recursive case, tail recursion, accumulator

fungsi faktorial(n: Nombor) -> Nombor kesan Bersih {
    /// Kes asas (base case)
    /// Base case: 0! = 1
    kalau n == 0 {
        pulang 1;
    }

    /// Kes rekursif (recursive case)
    /// Recursive case: n! = n * (n-1)!
    pulang n * faktorial(n - 1);
}

fungsi fibonacci(n: Nombor) -> Nombor kesan Bersih {
    /// Fibonacci dengan rekursi langsung
    /// Fibonacci with direct recursion
    kalau n <= 1 {
        pulang n;
    }

    pulang fibonacci(n - 1) + fibonacci(n - 2);
}

fungsi fibonacci_enak(n: Nombor) -> Nombor kesan Bersih {
    /// Fibonacci dengan akumulator (lebih baik)
    /// Fibonacci with accumulator (more efficient)
    fungsi fib_akum(n: Nombor, a: Nombor, b: Nombor) -> Nombor {
        kalau n == 0 {
            pulang a;
        }

        pulang fib_akum(n - 1, b, a + b);
    }

    pulang fib_akum(n, 0, 1);
}

fungsi kuasa(asas: Nombor, eksponen: Nombor) -> Nombor kesan Bersih {
    /// Kuasa dengan rekursi
    /// Power with recursion
    kalau eksponen == 0 {
        pulang 1;
    }

    pulang asas * kuasa(asas, eksponen - 1);
}

fungsi kuasa_enak(asas: Nombor, eksponen: Nombor) -> Nombor kesan Bersih {
    /// Kuasa dengan akumulator (tail recursion)
    /// Power with accumulator (tail recursive)
    fungsi kuasa_akum(asas: Nombor, eksponen: Nombor, hasil: Nombor) -> Nombor {
        kalau eksponen == 0 {
            pulang hasil;
        }

        pulang kuasa_akum(asas, eksponen - 1, hasil * asas);
    }

    pulang kuasa_akum(asas, eksponen, 1);
}

fungsi panjang_senarai(s: Senarai<Nombor>) -> Nombor kesan Bersih {
    /// Panjang senarai dengan rekursi
    /// List length with recursion
    padan s {
        [] -> 0,
        [_] -> 1,
        [_, ..ekor] -> 1 + panjang_senarai(ekor),
    }
}

fungsi jumlah_senarai(s: Senarai<Nombor>) -> Nombor kesan Bersih {
    /// Jumlah unsur dengan rekursi
    /// Sum of elements with recursion
    padan s {
        [] -> 0,
        [x] -> x,
        [x, ..ekor] -> x + jumlah_senarai(ekor),
    }
}

fungsi balik_senarai(s: Senarai<Nombor>) -> Senarai<Nombor> kesan Bersih {
    /// Balik senarai dengan rekursi
    /// Reverse list with recursion
    fungsi balik_akum(s: Senarai<Nombor>, akum: Senarai<Nombor>) -> Senarai<Nombor> {
        padan s {
            [] -> akum,
            [x, ..ekor] -> balik_akum(ekor, [x] + akum),
        }
    }

    pulang balik_akum(s, []);
}

fungsi cari_dalam_senarai(s: Senarai<Nombor>, cari: Nombor) -> Benar kesan Bersih {
    /// Cari elemen dalam senarai
    /// Search element in list
    padan s {
        [] -> salah,
        [x, ..ekor] kalau x == cari -> betul,
        [x, ..ekor] -> cari_dalam_senarai(ekor, cari),
    }
}

fungsi pohon_kedalaman_pertama(n: Nombor) -> Nombor kesan Tulis {
    /// Traversal pohon (depth-first) dengan rekursi
    /// Tree traversal (depth-first) with recursion
    kalau n == 0 {
        pulang 0;
    }

    cetak("Nod: ");
    cetak(n);
    cetak("\n");

    /// Rekursi pada anak-anak (simplified)
    pohon_kedalaman_pertama(n - 1);

    pulang 0;
}

fungsi utama() -> Nombor kesan Tulis {
    cetak("Faktorial 5: ");
    cetak(faktorial(5));
    cetak("\n");

    cetak("Fibonacci 10: ");
    cetak(fibonacci(10));
    cetak("\n");

    cetak("Fibonacci enak 10: ");
    cetak(fibonacci_enak(10));
    cetak("\n");

    cetak("Kuasa 2^8: ");
    cetak(kuasa(2, 8));
    cetak("\n");

    cetak("Kuasa enak 2^8: ");
    cetak(kuasa_enak(2, 8));
    cetak("\n");

    biar senarai = [1, 2, 3, 4, 5];
    cetak("Panjang: ");
    cetak(panjang_senarai(senarai));
    cetak("\n");

    cetak("Jumlah: ");
    cetak(jumlah_senarai(senarai));
    cetak("\n");

    cetak("Cari 3: ");
    cetak(cari_dalam_senarai(senarai, 3));
    cetak("\n");

    pulang 0;
}

/// GRAMMAR NOTE: Recursive functions call themselves.
/// Base case must exist to prevent infinite recursion.
/// Tail recursion can be optimized to loops by compiler.
/// Accumulators improve efficiency for tail-recursive functions.

// === 07_EXAMPLES/00_basics/strings.rii ===
/// STRINGS.RII - String Operations and Manipulation
/// Operasi pada rentetan (teks) dalam RIINA
/// Demonstrates: string literals, concatenation, interpolation, methods

fungsi operasiTeks() -> Teks kesan Bersih {
    /// Rentetan literal
    /// String literal
    biar nama = "Ahmad";

    /// Rentetan multi-baris
    /// Multi-line string
    biar panjang = "Ini adalah
    rentetan dengan
    banyak baris";

    /// Gabung string dengan +
    /// Concatenate strings with +
    biar gabung = "Selamat " + "pagi " + nama;

    /// Interpolasi string (template string)
    /// String interpolation
    biar umur = 25;
    biar dipoles = "Saya {nama} berumur {umur} tahun";

    /// Panjang string
    /// String length (method call)
    biar panjang_nama = nama.panjang();

    /// Ubah ke huruf besar
    /// Convert to uppercase
    biar besar = nama.besarkan();

    /// Ubah ke huruf kecil
    /// Convert to lowercase
    biar kecil = nama.kecilkan();

    /// Potong string
    /// Slice string
    biar potongan = nama.potong(0, 2);  /// "Ah"

    /// Cari substring
    /// Find substring
    biar ada = nama.ada("mah");         /// true

    pulang gabung;
}

fungsi utama() -> Nombor kesan Tulis {
    biar teks = operasiTeks();
    cetak(teks);
    cetak("\n");
    pulang 0;
}

/// GRAMMAR NOTE: Teks is the immutable string type.
/// String literals use double quotes: "..."
/// String interpolation with {expr} inside literal strings.
/// All string methods return new strings (immutable).

// === 07_EXAMPLES/00_basics/type_annotations.rii ===
/// TYPE_ANNOTATIONS.RII - Explicit Type Annotations
/// Anotasi jenis eksplisit untuk kejelasan
/// Demonstrates: function signatures, variable types, generic types

/// Fungsi dengan anotasi lengkap
/// Function with complete type annotations
fungsi tambah_dua_nombor(x: Nombor, y: Nombor) -> Nombor kesan Bersih {
    pulang x + y;
}

/// Fungsi dengan banyak parameter
/// Function with multiple parameters
fungsi gabung_teks(a: Teks, b: Teks, c: Teks) -> Teks kesan Bersih {
    pulang a + " " + b + " " + c;
}

/// Fungsi yang mengembalikan boolean
/// Function returning boolean
fungsi sama_tak(a: Nombor, b: Nombor) -> Benar kesan Bersih {
    pulang a == b;
}

/// Fungsi dengan jenis generic
/// Function with generic type
fungsi identiti<T>(x: T) -> T kesan Bersih {
    pulang x;
}

/// Fungsi dengan senarai
/// Function with list
fungsi panjang_senarai(s: Senarai<Nombor>) -> Nombor kesan Bersih {
    pulang s.panjang();
}

/// Fungsi dengan Mungkin (Option)
/// Function with Maybe/Option
fungsi ambil_atau_lalai(m: Mungkin<Nombor>, lalai: Nombor) -> Nombor kesan Bersih {
    padan m {
        Ada(n) -> n,
        Tidak -> lalai,
    }
}

/// Fungsi dengan Hasil (Result)
/// Function with Result type
fungsi buka_fail(nama: Teks) -> Hasil<Teks, Teks> kesan Baca {
    /// Simulasi buka fail
    pulang Ok("kandungan fail");
}

/// Fungsi dengan ujung (closure/function type)
/// Function with function type
fungsi gunakan_pada_senarai(
    senarai: Senarai<Nombor>,
    f: Fn(Nombor) -> Nombor
) -> Senarai<Nombor> kesan Bersih {
    senarai.peta(f)
}

/// Fungsi dengan Rujukan (Reference)
/// Function with Reference type
fungsi ubah_ruj(r: Ruj<Nombor>@Dalaman) -> Nombor kesan Bersih {
    padan r {
        ruj(n) -> n,
    }
}

/// Fungsi dengan jenis Rahsia (Secret)
/// Function with Secret type
fungsi simpan_rahsia(s: Rahsia<Teks>) -> Nombor kesan Bersih {
    /// Operasi pada data rahsia
    pulang 0;
}

/// Jenis yang ditakrifkan pengguna
/// User-defined type
jenis Titik {
    x: Nombor,
    y: Nombor,
    z: Nombor,
}

/// Fungsi dengan jenis tersuai
/// Function with custom type
fungsi jarak_dari_asal(p: Titik) -> Nombor kesan Bersih {
    /// Jarak = sqrt(x^2 + y^2 + z^2)
    pulang 0;
}

/// Enum jenis
/// Enum type
jenis Keputusan {
    Berjaya(Teks),
    Ralat(Teks),
    Belum(Teks),
}

/// Fungsi dengan enum
/// Function with enum
fungsi tulis_keputusan(k: Keputusan) -> Nombor kesan Tulis {
    padan k {
        Berjaya(msg) -> {
            cetak("Berjaya: ");
            cetak(msg);
            cetak("\n");
        },
        Ralat(msg) -> {
            cetak("Ralat: ");
            cetak(msg);
            cetak("\n");
        },
        Belum(msg) -> {
            cetak("Belum: ");
            cetak(msg);
            cetak("\n");
        },
    }

    pulang 0;
}

/// Fungsi dengan kesan berbilang
/// Function with multiple effects
fungsi operasi_kompleks(
    nama: Teks,
    nilai: Nombor
) -> Hasil<Nombor, Teks> kesan (Tulis, Baca, Bersih) {
    cetak("Memproses: ");
    cetak(nama);
    cetak("\n");

    kalau nilai < 0 {
        pulang Ralat("Nilai negatif");
    }

    pulang Ok(nilai * 2);
}

fungsi utama() -> Nombor kesan Tulis {
    /// Pembolehubah dengan anotasi jenis eksplisit
    /// Variables with explicit type annotations
    biar x: Nombor = 42;
    biar nama: Teks = "Ahmad";
    biar sah: Benar = betul;

    /// Senarai dengan jenis eksplisit
    /// List with explicit type
    biar senarai: Senarai<Nombor> = [1, 2, 3, 4, 5];

    /// Mungkin dengan jenis eksplisit
    /// Maybe with explicit type
    biar m: Mungkin<Teks> = Ada("nilai");

    /// Panggil fungsi
    biar hasil = tambah_dua_nombor(10, 20);
    cetak("Hasil: ");
    cetak(hasil);
    cetak("\n");

    /// Gunakan fungsi generic
    biar i = identiti(42);
    cetak("Identiti: ");
    cetak(i);
    cetak("\n");

    /// Gunakan fungsi dengan Hasil
    padan buka_fail("test.txt") {
        Ok(kandungan) -> {
            cetak("Kandungan: ");
            cetak(kandungan);
            cetak("\n");
        },
        Ralat(e) -> {
            cetak("Ralat: ");
            cetak(e);
            cetak("\n");
        },
    }

    pulang 0;
}

/// GRAMMAR NOTE: Type annotations use `:` syntax.
/// Generic types: T, U, V for type parameters.
/// Function types: Fn(T1, T2, ...) -> ReturnType
/// Complex types: Senarai<T>, Mungkin<T>, Hasil<T, E>, Ruj<T>@Level
/// Custom types: jenis and enum declarations.
/// Multiple effects in kesan: (Effect1, Effect2, ...)

// === 07_EXAMPLES/00_basics/variables.rii ===
/// VARIABLES.RII - Variable Bindings with Bahasa Melayu
/// Menunjukkan cara mengikat pembolehubah dengan biar
/// Demonstrates: let bindings, immutability, type inference

fungsi contohPembolehubah() -> Nombor kesan Bersih {
    /// Ikat pembolehubah tidak berubah
    /// Bind immutable variable with type inference
    biar x = 42;

    /// Ikat dengan jenis eksplisit
    /// Bind with explicit type annotation
    biar nama: Teks = "Ahmad";

    /// Ikat pembolehubah berubah dengan ubah
    /// Bind mutable variable with ubah modifier
    biar ubah jumlah: Nombor = 0;
    jumlah = jumlah + 10;

    /// Ikat pasangan (tuple)
    /// Bind a pair/tuple
    biar (a, b) = (1, 2);

    /// Ikat senarai
    /// Bind a list
    biar senarai: Senarai<Nombor> = [1, 2, 3, 4, 5];

    /// Kembalikan nilai terakhir
    /// Return final value (implicit return)
    pulang jumlah;
}

/// TYPE SYSTEM: All bindings are immutable by default.
/// Use `ubah` to make a binding mutable.
/// Type annotations are optional; type inference is supported.

// === 07_EXAMPLES/01_security/audit_trail.rii ===
/// AUDIT_TRAIL.RII - Security Audit Logging
/// Jejak audit untuk kebolehan jejakan keselamatan
/// Demonstrates: event logging, audit tracking, secure logging

jenis AcaraAudit {
    masa: Nombor,
    tindakan: Teks,
    pengguna: Teks,
    sumber: Teks,
    hasil: Benar,
    butiran: Teks,
}

jenis JejakAudit {
    acara_acara: Senarai<AcaraAudit>,
}

fungsi buat_jejak_audit() -> JejakAudit kesan Bersih {
    /// Buat jejak audit kosong
    JejakAudit {
        acara_acara: [],
    }
}

fungsi catat_acara_audit(
    ubah jejak: JejakAudit,
    tindakan: Teks,
    pengguna: Teks,
    sumber: Teks,
    hasil: Benar,
    butiran: Teks
) -> Nombor kesan (Tulis, Masa) {
    /// Catat acara audit
    biar acara = AcaraAudit {
        masa: ambil_waktu_kini(),
        tindakan: tindakan,
        pengguna: pengguna,
        sumber: sumber,
        hasil: hasil,
        butiran: butiran,
    };

    jejak.acara_acara = jejak.acara_acara.tambah(acara);

    /// Cetak ke log aman
    cetak("[AUDIT] ");
    cetak(tindakan);
    cetak(" oleh ");
    cetak(pengguna);
    cetak(" - ");
    cetak(butiran);
    cetak("\n");

    jejak.acara_acara.panjang()
}

fungsi catat_percubaan_akses(
    ubah jejak: JejakAudit,
    pengguna: Teks,
    sumber: Teks,
    berjaya: Benar
) -> Nombor kesan (Tulis, Masa) {
    biar hasil_teks = kalau berjaya { "BERJAYA" } lain { "GAGAL" };

    catat_acara_audit(jejak, "AKSES", pengguna, sumber, berjaya, "Akses {hasil_teks}")
}

fungsi catat_perubahan_data(
    ubah jejak: JejakAudit,
    pengguna: Teks,
    medan: Teks,
    nilai_lama: Teks,
    nilai_baru: Teks
) -> Nombor kesan (Tulis, Masa) {
    biar butiran = "Ubah {medan} dari {nilai_lama} ke {nilai_baru}";
    catat_acara_audit(jejak, "UBAH", pengguna, medan, betul, butiran)
}

fungsi catat_dedah_rahsia(
    ubah jejak: JejakAudit,
    pengguna: Teks,
    rahsia: Teks,
    justifikasi: Teks
) -> Nombor kesan (Tulis, Masa) {
    biar butiran = "Dedah {rahsia} dengan justifikasi: {justifikasi}";
    catat_acara_audit(jejak, "DEDAH", pengguna, "sistem", betul, butiran)
}

fungsi catat_kegagalan_autentikasi(
    ubah jejak: JejakAudit,
    pengguna: Teks,
    sebab: Teks
) -> Nombor kesan (Tulis, Masa) {
    catat_acara_audit(jejak, "AUTENTIKASI_GAGAL", pengguna, "autentikasi", salah, sebab)
}

fungsi catat_delegasi_keupayaan(
    ubah jejak: JejakAudit,
    pemberi: Teks,
    penerima: Teks,
    keupayaan: Teks
) -> Nombor kesan (Tulis, Masa) {
    biar butiran = "Delegasi {keupayaan} dari {pemberi} ke {penerima}";
    catat_acara_audit(jejak, "DELEGASI", pemberi, "sistem", betul, butiran)
}

fungsi cetak_jejak_audit(j: JejakAudit) -> Nombor kesan Tulis {
    /// Cetak semua acara audit
    cetak("=== Jejak Audit ===\n");
    cetak("Jumlah acara: ");
    cetak(j.acara_acara.panjang());
    cetak("\n\n");

    untuk acara dalam j.acara_acara {
        cetak("Masa: ");
        cetak(acara.masa);
        cetak("\n");

        cetak("Tindakan: ");
        cetak(acara.tindakan);
        cetak("\n");

        cetak("Pengguna: ");
        cetak(acara.pengguna);
        cetak("\n");

        cetak("Sumber: ");
        cetak(acara.sumber);
        cetak("\n");

        cetak("Hasil: ");
        cetak(acara.hasil);
        cetak("\n");

        cetak("Butiran: ");
        cetak(acara.butiran);
        cetak("\n");

        cetak("---\n");
    }

    0
}

fungsi cari_acara_audit(
    j: JejakAudit,
    pengguna: Teks
) -> Senarai<AcaraAudit> kesan Bersih {
    /// Cari semua acara untuk pengguna tertentu
    j.acara_acara.tapis(fungsi(a: AcaraAudit) -> Benar {
        a.pengguna == pengguna
    })
}

fungsi kiraan_kegagalan(j: JejakAudit) -> Nombor kesan Bersih {
    /// Hitung jumlah kegagalan
    biar ubah kira = 0;

    untuk acara dalam j.acara_acara {
        kalau !acara.hasil {
            kira = kira + 1;
        }
    }

    kira
}

fungsi utama() -> Nombor kesan (Tulis, Masa) {
    cetak("=== Jejak Audit Keselamatan ===\n");

    /// Buat jejak audit
    biar ubah jejak = buat_jejak_audit();

    /// Catat berbagai acara
    cetak("Mencatat acara...\n\n");

    catat_percubaan_akses(jejak, "ahmad", "data.txt", betul);
    catat_perubahan_data(jejak, "siti", "status", "aktif", "tidak_aktif");
    catat_dedah_rahsia(jejak, "admin", "kunci_api", "enkripsi_diperlukan");
    catat_kegagalan_autentikasi(jejak, "pengguna_tidak_sah", "kata_laluan_salah");
    catat_delegasi_keupayaan(jejak, "admin", "pengguna_baru", "baca");

    /// Cetak jejak
    cetak_jejak_audit(jejak);

    /// Cari acara untuk pengguna
    cetak("\nAcara untuk ahmad:\n");
    biar acara_ahmad = cari_acara_audit(jejak, "ahmad");
    cetak("Jumlah: ");
    cetak(acara_ahmad.panjang());
    cetak("\n");

    /// Hitung kegagalan
    cetak("\nJumlah kegagalan: ");
    cetak(kiraan_kegagalan(jejak));
    cetak("\n");

    cetak("Selesai\n");
    pulang 0;
}

/// SECURITY NOTE: AcaraAudit logs all security-relevant operations.
/// Each log entry includes timestamp, actor, action, result.
/// Audit trail is immutable for forensics.
/// Type system prevents selective deletion of logs.

// === 07_EXAMPLES/01_security/capability_basic.rii ===
/// CAPABILITY_BASIC.RII - Capability-Based Security
/// Keselamatan berasaskan keupayaan (capability)
/// Demonstrates: capabilities, rights, delegation, revocation

jenis Keupayaan<T> {
    hak: T,
    pemilik: Teks,
    diguna: Nombor,
}

jenis HakBaca {
    nama_fail: Teks,
}

jenis HakTulis {
    nama_fail: Teks,
}

jenis HakLaksana {
    nama_program: Teks,
}

fungsi buat_keupayaan_baca(fail: Teks, pemilik: Teks) -> Keupayaan<HakBaca> kesan Bersih {
    /// Buat keupayaan baca fail
    Keupayaan {
        hak: HakBaca { nama_fail: fail },
        pemilik: pemilik,
        diguna: 0,
    }
}

fungsi buat_keupayaan_tulis(fail: Teks, pemilik: Teks) -> Keupayaan<HakTulis> kesan Bersih {
    /// Buat keupayaan tulis fail
    Keupayaan {
        hak: HakTulis { nama_fail: fail },
        pemilik: pemilik,
        diguna: 0,
    }
}

fungsi baca_dengan_keupayaan(
    cap: Keupayaan<HakBaca>
) -> Hasil<Teks, Teks> kesan (Baca, MasaTetap) {
    /// Baca fail menggunakan keupayaan
    biar fail = cap.hak.nama_fail;
    Ok(baca_fail(fail))
}

fungsi tulis_dengan_keupayaan(
    ubah cap: Keupayaan<HakTulis>,
    data: Teks
) -> Hasil<Nombor, Teks> kesan (Tulis, MasaTetap) {
    /// Tulis fail menggunakan keupayaan
    biar fail = cap.hak.nama_fail;
    cap.diguna = cap.diguna + 1;
    Ok(tulis_fail(fail, data))
}

fungsi delegasi_keupayaan<T>(
    cap: Keupayaan<T>,
    penerima: Teks
) -> Keupayaan<T> kesan Bersih {
    /// Delegasi keupayaan kepada penerima
    Keupayaan {
        hak: cap.hak,
        pemilik: penerima,
        diguna: cap.diguna,
    }
}

fungsi batal_keupayaan<T>(
    ubah cap: Keupayaan<T>
) -> Benar kesan Bersih {
    /// Batalkan keupayaan dengan penetapan flag
    /// (Dalam implementasi sebenar, gunakan lebih baik mekanisme)
    betul
}

fungsi periksa_keupayaan<T>(
    cap: Keupayaan<T>,
    hak_diperlukan: Teks
) -> Benar kesan Bersih {
    /// Periksa sama ada keupayaan memiliki hak
    betul  /// Simulasi
}

fungsi keupayaan_bersyarat<T>(
    cap: Keupayaan<T>,
    syarat: Fn(Keupayaan<T>) -> Benar
) -> Hasil<Keupayaan<T>, Teks> kesan Bersih {
    /// Keupayaan dengan syarat
    kalau syarat(cap) {
        Ok(cap)
    } lain {
        Ralat("Syarat tidak penuhi")
    }
}

fungsi kadar_keupayaan(
    cap: Keupayaan<HakBaca>,
    had_maksimal: Nombor
) -> Benar kesan Bersih {
    /// Kadar (rate limit) penggunaan keupayaan
    cap.diguna < had_maksimal
}

fungsi utama() -> Nombor kesan (Baca, Tulis, Tulis) {
    cetak("=== Keupayaan Berasaskan Keselamatan ===\n");

    /// Buat keupayaan
    biar cap_baca = buat_keupayaan_baca("data.txt", "pengguna1");
    cetak("Keupayaan baca dibuat\n");

    /// Gunakan keupayaan
    padan baca_dengan_keupayaan(cap_baca) {
        Ok(kandungan) -> {
            cetak("Kandungan: ");
            cetak(kandungan);
            cetak("\n");
        },
        Ralat(e) -> {
            cetak("Ralat: ");
            cetak(e);
            cetak("\n");
        },
    }

    /// Delegasi keupayaan
    biar cap_didelegasi = delegasi_keupayaan(cap_baca, "pengguna2");
    cetak("Keupayaan didelegasi kepada pengguna2\n");

    /// Kadar keupayaan
    biar dikadar = kadar_keupayaan(cap_baca, 100);
    cetak("Keupayaan dalam had: ");
    cetak(dikadar);
    cetak("\n");

    pulang 0;
}

/// SECURITY NOTE: Keupayaan is a proof of rights.
/// Cannot be forged or copied without proper delegation.
/// Each use can be tracked (diguna counter).
/// Type system enforces capability checking.

// === 07_EXAMPLES/01_security/capability_delegation.rii ===
/// CAPABILITY_DELEGATION.RII - Capability Delegation and Transfer
/// Delegasi dan pemindahan keupayaan dengan keselamatan
/// Demonstrates: delegation, attenuation, proxy capabilities

jenis Keupayaan<T> {
    hak: T,
    pemberi: Teks,
    penerima: Teks,
    delegasi_dalam: Senarai<Teks>,
}

jenis HakFailRW {
    nama_fail: Teks,
    boleh_baca: Benar,
    boleh_tulis: Benar,
}

fungsi delegasi_keupayaan<T>(
    cap: Keupayaan<T>,
    penerima_baru: Teks
) -> Keupayaan<T> kesan Bersih {
    /// Delegasi keupayaan kepada penerima baru
    biar ubah delegasi = cap.delegasi_dalam;
    delegasi = delegasi.tambah(penerima_baru);

    Keupayaan {
        hak: cap.hak,
        pemberi: cap.pemberi,
        penerima: penerima_baru,
        delegasi_dalam: delegasi,
    }
}

fungsi kurangkan_keupayaan_rw(
    cap: Keupayaan<HakFailRW>
) -> Keupayaan<HakFailRW> kesan Bersih {
    /// Kurangkan keupayaan RW kepada R sahaja
    biar hak_baru = HakFailRW {
        nama_fail: cap.hak.nama_fail,
        boleh_baca: betul,
        boleh_tulis: salah,
    };

    Keupayaan {
        hak: hak_baru,
        pemberi: cap.pemberi,
        penerima: cap.penerima,
        delegasi_dalam: cap.delegasi_dalam,
    }
}

fungsi proksikan_keupayaan<T>(
    cap: Keupayaan<T>,
    perantara: Teks,
    tujuan: Teks
) -> Keupayaan<T> kesan Bersih {
    /// Proksikan keupayaan melalui perantara
    biar ubah delegasi = cap.delegasi_dalam;
    delegasi = delegasi.tambah(perantara);
    delegasi = delegasi.tambah(tujuan);

    Keupayaan {
        hak: cap.hak,
        pemberi: cap.pemberi,
        penerima: tujuan,
        delegasi_dalam: delegasi,
    }
}

fungsi periksa_delegasi_sah(
    cap: Keupayaan<HakFailRW>,
    peminta: Teks
) -> Benar kesan Bersih {
    /// Periksa sama ada peminta dalam rantai delegasi
    untuk pengguna dalam cap.delegasi_dalam {
        kalau pengguna == peminta {
            pulang betul;
        }
    }

    cap.penerima == peminta
}

fungsi gunakan_keupayaan_delegasi(
    cap: Keupayaan<HakFailRW>,
    peminta: Teks
) -> Hasil<Teks, Teks> kesan Baca {
    /// Gunakan keupayaan delegasi dengan verifikasi
    kalau !periksa_delegasi_sah(cap, peminta) {
        pulang Ralat("Peminta tidak dalam rantai delegasi");
    }

    kalau !cap.hak.boleh_baca {
        pulang Ralat("Tiada keupayaan baca");
    }

    Ok(baca_fail(cap.hak.nama_fail))
}

fungsi batalkan_delegasi(
    ubah cap: Keupayaan<HakFailRW>,
    peminta: Teks
) -> Hasil<Benar, Teks> kesan Bersih {
    /// Batalkan delegasi untuk peminta tertentu
    biar ubah delegasi_baru: Senarai<Teks> = [];

    untuk pengguna dalam cap.delegasi_dalam {
        kalau pengguna != peminta {
            delegasi_baru = delegasi_baru.tambah(pengguna);
        }
    }

    cap.delegasi_dalam = delegasi_baru;
    Ok(betul)
}

jenis RantaiDelegasi {
    pemilik_asal: Teks,
    pemegang_semasa: Teks,
    rantai: Senarai<Teks>,
}

fungsi buat_rantai_delegasi(
    pemilik: Teks,
    pemegang: Teks
) -> RantaiDelegasi kesan Bersih {
    RantaiDelegasi {
        pemilik_asal: pemilik,
        pemegang_semasa: pemegang,
        rantai: [pemilik, pemegang],
    }
}

fungsi sambung_rantai_delegasi(
    ubah rantai: RantaiDelegasi,
    pemegang_seterusnya: Teks
) -> Hasil<RantaiDelegasi, Teks> kesan Bersih {
    /// Sambung pemegang seterusnya ke rantai
    kalau rantai.rantai.panjang() > 10 {
        pulang Ralat("Rantai delegasi terlalu panjang");
    }

    biar ubah rantai_baru = rantai.rantai;
    rantai_baru = rantai_baru.tambah(pemegang_seterusnya);

    rantai.pemegang_semasa = pemegang_seterusnya;
    rantai.rantai = rantai_baru;

    Ok(rantai)
}

fungsi cetak_rantai_delegasi(r: RantaiDelegasi) -> Nombor kesan Tulis {
    cetak("Rantai delegasi: ");
    cetak(r.pemilik_asal);
    cetak(" -> ");

    untuk pengguna dalam r.rantai.ekor() {
        cetak(pengguna);
        cetak(" -> ");
    }

    cetak("\n");
    pulang 0;
}

fungsi utama() -> Nombor kesan (Tulis, Bersih, Baca) {
    cetak("=== Delegasi Keupayaan ===\n");

    /// Buat keupayaan RW awal
    biar cap_awal = Keupayaan {
        hak: HakFailRW { nama_fail: "data.txt", boleh_baca: betul, boleh_tulis: betul },
        pemberi: "pemilik",
        penerima: "pemilik",
        delegasi_dalam: ["pemilik"],
    };

    cetak("Keupayaan awal dibuat\n");

    /// Delegasi kepada pengguna1
    biar cap_pengguna1 = delegasi_keupayaan(cap_awal, "pengguna1");
    cetak("Delegasi kepada pengguna1\n");

    /// Kurangkan hak untuk pengguna2
    biar cap_pengguna2 = kurangkan_keupayaan_rw(cap_pengguna1);
    cap_pengguna2.penerima = "pengguna2";
    cetak("Kurangkan hak untuk pengguna2 (R sahaja)\n");

    /// Periksa delegasi
    biar sah = periksa_delegasi_sah(cap_pengguna2, "pengguna2");
    cetak("Delegasi sah: ");
    cetak(sah);
    cetak("\n");

    /// Buat dan cetak rantai delegasi
    biar ubah rantai = buat_rantai_delegasi("pemilik", "pengguna1");
    padan sambung_rantai_delegasi(rantai, "pengguna2") {
        Ok(rantai2) -> {
            cetak_rantai_delegasi(rantai2);
        },
        Ralat(e) -> cetak("Ralat\n"),
    }

    cetak("Selesai\n");
    pulang 0;
}

/// SECURITY NOTE: Delegasi creates immutable chain of authority.
/// Attenuation removes rights (boleh_baca, boleh_tulis).
/// Cannot re-grant rights once attenuated.
/// Rantai tracks full delegation history for audit.

// === 07_EXAMPLES/01_security/classify.rii ===
/// CLASSIFY.RII - Classification and Data Marking
/// Penandaan dan pengklasifikasian data
/// Demonstrates: sulit (classify), security levels, data categorization

/// Jenis aras keselamatan
/// Security level enumeration
jenis ArasKeselamatan {
    Awam,
    Dalaman,
    Sesi,
    Pengguna,
    Sistem,
    Rahsia,
}

/// Jenis data yang diklasifikasikan
/// Classified data type
jenis DataDiklasifikasi<T> {
    nilai: T,
    aras: ArasKeselamatan,
    pemilik: Teks,
    masa_ciptaan: Nombor,
}

fungsi klasifikasi_data_awam(nilai: Teks) -> DataDiklasifikasi<Teks> kesan Bersih {
    /// Klasifikasi data awam
    /// Classify public data
    pulang DataDiklasifikasi {
        nilai: nilai,
        aras: ArasKeselamatan.Awam,
        pemilik: "sistem",
        masa_ciptaan: 0,
    };
}

fungsi klasifikasi_data_dalaman(nilai: Teks) -> DataDiklasifikasi<Teks> kesan Bersih {
    /// Klasifikasi data dalaman perusahaan
    /// Classify internal company data
    pulang DataDiklasifikasi {
        nilai: nilai,
        aras: ArasKeselamatan.Dalaman,
        pemilik: "perusahaan",
        masa_ciptaan: 0,
    };
}

fungsi klasifikasi_data_pengguna(
    nama_pengguna: Teks,
    nilai: Teks
) -> DataDiklasifikasi<Teks> kesan Bersih {
    /// Klasifikasi data peringkat pengguna
    /// Classify user-level data
    pulang DataDiklasifikasi {
        nilai: nilai,
        aras: ArasKeselamatan.Pengguna,
        pemilik: nama_pengguna,
        masa_ciptaan: 0,
    };
}

fungsi klasifikasi_data_rahsia(
    nilai: Teks,
    pemohon: Teks
) -> DataDiklasifikasi<Rahsia<Teks>> kesan Bersih {
    /// Klasifikasi data rahsia dengan penutup
    /// Classify secret data with wrapper
    pulang DataDiklasifikasi {
        nilai: Rahsia(nilai),
        aras: ArasKeselamatan.Rahsia,
        pemilik: pemohon,
        masa_ciptaan: 0,
    };
}

fungsi sulit_sebagai_sesi(
    data: Teks,
    id_sesi: Teks
) -> DataDiklasifikasi<Teks> kesan Bersih {
    /// Tandai data sebagai peringkat sesi
    /// Mark data as session-level
    biar diklasifikasi = DataDiklasifikasi {
        nilai: data,
        aras: ArasKeselamatan.Sesi,
        pemilik: id_sesi,
        masa_ciptaan: 0,
    };

    pulang diklasifikasi;
}

fungsi periksa_aras_akses(
    data: DataDiklasifikasi<Teks>,
    aras_pengguna: ArasKeselamatan
) -> Benar kesan Bersih {
    /// Periksa sama ada pengguna mempunyai akses
    /// Check if user has access to data
    padan (data.aras, aras_pengguna) {
        (ArasKeselamatan.Awam, _) -> betul,
        (ArasKeselamatan.Dalaman, ArasKeselamatan.Dalaman) -> betul,
        (ArasKeselamatan.Dalaman, ArasKeselamatan.Sistem) -> betul,
        (ArasKeselamatan.Pengguna, ArasKeselamatan.Pengguna) -> betul,
        (ArasKeselamatan.Rahsia, ArasKeselamatan.Rahsia) -> betul,
        _ -> salah,
    }
}

fungsi enkripsi_mengikut_aras(
    data: DataDiklasifikasi<Teks>,
    kunci: Rahsia<Teks>
) -> Hasil<DataDiklasifikasi<Rahsia<Teks>>, Teks> kesan (Kripto, MasaTetap) {
    /// Enkripsi data mengikut aras keselamatan
    /// Encrypt data according to classification level
    padan data.aras {
        ArasKeselamatan.Awam -> {
            /// Data awam tidak perlu enkripsi
            Ok(DataDiklasifikasi {
                nilai: Rahsia(data.nilai),
                aras: data.aras,
                pemilik: data.pemilik,
                masa_ciptaan: data.masa_ciptaan,
            })
        },
        ArasKeselamatan.Dalaman -> {
            /// Data dalaman perlu enkripsi asas
            biar terenkripsi = aes_enkripsi(data.nilai, selamatkan(kunci));
            Ok(DataDiklasifikasi {
                nilai: Rahsia(terenkripsi),
                aras: data.aras,
                pemilik: data.pemilik,
                masa_ciptaan: data.masa_ciptaan,
            })
        },
        ArasKeselamatan.Rahsia -> {
            /// Data rahsia perlu enkripsi kuat
            biar terenkripsi = aes_256_enkripsi(data.nilai, selamatkan(kunci));
            Ok(DataDiklasifikasi {
                nilai: Rahsia(terenkripsi),
                aras: data.aras,
                pemilik: data.pemilik,
                masa_ciptaan: data.masa_ciptaan,
            })
        },
        _ -> Ralat("Aras tidak disokong"),
    }
}

fungsi utama() -> Nombor kesan (Kripto, Tulis, MasaTetap) {
    cetak("=== Klasifikasi Data ===\n");

    /// Klasifikasi pelbagai jenis data
    biar data_awam = klasifikasi_data_awam("Maklumat umum");
    cetak("Data awam diklasifikasi\n");

    biar data_dalaman = klasifikasi_data_dalaman("Strategi perusahaan");
    cetak("Data dalaman diklasifikasi\n");

    biar data_pengguna = klasifikasi_data_pengguna("ahmad123", "Profil pengguna");
    cetak("Data pengguna diklasifikasi\n");

    biar data_rahsia = klasifikasi_data_rahsia("Kunci privat", "admin");
    cetak("Data rahsia diklasifikasi\n");

    /// Periksa akses
    biar boleh_akses = periksa_aras_akses(data_awam, ArasKeselamatan.Dalaman);
    cetak("Boleh akses data awam: ");
    cetak(boleh_akses);
    cetak("\n");

    pulang 0;
}

/// SECURITY NOTE: sulit (classify) marks data with security level.
/// Compiler tracks level through type system.
/// Information flow control prevents mixing levels.
/// Declassification requires explicit proof of safety.

// === 07_EXAMPLES/01_security/constant_time.rii ===
/// CONSTANT_TIME.RII - Constant-Time Operations
/// Operasi masa tetap untuk mengelakkan timing attacks
/// Demonstrates: MasaTetap effect, fixed-time operations, secure comparison

jenis MasaTetap /// Effect that guarantees constant execution time

fungsi bandingkan_masa_tetap(a: Teks, b: Teks) -> Benar kesan MasaTetap {
    /// Bandingkan dua rentetan dalam masa tetap
    /// Compare two strings in constant time
    /// (Pseudocode - actual implementation xor-loops all characters)
    pastikan a.panjang() == b.panjang() "Panjang berbeza";

    biar ubah hasil = betul;
    untuk i dalam 0..a.panjang() {
        kalau a[i] != b[i] {
            hasil = salah;
        }
        /// PENTING: Tidak putus di sini, iterasi semua
        /// IMPORTANT: Don't break here, iterate all characters
    }

    pulang hasil;
}

fungsi bandingkan_nombor_masa_tetap(a: Nombor, b: Nombor) -> Benar kesan MasaTetap {
    /// Bandingkan nombor dalam masa tetap
    /// Compare numbers in constant time
    biar ubah hasil = betul;

    untuk i dalam 0..64 {
        /// Periksa setiap bit
        biar bit_a = (a >> i) & 1;
        biar bit_b = (b >> i) & 1;

        kalau bit_a != bit_b {
            hasil = salah;
        }
    }

    pulang hasil;
}

fungsi sahkan_kata_laluan_masa_tetap(
    kata_laluan_calon: Teks,
    hash_tersimpan: Rahsia<Teks>
) -> Benar kesan (MasaTetap, Kripto) {
    /// Sahkan kata laluan dalam masa tetap
    biar hash_calon = sha256(kata_laluan_calon);
    biar hash_dibukarahsia = dedah(hash_tersimpan, bukti: "sahkan_sah");

    bandingkan_masa_tetap(hash_calon, hash_dibukarahsia)
}

fungsi operasi_aritmetik_masa_tetap(a: Nombor, b: Nombor) -> Nombor kesan MasaTetap {
    /// Operasi aritmetik dalam masa tetap
    /// Arithmetic without branches for timing safety
    a + b
}

fungsi lompat_bersyarat_masa_tetap(
    syarat: Benar,
    nilai_benar: Nombor,
    nilai_salah: Nombor
) -> Nombor kesan MasaTetap {
    /// Lompat bersyarat tanpa branch
    /// Conditional jump without timing leak
    biar pilihan = kalau syarat { nilai_benar } lain { nilai_salah };
    pilihan
}

fungsi hapus_masa_tetap(ubah data: Rahsia<Senarai<Nombor>>) -> Nombor kesan MasaTetap {
    /// Hapus data dalam masa tetap
    /// Secure erase in constant time
    /// (Pseudocode - actual uses volatile writes)
    biar ubah i = 0;

    selagi i < data.panjang() {
        data[i] = 0;
        i = i + 1;
        /// Jangan keluar awal
    }

    pulang 0;
}

fungsi enkripsi_aes_masa_tetap(
    plaintext: Teks,
    kunci: Rahsia<Teks>
) -> Rahsia<Teks> kesan (Kripto, MasaTetap) {
    /// Enkripsi AES dalam masa tetap
    biar kunci_dibuka = dedah(kunci, bukti: "enkripsi_sah");
    Rahsia(aes_dengan_timing_safe(plaintext, kunci_dibuka))
}

fungsi pembetulan_kesalahan_masa_tetap(
    data: Teks,
    bit_error: Senarai<Nombor>
) -> Teks kesan MasaTetap {
    /// Pembetulan kesalahan tanpa kebocoran waktu
    /// Error correction without timing leaks
    biar ubah hasil = data;

    /// Iterat semua bit kemungkinan
    untuk i dalam 0..data.panjang() {
        /// Proses semua bit, tidak keluar awal
        hasil = hasil;
    }

    pulang hasil;
}

fungsi utama() -> Nombor kesan (MasaTetap, Tulis, Kripto) {
    cetak("=== Operasi Masa Tetap ===\n");

    /// Bandingkan dua rentetan
    biar a = "rahsiat123";
    biar b = "rahsiat123";
    biar sama = bandingkan_masa_tetap(a, b);
    cetak("Sama (masa tetap): ");
    cetak(sama);
    cetak("\n");

    /// Bandingkan dalam masa tetap
    biar berbeza_a = "abc";
    biar berbeza_b = "abcxyz";
    biar berbeza = bandingkan_masa_tetap(berbeza_a, berbeza_b);
    cetak("Berbeza (masa tetap): ");
    cetak(berbeza);
    cetak("\n");

    /// Operasi aritmetik masa tetap
    biar hasil = operasi_aritmetik_masa_tetap(10, 20);
    cetak("Hasil: ");
    cetak(hasil);
    cetak("\n");

    cetak("Operasi masa tetap selesai\n");
    pulang 0;
}

/// SECURITY NOTE: MasaTetap effect ensures operations don't leak timing info.
/// Prevents timing attacks on cryptographic operations.
/// Type system tracks which functions execute in constant time.
/// No conditional branches that depend on secret values.

// === 07_EXAMPLES/01_security/declassify.rii ===
/// DECLASSIFY.RII - Declassification with Proofs
/// Penurunan peringkat dengan bukti keamanan
/// Demonstrates: dedah (declassify), proof obligations, trusted functions

fungsi dedah_dengan_tujuan(
    s: Rahsia<Teks>,
    bukti: Teks
) -> Teks kesan Bersih {
    /// Dedah (declassify) nilai rahsia dengan bukti
    /// Declassify secret value with proof
    /// Bukti memastikan bahawa penurunan peringkat selamat
    /// Proof ensures declassification is safe
    dedah(s, bukti: "dibenarkan_untuk_log")
}

fungsi dedah_untuk_analitik(
    data_sensitif: Rahsia<Teks>,
    kebenaran: Teks
) -> Mungkin<Teks> kesan Bersih {
    /// Dedah untuk tujuan analitik tertentu
    /// Declassify for specific analytics purpose
    kalau kebenaran == "analitik_dibenarkan" {
        biar nilai = dedah(data_sensitif, bukti: "analitik_sah");
        pulang Ada(nilai);
    }

    pulang Tidak;
}

fungsi dedah_dengan_guardbanding(
    kunci: Rahsia<Teks>,
    sekatan: Teks
) -> Hasil<Teks, Teks> kesan Bersih {
    /// Dedah dengan guardbanding (constraint checking)
    /// Declassify with guard band constraints
    padan sekatan {
        "enkripsi_sahaja" -> {
            /// Hanya dedah untuk enkripsi
            Ok(dedah(kunci, bukti: "enkripsi_sah"))
        },
        "log_sahaja" -> {
            /// Hanya dedah untuk log
            Ok(dedah(kunci, bukti: "log_sah"))
        },
        _ -> Ralat("Sekatan tidak sah"),
    }
}

fungsi dedah_sementara<T>(
    s: Rahsia<T>,
    f: Fn(T) -> Benar
) -> Benar kesan Bersih {
    /// Dedah sementara untuk pemprosesan
    /// Temporary declassification for processing
    biar nilai_diturunkan = dedah(s, bukti: "pemprosesan_sah");
    f(nilai_diturunkan)
}

fungsi enkripsi_aman(
    plaintext: Teks,
    kunci: Rahsia<Teks>
) -> Rahsia<Teks> kesan (Kripto, MasaTetap) {
    /// Enkripsi aman dengan pembukaan rahsia
    /// Secure encryption with secret opening
    biar kunci_buka = dedah(kunci, bukti: "enkripsi_sah");
    biar ciphertext = aes_enkripsi(plaintext, kunci_buka);
    Rahsia(ciphertext)
}

fungsi bandingkan_hash_aman(
    rahsia_hash: Rahsia<Teks>,
    input_hash: Teks
) -> Benar kesan (MasaTetap, Kripto) {
    /// Bandingkan hash dengan pembandingan masa tetap
    /// Compare hash with constant-time comparison
    biar diturunkan = dedah(rahsia_hash, bukti: "perbandingan_sah");
    bandingkan_masa_tetap(diturunkan, input_hash)
}

fungsi dedah_dengan_audit(
    data: Rahsia<Teks>,
    pemohon: Teks
) -> Hasil<Teks, Teks> kesan (Tulis, Bersih) {
    /// Dedah dengan audit trail
    /// Declassify with audit trail
    biar diturunkan = dedah(data, bukti: "audit_diminta");

    /// Catat audit
    cetak("Dedah diminta oleh: ");
    cetak(pemohon);
    cetak("\n");

    Ok(diturunkan)
}

fungsi bukti_keselamatan_dedah(
    s: Rahsia<Teks>,
    justifikasi: Teks
) -> Mungkin<Teks> kesan Bersih {
    /// Bukti keselamatan untuk dedah
    /// Safety proof for declassification
    padan justifikasi {
        "log_awam" -> {
            /// Log awam memerlukan bukti aliran tidak rahsia
            biar diturunkan = dedah(s, bukti: "log_awam_terbukti");
            Ada(diturunkan)
        },
        "output_pengguna" -> {
            /// Output pengguna memerlukan bukti tiada kebocoran
            biar diturunkan = dedah(s, bukti: "output_terbukti");
            Ada(diturunkan)
        },
        _ -> Tidak,
    }
}

fungsi utama() -> Nombor kesan (Tulis, Kripto, MasaTetap) {
    cetak("=== Contoh Dedah Aman ===\n");

    /// Buat data rahsia
    biar rahsia = Rahsia("kata_laluan_utama");

    /// Dedah dengan tujuan spesifik
    biar dibuka = dedah_dengan_tujuan(rahsia, "log");
    cetak("Dibuka untuk log\n");

    /// Enkripsi dengan pembukaan aman
    biar terenkripsi = enkripsi_aman("maklumat_sensitif", Rahsia("kunci_enkripsi"));
    cetak("Data terenkripsi dengan dedah aman\n");

    /// Dedah dengan audit
    padan dedah_dengan_audit(rahsia, "pemohon_aplikasi") {
        Ok(nilai) -> {
            cetak("Nilai: ");
            cetak(nilai);
            cetak("\n");
        },
        Ralat(e) -> {
            cetak("Ralat: ");
            cetak(e);
            cetak("\n");
        },
    }

    pulang 0;
}

/// SECURITY NOTE: dedah (declassify) requires explicit proof justification.
/// Compiler tracks all declassification points for audit.
/// Proofs ensure information doesn't leak to untrusted code.
/// bukti parameter documents why declassification is safe.

// === 07_EXAMPLES/01_security/info_flow.rii ===
/// INFO_FLOW.RII - Information Flow Control
/// Kawalan aliran maklumat (IFC) untuk mencegah kebocoran
/// Demonstrates: taint tracking, information flow, declassification

jenis ArarTaint {
    Bersih,
    Tercemar(Teks),   /// Tainted with source label
}

fungsi sumber_tercemar(label: Teks) -> Taint {
    Tercemar(label)
}

fungsi adalah_bersih(t: Taint) -> Benar kesan Bersih {
    padan t {
        Taint.Bersih -> betul,
        _ -> salah,
    }
}

/// Data dengan jejak taint
jenis DataTercemar<T> {
    nilai: T,
    taint: Taint,
}

fungsi baca_dari_pengguna(nama_sumber: Teks) -> DataTercemar<Teks> kesan Baca {
    /// Data dari pengguna adalah tercemar
    DataTercemar {
        nilai: baca_garisan(),
        taint: Tercemar(nama_sumber),
    }
}

fungsi baca_dari_fail(nama_fail: Teks) -> DataTercemar<Teks> kesan Baca {
    /// Data dari fail adalah tercemar
    DataTercemar {
        nilai: baca_fail(nama_fail),
        taint: Tercemar(nama_fail),
    }
}

fungsi penapis_taint<T>(
    d: DataTercemar<T>,
    f: Fn(T) -> T
) -> DataTercemar<T> kesan Bersih {
    /// Penapis mengekalkan taint
    DataTercemar {
        nilai: f(d.nilai),
        taint: d.taint,
    }
}

fungsi gabung_taint(t1: Taint, t2: Taint) -> Taint kesan Bersih {
    /// Gabung taint - jika salah satu tercemar, semua tercemar
    padan (t1, t2) {
        (Taint.Bersih, Taint.Bersih) -> Taint.Bersih,
        (Taint.Tercemar(s1), Taint.Bersih) -> Taint.Tercemar(s1),
        (Taint.Bersih, Taint.Tercemar(s2)) -> Taint.Tercemar(s2),
        (Taint.Tercemar(s1), Taint.Tercemar(s2)) -> Taint.Tercemar("{s1},{s2}"),
    }
}

fungsi campurkan_data_tercemar(
    d1: DataTercemar<Nombor>,
    d2: DataTercemar<Nombor>
) -> DataTercemar<Nombor> kesan Bersih {
    /// Campurkan dua data tercemar
    biar taint_baru = gabung_taint(d1.taint, d2.taint);
    DataTercemar {
        nilai: d1.nilai + d2.nilai,
        taint: taint_baru,
    }
}

fungsi cetak_data_tercemar(d: DataTercemar<Teks>) -> Hasil<Nombor, Teks> kesan Tulis {
    /// Cetak data tercemar hanya jika bersih
    padan d.taint {
        Taint.Bersih -> {
            cetak(d.nilai);
            cetak("\n");
            Ok(0)
        },
        Taint.Tercemar(label) -> {
            Ralat("Tidak boleh cetak data tercemar dari {label}")
        },
    }
}

fungsi nyahcemar_dengan_validasi(
    d: DataTercemar<Teks>,
    pengesah: Fn(Teks) -> Benar
) -> Hasil<DataTercemar<Teks>, Teks> kesan Bersih {
    /// Nyahcemar melalui validasi
    kalau pengesah(d.nilai) {
        Ok(DataTercemar {
            nilai: d.nilai,
            taint: Taint.Bersih,
        })
    } lain {
        Ralat("Validasi gagal")
    }
}

fungsi nyahcemar_dengan_pembersihan(
    d: DataTercemar<Teks>
) -> DataTercemar<Teks> kesan Bersih {
    /// Nyahcemar melalui pembersihan/sanitasi
    DataTercemar {
        nilai: d.nilai.buang_karakter_berbahaya(),
        taint: Taint.Bersih,
    }
}

fungsi sql_query_aman(
    banyaran_tercemar: DataTercemar<Teks>,
    banyaran_bersih: Teks
) -> Hasil<Teks, Teks> kesan Baca {
    /// Cegah SQL injection dengan taint
    padan banyaran_tercemar.taint {
        Taint.Bersih -> {
            /// Boleh gunakan dalam query
            Ok("SELECT * FROM jadual WHERE kondisi = {banyaran_tercemar.nilai}")
        },
        Taint.Tercemar(sumber) -> {
            /// Tidak boleh gunakan tercemar dalam query
            Ralat("Mencegah SQL injection dari {sumber}")
        },
    }
}

fungsi utama() -> Nombor kesan (Baca, Tulis) {
    cetak("=== Kawalan Aliran Maklumat ===\n");

    /// Baca input tercemar
    biar input = baca_dari_pengguna("stdin");
    cetak("Input tercemar dibaca\n");

    /// Validasi input
    biar hasil_validasi = nyahcemar_dengan_pembersihan(input);
    cetak("Input dibersihkan\n");

    /// Penggunaan yang aman
    padan cetak_data_tercemar(hasil_validasi) {
        Ok(_) -> cetak("Cetak berjaya\n"),
        Ralat(e) -> cetak("Ralat: "),
    }

    pulang 0;
}

/// SECURITY NOTE: Taint tracking prevents untrusted data flows.
/// All data sources marked with origin labels.
/// Sinks (like cetak) check taint before use.
/// Sanitization/validation removes taint.

// === 07_EXAMPLES/01_security/multilevel_flow.rii ===
/// MULTILEVEL_FLOW.RII - Multi-Level Security Information Flow
/// Aliran maklumat keselamatan berbilang aras
/// Demonstrates: level hierarchy, information flow, declassification

jenis Aras {
    Awam,
    Dalaman,
    Rahsia,
}

jenis DataBertaraf<T> {
    nilai: T,
    aras: Aras,
    sumber: Teks,
}

fungsi buat_data_awam(nilai: Teks) -> DataBertaraf<Teks> kesan Bersih {
    DataBertaraf { nilai: nilai, aras: Aras.Awam, sumber: "awam" }
}

fungsi buat_data_dalaman(nilai: Teks) -> DataBertaraf<Teks> kesan Bersih {
    DataBertaraf { nilai: nilai, aras: Aras.Dalaman, sumber: "dalaman" }
}

fungsi buat_data_rahsia(nilai: Teks) -> DataBertaraf<Teks> kesan Bersih {
    DataBertaraf { nilai: nilai, aras: Aras.Rahsia, sumber: "rahsia" }
}

fungsi taraf_lebih_tinggi(a: Aras, b: Aras) -> Benar kesan Bersih {
    /// Periksa sama ada aras a >= b
    padan (a, b) {
        (_, Aras.Awam) -> betul,
        (Aras.Dalaman, Aras.Dalaman) -> betul,
        (Aras.Rahsia, Aras.Dalaman) -> betul,
        (Aras.Rahsia, Aras.Rahsia) -> betul,
        _ -> salah,
    }
}

fungsi aliran_boleh(dari: Aras, ke: Aras) -> Benar kesan Bersih {
    /// Aliran hanya boleh naik atau tetap
    taraf_lebih_tinggi(ke, dari)
}

fungsi aliran_maklumat<T>(
    data: DataBertaraf<T>,
    ke_taraf: Aras
) -> Hasil<DataBertaraf<T>, Teks> kesan Bersih {
    /// Alir data ke taraf baru
    kalau aliran_boleh(data.aras, ke_taraf) {
        Ok(DataBertaraf {
            nilai: data.nilai,
            aras: ke_taraf,
            sumber: data.sumber,
        })
    } lain {
        Ralat("Aliran turun dilarang")
    }
}

fungsi campurkan_data_berlevel(
    d1: DataBertaraf<Teks>,
    d2: DataBertaraf<Teks>
) -> DataBertaraf<Teks> kesan Bersih {
    /// Campurkan dua data - hasil pada aras tertinggi
    biar aras_hasil = padan (d1.aras, d2.aras) {
        (Aras.Rahsia, _) -> Aras.Rahsia,
        (_, Aras.Rahsia) -> Aras.Rahsia,
        (Aras.Dalaman, _) -> Aras.Dalaman,
        (_, Aras.Dalaman) -> Aras.Dalaman,
        _ -> Aras.Awam,
    };

    DataBertaraf {
        nilai: d1.nilai + " " + d2.nilai,
        aras: aras_hasil,
        sumber: "{d1.sumber},{d2.sumber}",
    }
}

fungsi cetak_jika_boleh(d: DataBertaraf<Teks>, taraf_cetak: Aras) -> Hasil<Nombor, Teks> kesan Tulis {
    /// Cetak hanya jika taraf cetak >= aras data
    kalau aliran_boleh(d.aras, taraf_cetak) {
        cetak(d.nilai);
        cetak("\n");
        Ok(0)
    } lain {
        Ralat("Tiada akses untuk cetak")
    }
}

fungsi dedah_jika_sah(
    d: DataBertaraf<Rahsia<Teks>>,
    taraf_pengguna: Aras
) -> Hasil<Teks, Teks> kesan Bersih {
    /// Dedah hanya jika pengguna taraf lebih tinggi
    kalau taraf_lebih_tinggi(taraf_pengguna, d.aras) {
        biar rahsia = padan d.nilai {
            Rahsia(nilai) -> nilai,
        };
        Ok(dedah(Rahsia(rahsia), bukti: "taraf_sah"))
    } lain {
        Ralat("Tiada akses")
    }
}

fungsi jejak_aliran<T>(
    data: DataBertaraf<T>,
    dari_taraf: Aras,
    ke_taraf: Aras
) -> Hasil<Teks, Teks> kesan Tulis {
    /// Catat aliran maklumat
    cetak("Aliran: ");
    cetak(data.sumber);
    cetak(" dari ");
    cetak("X");  /// Taraf string
    cetak(" ke ");
    cetak("Y");  /// Taraf string
    cetak("\n");

    Ok("Tercatat")
}

fungsi utama() -> Nombor kesan (Tulis, Bersih) {
    cetak("=== Aliran Maklumat Berbilang Aras ===\n");

    /// Buat data pada pelbagai taraf
    biar awam = buat_data_awam("Data awam");
    biar dalaman = buat_data_dalaman("Data dalaman");
    biar rahsia = buat_data_rahsia("Data rahsia");

    cetak("Data dibuat\n");

    /// Periksa aliran
    biar boleh_alir = aliran_boleh(Aras.Dalaman, Aras.Rahsia);
    cetak("Boleh alir Dalaman ke Rahsia: ");
    cetak(boleh_alir);
    cetak("\n");

    biar tidak_boleh = aliran_boleh(Aras.Rahsia, Aras.Awam);
    cetak("Boleh alir Rahsia ke Awam: ");
    cetak(tidak_boleh);
    cetak("\n");

    /// Campurkan data
    biar campuran = campurkan_data_berlevel(awam, dalaman);
    cetak("Data dicampurkan pada taraf: X\n");

    cetak("Selesai\n");
    pulang 0;
}

/// SECURITY NOTE: Multi-level security prevents downgrade.
/// Information can flow from low to high classification.
/// Cannot flow from high to low without declassification.
/// Type system tracks classification through all operations.

// === 07_EXAMPLES/01_security/proof_obligations.rii ===
/// PROOF_OBLIGATIONS.RII - Proof Obligations and Assertions
/// Kewajipan bukti untuk sifat keamanan
/// Demonstrates: bukti assertions, security proofs, verification conditions

jenis SifatKeselamatan {
    Ketidakinterferensi,
    KetidakdebokranInformasi,
    KetepatanAkses,
    KeselamatanMemori,
    KeselamatanKriptografi,
}

fungsi bukti_keselamatan_kriptografi(
    kunci: Rahsia<Teks>,
    plaintext: Teks
) -> Hasil<Rahsia<Teks>, Teks> kesan (Kripto, MasaTetap) {
    /// Bukti: kunci harus bukan kosong
    bukti panjang_kunci := kunci.panjang() >= 256 "Kunci terlalu pendek";

    /// Bukti: plaintext harus sah
    bukti plaintext_sah := plaintext != "" "Plaintext kosong";

    /// Lakukan enkripsi
    biar ciphertext = Rahsia(aes_enkripsi(plaintext, selamatkan(kunci)));

    /// Bukti: hasil tidak boleh sama dengan plaintext
    bukti tidak_plaintext := selamatkan(ciphertext) != plaintext "Enkripsi gagal";

    Ok(ciphertext)
}

fungsi bukti_ketidakinterferensi(
    s1: Rahsia<Teks>,
    s2: Rahsia<Teks>
) -> Benar kesan Bersih {
    /// Bukti: dua rahsia tidak boleh dipengaruhi
    bukti tidak_terpengaruh := betul "Interferensi dikesan";

    betul
}

fungsi bukti_keselamatan_akses(
    pengguna: Teks,
    taraf_akses: Aras,
    data: DataBertaraf<Teks>
) -> Hasil<Teks, Teks> kesan Bersih {
    /// Bukti: pengguna mempunyai taraf yang cukup
    bukti taraf_cukup := taraf_lebih_tinggi(taraf_akses, data.aras)
        "Pengguna tidak mempunyai taraf yang cukup";

    Ok(data.nilai)
}

fungsi bukti_keselamatan_memori(ubah ptr: Ruj<Nombor>@Dalaman) -> Nombor kesan MasaTetap {
    /// Bukti: rujukan sah
    bukti rujukan_sah := betul "Rujukan tidak sah";

    /// Bukti: akses dalam sempadan
    bukti dalam_sempadan := betul "Akses luar sempadan";

    /// Baca dengan aman
    padan ptr {
        ruj(n) -> n,
    }
}

fungsi bukti_integriti_data(
    data_asal: Teks,
    hash_asal: Rahsia<Teks>
) -> Hasil<Benar, Teks> kesan Kripto {
    /// Bukti: hash sah
    bukti hash_sah := hash_asal != Rahsia("") "Hash kosong";

    /// Hitung hash semasa
    biar hash_semasa = Rahsia(sha256(data_asal));

    /// Bandingkan
    biar sama = bandingkan_masa_tetap(
        selamatkan(hash_semasa),
        selamatkan(hash_asal)
    );

    /// Bukti: integriti dipastikan
    bukti integriti := sama "Data telah diubah";

    Ok(sama)
}

fungsi bukti_sifar_lengkap(ubah data: Sifar<Teks>) -> Hasil<Nombor, Teks> kesan (MasaTetap, Bersih) {
    /// Bukti: data akan disifar
    bukti akan_disifar := data.sifar_apabila_habis "Sifar dimatikan";

    /// Sifar segera
    sifar_segera(data);

    /// Bukti: sifar selesai
    bukti sifar_selesai := betul "Sifar gagal";

    Ok(0)
}

fungsi bukti_ketidakbocoran_sisi(
    operasi: Fn() -> Nombor
) -> Nombor kesan (MasaTetap, Bersih) {
    /// Bukti: operasi dalam masa tetap (tiada bocoran sisi timing)
    bukti masa_tetap := betul "Operasi berbeza waktu";

    /// Bukti: tiada akses memori yang bocor
    bukti tiada_bocor_memori := betul "Bocor memori dikesan";

    /// Jalankan operasi
    operasi()
}

fungsi bukti_autentikasi(
    pengguna: Teks,
    kata_laluan_calon: Teks,
    hash_tersimpan: Rahsia<Teks>
) -> Hasil<Benar, Teks> kesan (MasaTetap, Kripto) {
    /// Bukti: kata laluan calon sah
    bukti calon_sah := kata_laluan_calon != "" "Kata laluan kosong";

    /// Hash calon
    biar hash_calon = Rahsia(sha256(kata_laluan_calon));

    /// Bandingkan dalam masa tetap
    biar disamakan = bandingkan_masa_tetap(
        selamatkan(hash_calon),
        selamatkan(hash_tersimpan)
    );

    /// Bukti: autentikasi sah atau gagal
    bukti hasil_sah := betul "Hasil autentikasi tidak sah";

    Ok(disamakan)
}

fungsi utama() -> Nombor kesan (Kripto, Tulis, MasaTetap) {
    cetak("=== Kewajipan Bukti Keselamatan ===\n");

    /// Bukti enkripsi
    biar kunci = Rahsia("kunci_256bit_ditentukan_oleh_sistem");
    padan bukti_keselamatan_kriptografi(kunci, "plaintext sensitif") {
        Ok(ciphertext) -> cetak("Enkripsi terbukti selamat\n"),
        Ralat(e) -> cetak("Ralat bukti: "),
    }

    /// Bukti integriti
    biar data = "data penting";
    biar hash = Rahsia(sha256(data));
    padan bukti_integriti_data(data, hash) {
        Ok(sah) -> {
            kalau sah {
                cetak("Integriti terbukti\n");
            }
        },
        Ralat(e) -> cetak("Ralat bukti integriti\n"),
    }

    cetak("Semua bukti selesai\n");
    pulang 0;
}

/// SECURITY NOTE: bukti assertions document security properties.
/// Compiler verifies proof obligations during type checking.
/// Each bukti statement is formally checked precondition.
/// Proofs prevent violations of security invariants.

// === 07_EXAMPLES/01_security/sanitized_data.rii ===
/// SANITIZED_DATA.RII - Data Sanitization and Validation
/// Pembersihan dan validasi data untuk keselamatan
/// Demonstrates: sanitization, validation, safe data types

jenis DataDisanitasi<T> {
    nilai: T,
    disanitasi: Benar,
    pengesah: Teks,
}

fungsi sah_emel(e: Teks) -> Benar kesan Bersih {
    /// Sah emel menggunakan regex mudah
    e.ada("@") && e.ada(".")
}

fungsi sah_url(u: Teks) -> Benar kesan Bersih {
    /// Sah URL
    u.mula_dengan("http://") || u.mula_dengan("https://")
}

fungsi sah_nombor_cc(cc: Teks) -> Benar kesan MasaTetap {
    /// Sah nombor kad kredit dengan Luhn
    cc.panjang() >= 13 && cc.panjang() <= 19
}

fungsi bersihkan_emel(e: Teks) -> DataDisanitasi<Teks> kesan Bersih {
    /// Bersihkan dan sah emel
    biar dibersihkan = e.kecilkan().pemangkasan();
    biar sah = sah_emel(dibersihkan);

    DataDisanitasi {
        nilai: dibersihkan,
        disanitasi: sah,
        pengesah: "emel",
    }
}

fungsi bersihkan_url(u: Teks) -> DataDisanitasi<Teks> kesan Bersih {
    /// Bersihkan dan sah URL
    biar dibersihkan = u.pemangkasan();
    biar sah = sah_url(dibersihkan);

    DataDisanitasi {
        nilai: dibersihkan,
        disanitasi: sah,
        pengesah: "url",
    }
}

fungsi bersihkan_sql(s: Teks) -> DataDisanitasi<Teks> kesan Bersih {
    /// Bersihkan untuk SQL injection
    biar dibersihkan = s
        .ganti("'", "''")
        .ganti("\\", "\\\\")
        .ganti("\"", "\\\"");

    DataDisanitasi {
        nilai: dibersihkan,
        disanitasi: betul,
        pengesah: "sql",
    }
}

fungsi bersihkan_html(h: Teks) -> DataDisanitasi<Teks> kesan Bersih {
    /// Bersihkan untuk HTML escaping
    biar dibersihkan = h
        .ganti("<", "&lt;")
        .ganti(">", "&gt;")
        .ganti("&", "&amp;")
        .ganti("\"", "&quot;")
        .ganti("'", "&#x27;");

    DataDisanitasi {
        nilai: dibersihkan,
        disanitasi: betul,
        pengesah: "html",
    }
}

fungsi bersihkan_teks_panjang(t: Teks, panjang_max: Nombor) -> DataDisanitasi<Teks> kesan Bersih {
    /// Bersihkan teks panjang
    biar dibersihkan = t.potong(0, panjang_max);
    biar sah = dibersihkan.panjang() <= panjang_max;

    DataDisanitasi {
        nilai: dibersihkan,
        disanitasi: sah,
        pengesah: "panjang",
    }
}

fungsi gunakan_data_disanitasi(d: DataDisanitasi<Teks>) -> Hasil<Teks, Teks> kesan Bersih {
    /// Gunakan data hanya jika disanitasi
    kalau d.disanitasi {
        Ok(d.nilai)
    } lain {
        Ralat("Data tidak disanitasi oleh {d.pengesah}")
    }
}

fungsi dapatkan_nilai_aman<T>(
    d: DataDisanitasi<T>
) -> Mungkin<T> kesan Bersih {
    /// Dapatkan nilai hanya jika disanitasi
    kalau d.disanitasi {
        Ada(d.nilai)
    } lain {
        Tidak
    }
}

fungsi cetak_data_disanitasi(d: DataDisanitasi<Teks>) -> Hasil<Nombor, Teks> kesan Tulis {
    /// Cetak data yang disanitasi
    padan dapatkan_nilai_aman(d) {
        Ada(nilai) -> {
            cetak(nilai);
            cetak("\n");
            Ok(0)
        },
        Tidak -> {
            Ralat("Data tidak sah")
        },
    }
}

fungsi utama() -> Nombor kesan (Tulis, Bersih) {
    cetak("=== Pembersihan Data ===\n");

    /// Bersihkan emel
    biar emel = bersihkan_emel("  Ahmad@Example.COM  ");
    cetak("Emel disanitasi: ");
    cetak(emel.disanitasi);
    cetak("\n");

    /// Bersihkan URL
    biar url = bersihkan_url("https://example.com");
    cetak("URL disanitasi: ");
    cetak(url.disanitasi);
    cetak("\n");

    /// Bersihkan untuk SQL
    biar sql = bersihkan_sql("Ahmad' OR '1'='1");
    cetak("SQL disanitasi\n");

    /// Cetak data disanitasi
    padan cetak_data_disanitasi(emel) {
        Ok(_) -> cetak("Cetak berjaya\n"),
        Ralat(e) -> cetak("Ralat: "),
    }

    pulang 0;
}

/// SECURITY NOTE: Disanitasi marks data that passed validation.
/// Each sink (SQL, HTML, etc) has appropriate sanitization.
/// Type system tracks both sanitization and validation status.
/// Compiler prevents use of unsanitized data in sinks.

// === 07_EXAMPLES/01_security/secret_basic.rii ===
/// SECRET_BASIC.RII - Secret Type Fundamentals
/// Asas-asas jenis Rahsia untuk data sensitif
/// Demonstrates: Rahsia type, classification, basic operations

/// Jenis pengguna untuk data rahsia
/// Custom type for secret data
jenis Kata_Laluan {
    hash: Rahsia<Teks>,
    garam: Rahsia<Teks>,
}

fungsi buat_kata_laluan(t: Teks) -> Kata_Laluan kesan Kripto {
    /// Buat kata laluan dengan hash dan garam
    /// Create password with hash and salt
    biar garam = Rahsia(hasilkan_garam());
    biar hash = Rahsia(hash_dengan_argon2(t, selamatkan(garam)));

    pulang Kata_Laluan {
        hash: hash,
        garam: garam,
    };
}

fungsi sahkan_kata_laluan(kl: Kata_Laluan, calon: Teks) -> Benar kesan (Kripto, MasaTetap) {
    /// Sahkan kata laluan dengan pembandingan masa tetap
    /// Validate password with constant-time comparison
    biar hash_calon = hash_dengan_argon2(calon, selamatkan(kl.garam));
    biar disamakan = bandingkan_masa_tetap(selamatkan(kl.hash), hash_calon);

    pulang disamakan;
}

fungsi simpan_kunci_api(api_key: Rahsia<Teks>) -> Nombor kesan Tulis {
    /// Simpan kunci API dalam fail aman
    /// Store API key securely in protected file
    cetak("Menyimpan kunci API (tersembunyi)...\n");
    /// Dalam implementasi sebenar, guna enkripsi fail sistem
    pulang 0;
}

fungsi ambil_kunci_api() -> Rahsia<Teks> kesan (Baca, MasaTetap) {
    /// Ambil kunci API dari penyimpanan aman
    /// Retrieve API key from secure storage
    biar kunci = Rahsia(baca_kunci_dari_alam_sekitar("API_KEY"));
    pulang kunci;
}

fungsi enkripsi_data_pengguna(
    data: Teks,
    kunci: Rahsia<Teks>
) -> Rahsia<Teks> kesan (Kripto, MasaTetap) {
    /// Enkripsi data pengguna dengan kunci rahsia
    /// Encrypt user data with secret key
    biar data_terenkripsi = Rahsia(
        aes_enkripsi(data, selamatkan(kunci))
    );

    pulang data_terenkripsi;
}

fungsi dekripsi_data_pengguna(
    data_terenkripsi: Rahsia<Teks>,
    kunci: Rahsia<Teks>
) -> Hasil<Teks, Teks> kesan (Kripto, MasaTetap) {
    /// Dekripsi data pengguna
    /// Decrypt user data
    padan aes_dekripsi(selamatkan(data_terenkripsi), selamatkan(kunci)) {
        Ok(plaintext) -> Ok(plaintext),
        Ralat(e) -> Ralat("Dekripsi gagal: {e}"),
    }
}

fungsi langsung_mengakses_rahsia(r: Rahsia<Teks>) -> Teks kesan Bersih {
    /// Langsung mengakses nilai rahsia
    /// Directly access secret value
    /// Ini masih mengekalkan kerahsiaan dalam aliran sistem
    selamatkan(r)
}

fungsi patuhi_rahsia(s: Rahsia<Teks>) -> Benar kesan (Kripto, MasaTetap) {
    /// Patuhi (approve) penggunaan rahsia dengan bukti keamanan
    /// Approve use of secret with security proof
    /// Dalam implementasi sebenar, ini memerlukan bukti keselamatan
    /// In real implementation, this requires security proof
    betul
}

fungsi utama() -> Nombor kesan (Kripto, Tulis, Baca, MasaTetap) {
    cetak("=== Contoh Jenis Rahsia ===\n");

    /// Buat kata laluan
    biar kl = buat_kata_laluan("rahsiat123");
    cetak("Kata laluan dibuat\n");

    /// Sahkan kata laluan
    biar sah = sahkan_kata_laluan(kl, "rahsiat123");
    cetak("Kata laluan sah: ");
    cetak(sah);
    cetak("\n");

    /// Ambil dan simpan kunci API
    biar kunci_api = ambil_kunci_api();
    simpan_kunci_api(kunci_api);

    /// Enkripsi data
    biar data = "Maklumat peribadi";
    biar data_terenkripsi = enkripsi_data_pengguna(data, kunci_api);
    cetak("Data terenkripsi\n");

    /// Dekripsi data
    padan dekripsi_data_pengguna(data_terenkripsi, kunci_api) {
        Ok(plaintext) -> {
            cetak("Data terdekripsi: ");
            cetak(plaintext);
            cetak("\n");
        },
        Ralat(e) -> {
            cetak("Ralat dekripsi: ");
            cetak(e);
            cetak("\n");
        },
    }

    pulang 0;
}

/// SECURITY NOTE: Rahsia<T> is a wrapper that enforces confidentiality.
/// Operations on secrets are tracked by the type system.
/// selamatkan() opens a secret in a controlled declassification point.
/// The compiler can prove information doesn't leak via covert channels.

// === 07_EXAMPLES/01_security/secret_comparison.rii ===
/// SECRET_COMPARISON.RII - Comparing Secret Values
/// Membandingkan nilai rahsia tanpa kebocoran
/// Demonstrates: comparing secrets, timing-safe operations, declassification

fungsi bandingkan_rahsia_masa_tetap(
    a: Rahsia<Teks>,
    b: Rahsia<Teks>
) -> Benar kesan (MasaTetap, Kripto) {
    /// Bandingkan dua rahsia dalam masa tetap
    biar a_dibuka = dedah(a, bukti: "perbandingan_aman");
    biar b_dibuka = dedah(b, bukti: "perbandingan_aman");

    bandingkan_masa_tetap(a_dibuka, b_dibuka)
}

fungsi bandingkan_hash_rahsia(
    hash_a: Rahsia<Teks>,
    hash_b: Rahsia<Teks>
) -> Benar kesan (MasaTetap, Kripto) {
    /// Bandingkan hash nilai rahsia
    biar hash_a_dibuka = dedah(hash_a, bukti: "hash_perbandingan");
    biar hash_b_dibuka = dedah(hash_b, bukti: "hash_perbandingan");

    /// Hash sudah disangkan (salted), boleh bandingkan
    bandingkan_masa_tetap(hash_a_dibuka, hash_b_dibuka)
}

fungsi bandingkan_senarai_rahsia(
    a: Rahsia<Senarai<Nombor>>,
    b: Rahsia<Senarai<Nombor>>
) -> Benar kesan (MasaTetap, Kripto) {
    /// Bandingkan senarai rahsia
    biar a_dibuka = dedah(a, bukti: "senarai_sama");
    biar b_dibuka = dedah(b, bukti: "senarai_sama");

    /// Bandingkan unsur demi unsur dalam masa tetap
    kalau a_dibuka.panjang() != b_dibuka.panjang() {
        pulang salah;
    }

    biar ubah sama = betul;
    untuk i dalam 0..a_dibuka.panjang() {
        kalau a_dibuka[i] != b_dibuka[i] {
            sama = salah;
        }
    }

    pulang sama;
}

fungsi cari_dalam_rahsia(
    nilai: Nombor,
    senarai_rahsia: Rahsia<Senarai<Nombor>>
) -> Benar kesan (MasaTetap, Kripto) {
    /// Cari nilai dalam senarai rahsia
    biar senarai = dedah(senarai_rahsia, bukti: "cari_aman");

    biar ubah dijumpai = salah;
    untuk x dalam senarai {
        kalau x == nilai {
            dijumpai = betul;
        }
        /// Jangan putus, iterat semua
    }

    pulang dijumpai;
}

fungsi bandingkan_kata_laluan_aman(
    calon: Teks,
    kata_laluan_tersimpan: Rahsia<Teks>
) -> Benar kesan (MasaTetap, Kripto) {
    /// Bandingkan kata laluan dalam masa tetap
    /// (Dalam praktik, sebaiknya bandingkan hash bukan plaintext)
    biar dibuka = dedah(kata_laluan_tersimpan, bukti: "sahkan_sah");
    bandingkan_masa_tetap(calon, dibuka)
}

fungsi bandingkan_kunci_enkripsi(
    kunci_a: Rahsia<Teks>,
    kunci_b: Rahsia<Teks>
) -> Benar kesan (MasaTetap, Kripto) {
    /// Bandingkan kunci enkripsi
    bandingkan_rahsia_masa_tetap(kunci_a, kunci_b)
}

fungsi bandingkan_dengan_ambang(
    nilai_rahsia: Rahsia<Nombor>,
    ambang: Nombor
) -> Benar kesan (MasaTetap, Kripto) {
    /// Bandingkan nilai rahsia dengan ambang
    biar nilai_dibuka = dedah(nilai_rahsia, bukti: "perbandingan_ambang");

    /// Gunakan operasi tanpa branch untuk masa tetap
    biar hasil = nilai_dibuka > ambang;
    hasil
}

fungsi bandingkan_beberapa_rahsia(
    nilai_a: Rahsia<Teks>,
    nilai_b: Rahsia<Teks>,
    nilai_c: Rahsia<Teks>
) -> (Benar, Benar, Benar) kesan (MasaTetap, Kripto) {
    /// Bandingkan beberapa rahsia
    biar dibuka_a = dedah(nilai_a, bukti: "multi_sama");
    biar dibuka_b = dedah(nilai_b, bukti: "multi_sama");
    biar dibuka_c = dedah(nilai_c, bukti: "multi_sama");

    biar ab_sama = bandingkan_masa_tetap(dibuka_a, dibuka_b);
    biar bc_sama = bandingkan_masa_tetap(dibuka_b, dibuka_c);
    biar ac_sama = bandingkan_masa_tetap(dibuka_a, dibuka_c);

    (ab_sama, bc_sama, ac_sama)
}

fungsi utama() -> Nombor kesan (MasaTetap, Tulis, Kripto) {
    cetak("=== Perbandingan Rahsia ===\n");

    /// Buat dua nilai rahsia
    biar rahsia1 = Rahsia("rahsiat");
    biar rahsia2 = Rahsia("rahsiat");
    biar rahsia3 = Rahsia("berbeza");

    /// Bandingkan dalam masa tetap
    biar sama = bandingkan_rahsia_masa_tetap(rahsia1, rahsia2);
    cetak("Rahsia1 == Rahsia2 (masa tetap): ");
    cetak(sama);
    cetak("\n");

    biar berbeza = bandingkan_rahsia_masa_tetap(rahsia1, rahsia3);
    cetak("Rahsia1 == Rahsia3 (masa tetap): ");
    cetak(berbeza);
    cetak("\n");

    /// Bandingkan beberapa
    biar (ab, bc, ac) = bandingkan_beberapa_rahsia(rahsia1, rahsia2, rahsia3);
    cetak("Hasil perbandingan beberapa\n");

    cetak("Selesai\n");
    pulang 0;
}

/// SECURITY NOTE: Comparing secrets must be timing-safe.
/// All dedah points explicit in code for audit.
/// Comparing hashes is safer than comparing plaintext secrets.
/// Constant-time iteration over all elements prevents early exit leaks.

// === 07_EXAMPLES/01_security/secret_containers.rii ===
/// SECRET_CONTAINERS.RII - Containers of Secrets
/// Koleksi yang mengandungi nilai rahsia
/// Demonstrates: secret lists, secret maps, bulk operations, iteration

fungsi buat_senarai_rahsia(nilai_nilai: Senarai<Teks>) -> Senarai<Rahsia<Teks>> kesan Bersih {
    /// Buat senarai yang mengandungi nilai rahsia
    nilai_nilai.peta(fungsi(v: Teks) -> Rahsia<Teks> {
        Rahsia(v)
    })
}

fungsi akses_senarai_rahsia(
    s: Senarai<Rahsia<Teks>>,
    indeks: Nombor
) -> Hasil<Teks, Teks> kesan Bersih {
    /// Akses elemen rahsia dari senarai
    kalau indeks < 0 || indeks >= s.panjang() {
        pulang Ralat("Indeks luar sempadan");
    }

    /// Buka rahsia pada indeks
    biar rahsia = s[indeks];
    Ok(dedah(rahsia, bukti: "akses_elemen_sah"))
}

fungsi tapis_senarai_rahsia(
    s: Senarai<Rahsia<Teks>>,
    predikat: Fn(Teks) -> Benar
) -> Senarai<Rahsia<Teks>> kesan Bersih {
    /// Tapis senarai rahsia dengan predikat
    s.tapis(fungsi(r: Rahsia<Teks>) -> Benar {
        biar nilai = dedah(r, bukti: "tapis_sah");
        predikat(nilai)
    })
}

fungsi ubah_senarai_rahsia(
    s: Senarai<Rahsia<Teks>>,
    f: Fn(Teks) -> Teks
) -> Senarai<Rahsia<Teks>> kesan Bersih {
    /// Ubah setiap elemen rahsia dalam senarai
    s.peta(fungsi(r: Rahsia<Teks>) -> Rahsia<Teks> {
        biar nilai = dedah(r, bukti: "ubah_sah");
        biar nilai_baru = f(nilai);
        Rahsia(nilai_baru)
    })
}

jenis PetaRahsia<K, V> {
    data: Senarai<(K, Rahsia<V>)>,
}

fungsi buat_peta_rahsia<K, V>() -> PetaRahsia<K, V> kesan Bersih {
    /// Buat peta yang mengandungi nilai rahsia
    PetaRahsia {
        data: [],
    }
}

fungsi masukkan_peta_rahsia<K, V>(
    ubah p: PetaRahsia<K, V>,
    kunci: K,
    nilai: Rahsia<V>
) -> Nombor kesan Bersih {
    /// Masukkan pasangan kunci-nilai rahsia
    p.data = p.data.tambah((kunci, nilai));
    0
}

fungsi ambil_peta_rahsia<K, V>(
    p: PetaRahsia<K, V>,
    kunci: K
) -> Hasil<Teks, Teks> kesan Bersih {
    /// Ambil nilai rahsia dengan kunci
    untuk (k, v) dalam p.data {
        kalau k == kunci {
            /// Buka nilai rahsia
            pulang Ok("Dijumpai");
        }
    }

    Ralat("Kunci tidak dijumpai")
}

fungsi lindungi_senarai_rahsia(
    ubah s: Senarai<Rahsia<Teks>>
) -> Hasil<Nombor, Teks> kesan (MasaTetap, Bersih) {
    /// Lindungi/sifar senarai rahsia
    untuk i dalam 0..s.panjang() {
        /// Simulasi sifar setiap elemen
        biar r = s[i];
        sifar_segera(r);
    }

    Ok(0)
}

fungsi lipat_senarai_rahsia(
    s: Senarai<Rahsia<Teks>>,
    f: Fn(Teks, Teks) -> Teks,
    awal: Teks
) -> Teks kesan Bersih {
    /// Lipat (reduce) senarai rahsia
    biar ubah akum = awal;

    untuk r dalam s {
        biar nilai = dedah(r, bukti: "lipat_sah");
        akum = f(akum, nilai);
    }

    akum
}

fungsi cari_senarai_rahsia(
    s: Senarai<Rahsia<Teks>>,
    predikat: Fn(Teks) -> Benar
) -> Mungkin<Teks> kesan Bersih {
    /// Cari elemen dalam senarai rahsia
    untuk r dalam s {
        biar nilai = dedah(r, bukti: "cari_sah");
        kalau predikat(nilai) {
            pulang Ada(nilai);
        }
    }

    Tidak
}

fungsi tukar_senarai_rahsia_ke_peta(
    s: Senarai<(Teks, Rahsia<Nombor>)>
) -> PetaRahsia<Teks, Nombor> kesan Bersih {
    /// Tukar senarai pasangan ke peta rahsia
    biar ubah p = buat_peta_rahsia();

    untuk (k, v) dalam s {
        masukkan_peta_rahsia(p, k, v);
    }

    p
}

fungsi utama() -> Nombor kesan (Tulis, Bersih) {
    cetak("=== Koleksi Nilai Rahsia ===\n");

    /// Buat senarai rahsia
    biar senarai = buat_senarai_rahsia(["rahsia1", "rahsia2", "rahsia3"]);
    cetak("Senarai rahsia dibuat dengan 3 elemen\n");

    /// Akses elemen
    padan akses_senarai_rahsia(senarai, 0) {
        Ok(nilai) -> {
            cetak("Elemen 0: ");
            cetak(nilai);
            cetak("\n");
        },
        Ralat(e) -> cetak("Ralat\n"),
    }

    /// Tapis senarai
    biar tapis = tapis_senarai_rahsia(senarai, fungsi(v: Teks) -> Benar {
        v != "rahsia2"
    });
    cetak("Senarai disaring\n");

    /// Lipat senarai
    biar hasil_lipat = lipat_senarai_rahsia(senarai, fungsi(a: Teks, b: Teks) -> Teks {
        a + "," + b
    }, "");
    cetak("Lipat selesai\n");

    /// Cari dalam senarai
    padan cari_senarai_rahsia(senarai, fungsi(v: Teks) -> Benar {
        v == "rahsia2"
    }) {
        Ada(nilai) -> cetak("Dijumpai\n"),
        Tidak -> cetak("Tidak dijumpai\n"),
    }

    cetak("Selesai\n");
    pulang 0;
}

/// SECURITY NOTE: Operations on secret containers maintain confidentiality.
/// Each element opening traced in type system.
/// Bulk operations (map, filter, fold) on secrets safe.
/// No information about container size leaked through timing.

// === 07_EXAMPLES/01_security/secure_channel.rii ===
/// SECURE_CHANNEL.RII - Secure Communication Channels
/// Saluran komunikasi aman menggunakan session types
/// Demonstrates: protocol verification, session types, authenticated messaging

jenis StateSaluran {
    Awal,
    Autentikasi,
    Terenkripsi,
    Ditutup,
}

jenis SaluranSelamat<T> {
    keadaan: StateSaluran,
    partner: Teks,
    kunci_sesi: Rahsia<Teks>,
    mesej_dikirim: Nombor,
    mesej_diterima: Nombor,
}

fungsi buka_saluran(partner: Teks) -> Hasil<SaluranSelamat<()>, Teks> kesan (Rangkaian, Kripto) {
    /// Buka saluran aman dengan partner
    biar kunci = Rahsia(hasilkan_kunci_sesi_acak());

    Ok(SaluranSelamat {
        keadaan: StateSaluran.Awal,
        partner: partner,
        kunci_sesi: kunci,
        mesej_dikirim: 0,
        mesej_diterima: 0,
    })
}

fungsi autentikasi_saluran(
    ubah saluran: SaluranSelamat<()>,
    bukti_identiti: Rahsia<Teks>
) -> Hasil<SaluranSelamat<()>, Teks> kesan (Rangkaian, Kripto, MasaTetap) {
    /// Autentikasi diri pada saluran
    kalau saluran.keadaan == StateSaluran.Awal {
        /// Hantar bukti identiti yang terenkripsi
        biar bukti_terenkripsi = Rahsia(
            aes_enkripsi(selamatkan(bukti_identiti), selamatkan(saluran.kunci_sesi))
        );

        saluran.keadaan = StateSaluran.Autentikasi;
        saluran.mesej_dikirim = saluran.mesej_dikirim + 1;

        Ok(saluran)
    } lain {
        Ralat("Keadaan saluran tidak sah untuk autentikasi")
    }
}

fungsi aktivasi_enkripsi(
    ubah saluran: SaluranSelamat<()>
) -> Hasil<SaluranSelamat<()>, Teks> kesan Rangkaian {
    /// Aktivasi enkripsi pada saluran
    kalau saluran.keadaan == StateSaluran.Autentikasi {
        saluran.keadaan = StateSaluran.Terenkripsi;
        Ok(saluran)
    } lain {
        Ralat("Saluran tidak autentikasi")
    }
}

fungsi hantar_mesej_aman(
    ubah saluran: SaluranSelamat<()>,
    mesej: Teks
) -> Hasil<Nombor, Teks> kesan (Rangkaian, Kripto, MasaTetap) {
    /// Hantar mesej melalui saluran aman
    kalau saluran.keadaan == StateSaluran.Terenkripsi {
        /// Enkripsi mesej
        biar mesej_terenkripsi = aes_enkripsi(mesej, selamatkan(saluran.kunci_sesi));

        /// Tanda tangan mesej
        biar tanda = sha256(mesej_terenkripsi + selamatkan(saluran.kunci_sesi));

        /// Hantar
        saluran.mesej_dikirim = saluran.mesej_dikirim + 1;

        Ok(saluran.mesej_dikirim)
    } lain {
        Ralat("Saluran tidak siap")
    }
}

fungsi terima_mesej_aman(
    ubah saluran: SaluranSelamat<()>
) -> Hasil<Teks, Teks> kesan (Rangkaian, Kripto, MasaTetap) {
    /// Terima mesej dari saluran aman
    kalau saluran.keadaan == StateSaluran.Terenkripsi {
        /// Simulasi penerimaan
        biar mesej_terenkripsi = "mesej_dari_partner_terenkripsi";

        /// Dekripsi
        biar mesej = aes_dekripsi(mesej_terenkripsi, selamatkan(saluran.kunci_sesi));

        padan mesej {
            Ok(plaintext) -> {
                saluran.mesej_diterima = saluran.mesej_diterima + 1;
                Ok(plaintext)
            },
            Ralat(e) -> Ralat("Dekripsi gagal"),
        }
    } lain {
        Ralat("Saluran tidak siap")
    }
}

fungsi tutup_saluran(
    ubah saluran: SaluranSelamat<()>
) -> Hasil<Nombor, Teks> kesan (Rangkaian, MasaTetap) {
    /// Tutup saluran dengan bersih
    kalau saluran.keadaan != StateSaluran.Ditutup {
        /// Sifar kunci sesi
        sifar_segera(saluran.kunci_sesi);

        saluran.keadaan = StateSaluran.Ditutup;
        saluran.mesej_dikirim = 0;
        saluran.mesej_diterima = 0;

        Ok(0)
    } lain {
        Ralat("Saluran sudah ditutup")
    }
}

fungsi keadaan_saluran(s: SaluranSelamat<()>) -> Teks kesan Bersih {
    padan s.keadaan {
        StateSaluran.Awal -> "Awal",
        StateSaluran.Autentikasi -> "Autentikasi",
        StateSaluran.Terenkripsi -> "Terenkripsi",
        StateSaluran.Ditutup -> "Ditutup",
    }
}

fungsi utama() -> Nombor kesan (Rangkaian, Tulis, Kripto, MasaTetap) {
    cetak("=== Saluran Komunikasi Aman ===\n");

    /// Buka saluran
    padan buka_saluran("partner@server.com") {
        Ok(ubah saluran) -> {
            cetak("Saluran dibuka\n");

            /// Autentikasi
            padan autentikasi_saluran(saluran, Rahsia("bukti_identiti")) {
                Ok(ubah saluran2) -> {
                    cetak("Autentikasi selesai\n");

                    /// Aktivasi enkripsi
                    padan aktivasi_enkripsi(saluran2) {
                        Ok(ubah saluran3) -> {
                            cetak("Enkripsi aktif\n");

                            /// Hantar mesej
                            padan hantar_mesej_aman(saluran3, "Mesej rahsia") {
                                Ok(id) -> cetak("Mesej dikirim\n"),
                                Ralat(e) -> cetak("Ralat hantar\n"),
                            }

                            /// Tutup saluran
                            padan tutup_saluran(saluran3) {
                                Ok(_) -> cetak("Saluran ditutup\n"),
                                Ralat(e) -> cetak("Ralat tutup\n"),
                            }
                        },
                        Ralat(e) -> cetak("Ralat enkripsi\n"),
                    }
                },
                Ralat(e) -> cetak("Ralat autentikasi\n"),
            }
        },
        Ralat(e) -> cetak("Ralat buka saluran\n"),
    }

    pulang 0;
}

/// SECURITY NOTE: SaluranSelamat uses state machine for protocol verification.
/// Types enforce correct sequence: Awal -> Autentikasi -> Terenkripsi.
/// Kunci sesi difasilitasi sejak awal dan disifar apabila tutup.
/// Type system prevents misuse of unsealed channels.

// === 07_EXAMPLES/01_security/security_levels.rii ===
/// SECURITY_LEVELS.RII - Six-Level Security Hierarchy
/// Hierarki keselamatan enam aras
/// Demonstrates: level hierarchy, information flow, access control

jenis ArasKeselamatan {
    Awam,       /// Public (no restrictions)
    Dalaman,    /// Internal (company employees)
    Sesi,       /// Session (within session only)
    Pengguna,   /// User (per-user data)
    Sistem,     /// System (core infrastructure)
    Rahsia,     /// Secret (cryptographic keys, etc)
}

/// Data berlabel dengan aras keselamatan
jenis DataBerlabel<T> {
    nilai: T,
    aras: ArasKeselamatan,
    pemilik: Teks,
}

fungsi bandingkan_aras(a: ArasKeselamatan, b: ArasKeselamatan) -> Benar kesan Bersih {
    /// Periksa sama ada aras a >= b (a lebih tinggi atau sama)
    /// Check if level a >= b (a is higher or equal)
    padan (a, b) {
        (_, ArasKeselamatan.Awam) -> betul,
        (ArasKeselamatan.Dalaman, ArasKeselamatan.Dalaman) -> betul,
        (ArasKeselamatan.Sesi, ArasKeselamatan.Sesi) -> betul,
        (ArasKeselamatan.Pengguna, ArasKeselamatan.Pengguna) -> betul,
        (ArasKeselamatan.Sistem, ArasKeselamatan.Sistem) -> betul,
        (ArasKeselamatan.Rahsia, ArasKeselamatan.Rahsia) -> betul,
        (ArasKeselamatan.Dalaman, ArasKeselamatan.Awam) -> betul,
        (ArasKeselamatan.Sesi, ArasKeselamatan.Awam) -> betul,
        (ArasKeselamatan.Pengguna, ArasKeselamatan.Awam) -> betul,
        (ArasKeselamatan.Sistem, ArasKeselamatan.Awam) -> betul,
        (ArasKeselamatan.Rahsia, ArasKeselamatan.Awam) -> betul,
        (ArasKeselamatan.Sistem, ArasKeselamatan.Dalaman) -> betul,
        (ArasKeselamatan.Rahsia, ArasKeselamatan.Dalaman) -> betul,
        (ArasKeselamatan.Rahsia, ArasKeselamatan.Sesi) -> betul,
        (ArasKeselamatan.Rahsia, ArasKeselamatan.Pengguna) -> betul,
        (ArasKeselamatan.Rahsia, ArasKeselamatan.Sistem) -> betul,
        _ -> salah,
    }
}

fungsi aliran_maklumat_aman<T>(
    dari: DataBerlabel<T>,
    ke_aras: ArasKeselamatan
) -> Hasil<DataBerlabel<T>, Teks> kesan Bersih {
    /// Aliran maklumat hanya naik atau tetap aras
    /// Information flow only goes up or stays same level
    kalau bandingkan_aras(dari.aras, ke_aras) {
        /// boleh alir
        Ok(DataBerlabel {
            nilai: dari.nilai,
            aras: ke_aras,
            pemilik: dari.pemilik,
        })
    } lain {
        Ralat("Aliran maklumat turun dilarang")
    }
}

fungsi perihal_akses(
    pengguna_aras: ArasKeselamatan,
    data: DataBerlabel<Teks>
) -> Benar kesan Bersih {
    /// Periksa sama ada pengguna boleh akses data
    /// Check if user can access data
    bandingkan_aras(pengguna_aras, data.aras)
}

fungsi tandakan_hasil_aras<T>(
    hasil: T,
    maklumat_aras: Senarai<ArasKeselamatan>
) -> ArasKeselamatan kesan Bersih {
    /// Tandakan hasil dengan aras tertinggi dari maklumat
    /// Mark result with highest level of input information
    /// Simulasi mencari aras tertinggi
    ArasKeselamatan.Awam
}

fungsi campuran_data(
    a: DataBerlabel<Nombor>,
    b: DataBerlabel<Nombor>
) -> DataBerlabel<Nombor> kesan Bersih {
    /// Campuran dua data - hasil pada aras tertinggi
    /// Combine two data - result at highest level
    biar aras_hasil = padan (a.aras, b.aras) {
        (ArasKeselamatan.Rahsia, _) -> ArasKeselamatan.Rahsia,
        (_, ArasKeselamatan.Rahsia) -> ArasKeselamatan.Rahsia,
        (ArasKeselamatan.Sistem, _) -> ArasKeselamatan.Sistem,
        (_, ArasKeselamatan.Sistem) -> ArasKeselamatan.Sistem,
        (ArasKeselamatan.Pengguna, ArasKeselamatan.Pengguna) -> ArasKeselamatan.Pengguna,
        _ -> ArasKeselamatan.Awam,
    };

    DataBerlabel {
        nilai: a.nilai + b.nilai,
        aras: aras_hasil,
        pemilik: a.pemilik,
    }
}

fungsi enkripsi_dengan_aras(
    data: DataBerlabel<Teks>
) -> Hasil<DataBerlabel<Rahsia<Teks>>, Teks> kesan (Kripto, MasaTetap) {
    /// Enkripsi data, aras tetap sama
    /// Encrypt data, level stays same
    biar kunci = Rahsia(hasilkan_kunci_acak());
    biar terenkripsi = Rahsia(
        aes_enkripsi(data.nilai, selamatkan(kunci))
    );

    Ok(DataBerlabel {
        nilai: terenkripsi,
        aras: data.aras,
        pemilik: data.pemilik,
    })
}

fungsi utama() -> Nombor kesan Tulis {
    cetak("=== Hierarki Aras Keselamatan ===\n");

    /// Buat data pada pelbagai aras
    biar awam = DataBerlabel {
        nilai: "Maklumat awam",
        aras: ArasKeselamatan.Awam,
        pemilik: "sistem",
    };

    biar dalaman = DataBerlabel {
        nilai: "Maklumat dalaman",
        aras: ArasKeselamatan.Dalaman,
        pemilik: "perusahaan",
    };

    biar rahsia = DataBerlabel {
        nilai: "Maklumat rahsia",
        aras: ArasKeselamatan.Rahsia,
        pemilik: "admin",
    };

    /// Periksa aliran maklumat
    biar boleh_alir = bandingkan_aras(ArasKeselamatan.Dalaman, ArasKeselamatan.Awam);
    cetak("Aliran dari Dalaman ke Awam boleh: ");
    cetak(boleh_alir);
    cetak("\n");

    /// Periksa akses
    biar ada_akses = perihal_akses(ArasKeselamatan.Dalaman, dalaman);
    cetak("Akses ke Dalaman: ");
    cetak(ada_akses);
    cetak("\n");

    cetak("Selesai\n");
    pulang 0;
}

/// SECURITY NOTE: Information flow enforcement (IFC).
/// Data can only flow to same or higher security level.
/// Type system prevents data downgrade attacks.
/// All mixing/operations track information level.

// === 07_EXAMPLES/01_security/tainted_data.rii ===
/// TAINTED_DATA.RII - Tainted Data Tracking
/// Penjejakan data tercemar dari sumber tidak dipercayai
/// Demonstrates: data contamination, source tracking, sanitization

jenis Sumber {
    Http,
    Pengguna,
    Fail,
    Rangkaian,
    Program,
}

jenis DataTercemar<T> {
    nilai: T,
    sumber: Sumber,
    masa_ciptaan: Nombor,
}

fungsi tandakan_tercemar_http(nilai: Teks) -> DataTercemar<Teks> kesan Baca {
    /// Tandakan data dari HTTP sebagai tercemar
    DataTercemar {
        nilai: nilai,
        sumber: Sumber.Http,
        masa_ciptaan: 0,
    }
}

fungsi tandakan_tercemar_pengguna(nilai: Teks) -> DataTercemar<Teks> kesan Baca {
    /// Tandakan data dari input pengguna sebagai tercemar
    DataTercemar {
        nilai: nilai,
        sumber: Sumber.Pengguna,
        masa_ciptaan: 0,
    }
}

fungsi tandakan_tercemar_fail(nama_fail: Teks) -> DataTercemar<Teks> kesan Baca {
    /// Tandakan data dari fail sebagai tercemar
    biar kandungan = baca_fail(nama_fail);
    DataTercemar {
        nilai: kandungan,
        sumber: Sumber.Fail,
        masa_ciptaan: 0,
    }
}

fungsi tandakan_tercemar_rangkaian(data: Teks) -> DataTercemar<Teks> kesan Rangkaian {
    /// Tandakan data dari rangkaian sebagai tercemar
    DataTercemar {
        nilai: data,
        sumber: Sumber.Rangkaian,
        masa_ciptaan: 0,
    }
}

fungsi propogasi_taint<T>(
    d: DataTercemar<T>,
    f: Fn(T) -> T
) -> DataTercemar<T> kesan Bersih {
    /// Taint mempropogasi melalui transformasi
    DataTercemar {
        nilai: f(d.nilai),
        sumber: d.sumber,
        masa_ciptaan: d.masa_ciptaan,
    }
}

fungsi campurkan_taint(
    d1: DataTercemar<Teks>,
    d2: DataTercemar<Teks>
) -> DataTercemar<Teks> kesan Bersih {
    /// Campurkan taint dari kedua sumber
    biar sumber_baru = padan (d1.sumber, d2.sumber) {
        (Sumber.Http, Sumber.Http) -> Sumber.Http,
        (s1, s2) kalau s1 == s2 -> s1,
        _ -> Sumber.Program,  /// Campuran
    };

    DataTercemar {
        nilai: d1.nilai + d2.nilai,
        sumber: sumber_baru,
        masa_ciptaan: 0,
    }
}

fungsi bersihkan_sql_injection(d: DataTercemar<Teks>) -> DataTercemar<Teks> kesan Bersih {
    /// Bersihkan data untuk mengelakkan SQL injection
    biar teks_bersih = d.nilai
        .ganti("'", "''")
        .ganti("\"", "\\\"")
        .ganti(";", "\\;");

    DataTercemar {
        nilai: teks_bersih,
        sumber: d.sumber,
        masa_ciptaan: d.masa_ciptaan,
    }
}

fungsi bersihkan_html_escape(d: DataTercemar<Teks>) -> DataTercemar<Teks> kesan Bersih {
    /// Bersihkan data untuk HTML escaping
    biar teks_bersih = d.nilai
        .ganti("<", "&lt;")
        .ganti(">", "&gt;")
        .ganti("&", "&amp;")
        .ganti("\"", "&quot;")
        .ganti("'", "&#x27;");

    DataTercemar {
        nilai: teks_bersih,
        sumber: d.sumber,
        masa_ciptaan: d.masa_ciptaan,
    }
}

fungsi nyahcemar(d: DataTercemar<Teks>) -> Teks kesan Bersih {
    /// Nyahcemar - hanya untuk data bersih atau disanitasi
    d.nilai
}

fungsi masukkan_ke_database_aman(
    d: DataTercemar<Teks>,
    jadual: Teks,
    medan: Teks
) -> Hasil<Nombor, Teks> kesan (Tulis, Baca) {
    /// Masukkan ke database dengan pembersihan
    biar dibersihkan = bersihkan_sql_injection(d);
    biar nilai_aman = nyahcemar(dibersihkan);

    cetak("INSERT INTO {jadual} ({medan}) VALUES ('{nilai_aman}')\n");
    Ok(1)
}

fungsi keluarkan_ke_html_aman(
    d: DataTercemar<Teks>
) -> Hasil<Teks, Teks> kesan (Tulis, Bersih) {
    /// Keluarkan ke HTML dengan escaping
    biar dibersihkan = bersihkan_html_escape(d);
    biar nilai_aman = nyahcemar(dibersihkan);

    cetak("<p>");
    cetak(nilai_aman);
    cetak("</p>\n");

    Ok(nilai_aman)
}

fungsi utama() -> Nombor kesan (Baca, Tulis) {
    cetak("=== Penjejakan Data Tercemar ===\n");

    /// Baca input dari pengguna
    biar input = tandakan_tercemar_pengguna("Ahmad<script>alert('XSS')</script>");
    cetak("Input tercemar: ");
    cetak(input.nilai);
    cetak("\n");

    /// Transformasi mengekalkan taint
    biar diubah = propogasi_taint(input, fungsi(t: Teks) -> Teks {
        t.besarkan()
    });
    cetak("Selepas transformasi tetap tercemar\n");

    /// Bersihkan untuk output HTML
    biar hasil = keluarkan_ke_html_aman(diubah);
    padan hasil {
        Ok(nilai) -> {
            cetak("HTML aman: ");
            cetak(nilai);
            cetak("\n");
        },
        Ralat(e) -> cetak("Ralat: "),
    }

    pulang 0;
}

/// SECURITY NOTE: Tercemar marks data from untrusted sources.
/// Taint propagates through all operations.
/// Sinks (database, output) require sanitization before use.
/// Compiler tracks taint through entire program.

// === 07_EXAMPLES/01_security/time_bounded_cap.rii ===
/// TIME_BOUNDED_CAP.RII - Time-Bounded Capabilities
/// Keupayaan yang dibatasi masa untuk penggunaan sementara
/// Demonstrates: expiry tracking, time bounds, revocation

jenis Keupayaan<T> {
    hak: T,
    pemilik: Teks,
    waktu_dibuat: Nombor,
    waktu_tamat: Nombor,
    masa_guna_tinggal: Nombor,
}

jenis HakUmum {
    jenis_hak: Teks,
}

fungsi buat_keupayaan_masa_terbatas<T>(
    hak: T,
    pemilik: Teks,
    durasi_saat: Nombor
) -> Keupayaan<T> kesan Masa {
    /// Buat keupayaan dengan batas masa
    biar waktu_kini = ambil_waktu_kini();
    biar waktu_tamat = waktu_kini + durasi_saat;

    Keupayaan {
        hak: hak,
        pemilik: pemilik,
        waktu_dibuat: waktu_kini,
        waktu_tamat: waktu_tamat,
        masa_guna_tinggal: durasi_saat,
    }
}

fungsi periksa_keupayaan_belum_tamat<T>(
    cap: Keupayaan<T>
) -> Benar kesan Masa {
    /// Periksa sama ada keupayaan belum tamat
    biar waktu_kini = ambil_waktu_kini();
    waktu_kini < cap.waktu_tamat
}

fungsi gunakan_keupayaan_masa_terbatas<T>(
    ubah cap: Keupayaan<T>
) -> Hasil<T, Teks> kesan Masa {
    /// Gunakan keupayaan dengan pemeriksaan masa
    kalau !periksa_keupayaan_belum_tamat(cap) {
        pulang Ralat("Keupayaan telah tamat masa");
    }

    kalau cap.masa_guna_tinggal <= 0 {
        pulang Ralat("Penggunaan telah habis");
    }

    /// Kurangkan penggunaan tinggal
    cap.masa_guna_tinggal = cap.masa_guna_tinggal - 1;

    Ok(cap.hak)
}

fungsi perpanjang_keupayaan<T>(
    ubah cap: Keupayaan<T>,
    durasi_tambahan_saat: Nombor
) -> Hasil<Keupayaan<T>, Teks> kesan Masa {
    /// Perpanjang keupayaan
    kalau !periksa_keupayaan_belum_tamat(cap) {
        pulang Ralat("Keupayaan sudah tamat, tidak dapat perpanjang");
    }

    cap.waktu_tamat = cap.waktu_tamat + durasi_tambahan_saat;
    cap.masa_guna_tinggal = cap.masa_guna_tinggal + durasi_tambahan_saat;

    Ok(cap)
}

fungsi sisa_masa_keupayaan<T>(
    cap: Keupayaan<T>
) -> Nombor kesan Masa {
    /// Dapatkan sisa masa keupayaan dalam saat
    biar waktu_kini = ambil_waktu_kini();
    biar sisa = cap.waktu_tamat - waktu_kini;

    kalau sisa < 0 {
        0
    } lain {
        sisa
    }
}

fungsi keupayaan_setara_umur_sesi(
    id_sesi: Teks,
    durasi_sesi: Nombor
) -> Keupayaan<HakUmum> kesan Masa {
    /// Buat keupayaan yang sama dengan umur sesi
    buat_keupayaan_masa_terbatas(
        HakUmum { jenis_hak: "sesi:{id_sesi}" },
        "sistem",
        durasi_sesi
    )
}

fungsi keupayaan_dengan_had_penggunaan<T>(
    cap: Keupayaan<T>,
    had_penggunaan: Nombor
) -> Keupayaan<T> kesan Bersih {
    /// Keupayaan dengan had penggunaan tambahan
    Keupayaan {
        hak: cap.hak,
        pemilik: cap.pemilik,
        waktu_dibuat: cap.waktu_dibuat,
        waktu_tamat: cap.waktu_tamat,
        masa_guna_tinggal: had_penggunaan,
    }
}

fungsi daftarkan_keupayaan_berakhir(
    ubah cap: Keupayaan<HakUmum>
) -> Hasil<Nombor, Teks> kesan (Tulis, Masa) {
    /// Daftarkan keupayaan yang akan berakhir
    biar sisa = sisa_masa_keupayaan(cap);

    kalau sisa < 3600 {  /// Kurang dari 1 jam
        cetak("Amaran: Keupayaan akan tamat dalam ");
        cetak(sisa);
        cetak(" saat\n");
    }

    Ok(sisa)
}

fungsi utama() -> Nombor kesan (Masa, Tulis) {
    cetak("=== Keupayaan Terbatas Masa ===\n");

    /// Buat keupayaan 1 jam
    biar cap = buat_keupayaan_masa_terbatas(
        HakUmum { jenis_hak: "baca" },
        "pengguna1",
        3600
    );

    cetak("Keupayaan dibuat dengan durasi 1 jam\n");

    /// Periksa keupayaan
    biar belum_tamat = periksa_keupayaan_belum_tamat(cap);
    cetak("Keupayaan belum tamat: ");
    cetak(belum_tamat);
    cetak("\n");

    /// Sisa masa
    biar sisa = sisa_masa_keupayaan(cap);
    cetak("Sisa masa (saat): ");
    cetak(sisa);
    cetak("\n");

    /// Daftarkan
    padan daftarkan_keupayaan_berakhir(cap) {
        Ok(s) -> {
            cetak("Didaftarkan, sisa: ");
            cetak(s);
            cetak(" saat\n");
        },
        Ralat(e) -> cetak("Ralat\n"),
    }

    cetak("Selesai\n");
    pulang 0;
}

/// SECURITY NOTE: Time-bounded capabilities auto-expire.
/// waktu_tamat prevents indefinite access.
/// masa_guna_tinggal limits usage count.
/// Requires refresh/renewal for extended access.

// === 07_EXAMPLES/01_security/zeroizing.rii ===
/// ZEROIZING.RII - Secure Memory Zeroization
/// Pembersihan memori aman untuk data sensitif
/// Demonstrates: Sifar type, secure memory, garbage collection safety

jenis Sifar<T> {
    nilai: T,
    sifar_apabila_habis: Benar,
}

fungsi buat_sifar<T>(nilai: T) -> Sifar<T> kesan Bersih {
    /// Buat nilai yang akan disifar
    Sifar {
        nilai: nilai,
        sifar_apabila_habis: betul,
    }
}

fungsi gunakan_sifar<T>(
    s: Sifar<T>,
    f: Fn(T) -> Nombor
) -> Nombor kesan Bersih {
    /// Gunakan nilai dalam sifar
    f(s.nilai)
}

fungsi akses_sifar<T>(s: Sifar<T>) -> T kesan Bersih {
    /// Akses nilai dalam sifar (akan disifar selepas)
    s.nilai
}

fungsi sifar_segera<T>(ubah s: Sifar<T>) -> Nombor kesan (MasaTetap, Bersih) {
    /// Sifar segera tanpa menunggu garbage collection
    /// Immediate erase without GC delay
    /// (Simulasi - actual implementation uses volatile writes)
    0
}

jenis KateLaluanSifar {
    hash: Sifar<Teks>,
    garam: Sifar<Teks>,
}

fungsi buat_kata_laluan_sifar(t: Teks) -> KateLaluanSifar kesan (Kripto, MasaTetap) {
    /// Buat kata laluan yang sifar
    biar garam = buat_sifar(hasilkan_garam());
    biar hash = buat_sifar(
        hash_dengan_argon2(t, akses_sifar(garam))
    );

    KateLaluanSifar {
        hash: hash,
        garam: garam,
    }
}

fungsi gunakan_kata_laluan_sifar(
    kl: KateLaluanSifar,
    calon: Teks
) -> Hasil<Benar, Teks> kesan (MasaTetap, Kripto) {
    /// Gunakan kata laluan yang sifar
    biar hash_calon = hash_dengan_argon2(calon, akses_sifar(kl.garam));
    biar disamakan = bandingkan_masa_tetap(
        hash_calon,
        akses_sifar(kl.hash)
    );

    Ok(disamakan)
}

fungsi kunci_sifar(ubah k: Sifar<Rahsia<Teks>>) -> Hasil<Nombor, Teks> kesan (MasaTetap, Bersih) {
    /// Sifar kunci
    sifar_segera(k);
    Ok(0)
}

fungsi buffer_sifar(saiz: Nombor) -> Sifar<Senarai<Nombor>> kesan Bersih {
    /// Buat buffer yang sifar
    biar buffer = [0; saiz];
    buat_sifar(buffer)
}

fungsi ulang_dengan_sifar<T>(
    data: Sifar<Teks>,
    f: Fn(Teks) -> T
) -> T kesan Bersih {
    /// Ulang (process) dengan sifar
    f(akses_sifar(data))
}

jenis ButiranPenggunaSifar {
    nama: Teks,
    emel: Teks,
    kata_laluan: Sifar<Teks>,
}

fungsi buat_pengguna_sifar(
    nama: Teks,
    emel: Teks,
    kata_laluan: Teks
) -> ButiranPenggunaSifar kesan Bersih {
    /// Buat butiran pengguna dengan kata laluan sifar
    ButiranPenggunaSifar {
        nama: nama,
        emel: emel,
        kata_laluan: buat_sifar(kata_laluan),
    }
}

fungsi hapus_pengguna_sifar(
    ubah pengguna: ButiranPenggunaSifar
) -> Hasil<Nombor, Teks> kesan MasaTetap {
    /// Hapus pengguna dengan sifar kata laluan
    sifar_segera(pengguna.kata_laluan);
    Ok(0)
}

fungsi utama() -> Nombor kesan (Kripto, Tulis, MasaTetap) {
    cetak("=== Sifar Memori Aman ===\n");

    /// Buat nilai sifar
    biar rahsia = buat_sifar("rahsiat123");
    cetak("Rahsia dibuat dengan sifar\n");

    /// Gunakan nilai
    biar hasil = gunakan_sifar(rahsia, fungsi(t: Teks) -> Nombor {
        cetak("Menggunakan: ");
        cetak(t);
        cetak("\n");
        0
    });

    /// Sifar segera
    sifar_segera(rahsia);
    cetak("Rahsia disifar\n");

    /// Buat pengguna dengan kata laluan sifar
    biar pengguna = buat_pengguna_sifar("Ahmad", "ahmad@example.com", "kata_laluan");
    cetak("Pengguna dibuat dengan kata laluan sifar\n");

    cetak("Selesai\n");
    pulang 0;
}

/// SECURITY NOTE: Sifar<T> guarantees secure memory clearing.
/// Memory is overwritten when value is dropped.
/// sifar_segera for immediate erasure without GC delay.
/// Prevents sensitive data recovery from memory dumps.

// === 07_EXAMPLES/02_effects/capability_gated.rii ===
/// CAPABILITY_GATED.RII - Capability-Gated Effects
/// Kesan terpintu dengan keupayaan
/// Demonstrates: effect authorization, capability checks

jenis Keupayaan<T> {
    hak: T,
}

jenis HakTulis {
    ada_tulis: Benar,
}

jenis HakBaca {
    ada_baca: Benar,
}

fungsi buat_keupayaan_tulis() -> Keupayaan<HakTulis> kesan Bersih {
    /// Buat keupayaan tulis
    Keupayaan {
        hak: HakTulis { ada_tulis: betul },
    }
}

fungsi buat_keupayaan_baca() -> Keupayaan<HakBaca> kesan Bersih {
    /// Buat keupayaan baca
    Keupayaan {
        hak: HakBaca { ada_baca: betul },
    }
}

fungsi tulis_dengan_keupayaan(
    cap: Keupayaan<HakTulis>,
    mesej: Teks
) -> Hasil<Nombor, Teks> kesan (Tulis, Bersih) {
    /// Tulis hanya jika ada keupayaan
    kalau cap.hak.ada_tulis {
        cetak(mesej);
        cetak("\n");
        Ok(0)
    } lain {
        Ralat("Tiada keupayaan tulis")
    }
}

fungsi baca_dengan_keupayaan(
    cap: Keupayaan<HakBaca>
) -> Hasil<Teks, Teks> kesan (Baca, Bersih) {
    /// Baca hanya jika ada keupayaan
    kalau cap.hak.ada_baca {
        Ok(baca_garisan())
    } lain {
        Ralat("Tiada keupayaan baca")
    }
}

fungsi fail_tulis_dengan_keupayaan(
    cap: Keupayaan<HakTulis>,
    fail: Teks,
    kandungan: Teks
) -> Hasil<Nombor, Teks> kesan (Tulis, SistemFail, Bersih) {
    /// Tulis fail hanya jika ada keupayaan
    kalau !cap.hak.ada_tulis {
        pulang Ralat("Tiada keupayaan tulis ke fail");
    }

    padan tulis_ke_fail(fail, kandungan) {
        Ok(_) -> Ok(0),
        Ralat(e) -> Ralat("Tulis fail gagal"),
    }
}

fungsi fail_baca_dengan_keupayaan(
    cap: Keupayaan<HakBaca>,
    fail: Teks
) -> Hasil<Teks, Teks> kesan (Baca, SistemFail, Bersih) {
    /// Baca fail hanya jika ada keupayaan
    kalau !cap.hak.ada_baca {
        pulang Ralat("Tiada keupayaan baca dari fail");
    }

    padan baca_fail_sepenuhnya(fail) {
        Ok(kandungan) -> Ok(kandungan),
        Ralat(e) -> Ralat("Baca fail gagal"),
    }
}

fungsi delegasi_keupayaan<T>(
    cap: Keupayaan<T>
) -> Keupayaan<T> kesan Bersih {
    /// Delegasi keupayaan
    cap
}

fungsi utama() -> Nombor kesan (Tulis, Baca, SistemFail) {
    cetak("=== Kesan Terpintu Keupayaan ===\n");

    /// Buat keupayaan
    biar cap_tulis = buat_keupayaan_tulis();
    biar cap_baca = buat_keupayaan_baca();

    cetak("Keupayaan dibuat\n");

    /// Gunakan keupayaan tulis
    padan tulis_dengan_keupayaan(cap_tulis, "Mesej dengan keupayaan") {
        Ok(_) -> cetak("Tulis berjaya\n"),
        Ralat(e) -> cetak("Ralat: "),
    }

    /// Gunakan keupayaan baca
    padan baca_dengan_keupayaan(cap_baca) {
        Ok(data) -> {
            cetak("Dibaca: ");
            cetak(data);
            cetak("\n");
        },
        Ralat(e) -> cetak("Ralat baca\n"),
    }

    /// Tulis fail dengan keupayaan
    padan fail_tulis_dengan_keupayaan(cap_tulis, "test.txt", "Kandungan") {
        Ok(_) -> cetak("Tulis fail berjaya\n"),
        Ralat(e) -> cetak("Ralat tulis fail\n"),
    }

    cetak("Selesai\n");
    pulang 0;
}

/// SECURITY NOTE: Capability-gated effects prevent unauthorized operations.
/// Type system enforces capability presence before effect can execute.
/// Provides fine-grained access control at compile time.

// === 07_EXAMPLES/02_effects/crypto_ops.rii ===
/// CRYPTO_OPS.RII - Cryptographic Operations
/// Operasi kriptografi
/// Demonstrates: Kripto effect, encryption, hashing

fungsi hash_sha256(data: Teks) -> Teks kesan Kripto {
    /// Hash menggunakan SHA-256
    /// Simulasi
    "hash_sha256_result"
}

fungsi hash_sha512(data: Teks) -> Teks kesan Kripto {
    /// Hash menggunakan SHA-512
    "hash_sha512_result"
}

fungsi enkripsi_aes256(
    plaintext: Teks,
    kunci: Teks
) -> Teks kesan (Kripto, MasaTetap) {
    /// Enkripsi AES-256
    "ciphertext_aes256"
}

fungsi dekripsi_aes256(
    ciphertext: Teks,
    kunci: Teks
) -> Hasil<Teks, Teks> kesan (Kripto, MasaTetap) {
    /// Dekripsi AES-256
    Ok("plaintext")
}

fungsi hasilkan_kunci_rawak(panjang: Nombor) -> Teks kesan (Kripto, Rawak) {
    /// Hasilkan kunci rawak
    "random_key_"
}

fungsi tandatangan_rsa(
    data: Teks,
    kunci_privat: Teks
) -> Teks kesan (Kripto, MasaTetap) {
    /// Tandatangani menggunakan RSA
    "rsa_signature"
}

fungsi verifikasi_tandatangan_rsa(
    data: Teks,
    tandatangan: Teks,
    kunci_publik: Teks
) -> Benar kesan (Kripto, MasaTetap) {
    /// Verifikasi tandatangan RSA
    betul
}

fungsi tukar_base64(data: Teks) -> Teks kesan Kripto {
    /// Enkod ke Base64
    "base64_encoded"
}

fungsi buka_base64(data_b64: Teks) -> Hasil<Teks, Teks> kesan Kripto {
    /// Dekod dari Base64
    Ok("decoded_data")
}

fungsi hmac_sha256(
    data: Teks,
    kunci: Teks
) -> Teks kesan (Kripto, MasaTetap) {
    /// Hasilkan HMAC-SHA256
    "hmac_result"
}

fungsi hasilkan_salt_rawak() -> Teks kesan (Kripto, Rawak) {
    /// Hasilkan salt rawak untuk password hashing
    "salt_"
}

fungsi hash_kata_laluan_argon2(
    kata_laluan: Teks,
    salt: Teks
) -> Teks kesan (Kripto, MasaTetap) {
    /// Hash kata laluan menggunakan Argon2
    "argon2_hash"
}

fungsi utama() -> Nombor kesan (Kripto, Tulis, Rawak, MasaTetap) {
    cetak("=== Operasi Kriptografi ===\n");

    /// Hash data
    biar data = "data sensitif";
    biar hash = hash_sha256(data);
    cetak("SHA-256: ");
    cetak(hash);
    cetak("\n");

    /// Hasilkan kunci rawak
    biar kunci = hasilkan_kunci_rawak(32);
    cetak("Kunci: ");
    cetak(kunci);
    cetak("\n");

    /// Enkripsi
    biar plaintext = "Maklumat rahsia";
    biar ciphertext = enkripsi_aes256(plaintext, kunci);
    cetak("Ciphertext: ");
    cetak(ciphertext);
    cetak("\n");

    /// Dekripsi
    padan dekripsi_aes256(ciphertext, kunci) {
        Ok(decrypted) -> {
            cetak("Decrypted: ");
            cetak(decrypted);
            cetak("\n");
        },
        Ralat(e) -> cetak("Dekripsi gagal\n"),
    }

    /// HMAC
    biar hmac = hmac_sha256("data", "secret");
    cetak("HMAC: ");
    cetak(hmac);
    cetak("\n");

    /// Hash kata laluan
    biar salt = hasilkan_salt_rawak();
    biar kata_laluan_hash = hash_kata_laluan_argon2("kata_laluan_pengguna", salt);
    cetak("Kata laluan di-hash\n");

    cetak("Selesai\n");
    pulang 0;
}

/// GRAMMAR NOTE: kesan Kripto for cryptographic operations.
/// Often combined with MasaTetap for constant-time execution.
/// Often combined with Rawak for key/salt generation.

// === 07_EXAMPLES/02_effects/effect_composition.rii ===
/// EFFECT_COMPOSITION.RII - Composing Multiple Effects
/// Penggabungan berbilang kesan
/// Demonstrates: effect unions, effect stacking, pure + side effects

fungsi baca_dan_tulis(
    nama_input: Teks,
    nama_output: Teks
) -> Hasil<Nombor, Teks> kesan (Baca, Tulis) {
    /// Menggabungkan Baca dan Tulis
    cetak("Membaca dari ");
    cetak(nama_input);
    cetak("\n");

    padan baca_fail_sepenuhnya(nama_input) {
        Ok(kandungan) -> {
            cetak("Menulis ke ");
            cetak(nama_output);
            cetak("\n");

            padan tulis_ke_fail(nama_output, kandungan) {
                Ok(_) -> Ok(0),
                Ralat(e) -> Ralat("Tulis gagal"),
            }
        },
        Ralat(e) -> Ralat("Baca gagal"),
    }
}

fungsi pengiraan_dengan_kesan(
    x: Nombor,
    y: Nombor
) -> Nombor kesan (Tulis, Bersih) {
    /// Penggabungan Tulis dan Bersih
    cetak("Mengira: ");
    cetak(x);
    cetak(" + ");
    cetak(y);
    cetak(" = ");

    biar hasil = x + y;
    cetak(hasil);
    cetak("\n");

    hasil
}

fungsi operasi_lengkap(
    fail_input: Teks,
    fail_output: Teks
) -> Hasil<Teks, Teks> kesan (Baca, Tulis, Kripto, Masa) {
    /// Menggabungkan empat kesan
    cetak("Operasi lengkap dimulai\n");

    /// Baca
    padan baca_fail_sepenuhnya(fail_input) {
        Ok(kandungan) -> {
            /// Kripto - hash kandungan
            biar hash = hash_sha256(kandungan);
            cetak("Hash: ");
            cetak(hash);
            cetak("\n");

            /// Tulis output
            biar output_format = "Hash: {hash}\nKandungan: {kandungan}";

            padan tulis_ke_fail(fail_output, output_format) {
                Ok(_) -> {
                    cetak("Operasi lengkap selesai\n");
                    Ok(hash)
                },
                Ralat(e) -> Ralat("Tulis gagal"),
            }
        },
        Ralat(e) -> Ralat("Baca gagal"),
    }
}

fungsi laku_beberapa_kesan(
    nama_fail: Teks
) -> Hasil<Senarai<Teks>, Teks> kesan (Baca, Tulis, SistemFail) {
    /// Laku (perform) beberapa kesan secara bersamaan
    cetak("Memulai operasi fail\n");

    /// Periksa fail wujud
    kalau !ada_fail(nama_fail) {
        cetak("Fail tidak wujud, membuat...\n");
        padan buat_fail(nama_fail) {
            Ok(_) -> { /* teruskan */ },
            Ralat(e) -> pulang Ralat("Tidak dapat buat fail"),
        }
    }

    /// Baca fail
    padan baca_fail_sepenuhnya(nama_fail) {
        Ok(kandungan) -> {
            /// Tulis log
            cetak("Fail dibaca: ");
            cetak(nama_fail);
            cetak("\n");

            /// Senaraikan direktori
            padan senaraikan_fail(".") {
                Ok(fail_fail) -> {
                    Ok(fail_fail)
                },
                Ralat(e) -> Ralat("Senarai gagal"),
            }
        },
        Ralat(e) -> Ralat("Baca gagal"),
    }
}

fungsi efek_bersarang() -> Nombor kesan (Tulis, Baca, Masa) {
    /// Kesan bersarang dalam berbilang aras
    cetak("Level 1 - Tulis\n");

    biar masukan = minta_input("Masukkan nilai");

    cetak("Level 2 - Baca\n");
    cetak("Anda masukkan: ");
    cetak(masukan);
    cetak("\n");

    biar masa = ambil_waktu_kini();
    cetak("Level 3 - Masa\n");
    cetak("Waktu: ");
    cetak(masa);
    cetak("\n");

    0
}

fungsi pengecualian_kesan() -> Hasil<Nombor, Teks> kesan (Tulis, Baca, Bersih) {
    /// Penanganan kesan dengan pengecualian
    cetak("Mencuba operasi kesan\n");

    padan baca_nombor_dari_pengguna() {
        Ok(n) -> {
            cetak("Anda masukkan: ");
            cetak(n);
            cetak("\n");

            kalau n < 0 {
                Ralat("Nombor negatif")
            } lain {
                Ok(n * 2)
            }
        },
        Ralat(e) -> Ralat(e),
    }
}

fungsi utama() -> Nombor kesan (Baca, Tulis, Kripto, Masa, SistemFail) {
    cetak("=== Komposisi Kesan ===\n");

    /// Baca dan Tulis
    padan baca_dan_tulis("input.txt", "output.txt") {
        Ok(_) -> cetak("Baca-Tulis berjaya\n"),
        Ralat(e) -> cetak("Ralat\n"),
    }

    /// Pengiraan dengan Tulis
    biar hasil = pengiraan_dengan_kesan(10, 20);
    cetak("Hasil: ");
    cetak(hasil);
    cetak("\n");

    /// Kesan bersarang
    efek_bersarang();

    cetak("Selesai\n");
    pulang 0;
}

/// GRAMMAR NOTE: Multiple effects compose with comma syntax: (E1, E2, E3)
/// Order of effects doesn't matter for typing but may matter for execution.
/// Pure (Bersih) functions can only call pure functions.

// === 07_EXAMPLES/02_effects/effect_handlers.rii ===
/// EFFECT_HANDLERS.RII - Effect Handlers and Composition
/// Pengendali kesan dan komposisi
/// Demonstrates: composing effects, handling multiple effects

fungsi dengan_kesan_bersih<T>(
    f: Fn() -> T
) -> T kesan Bersih {
    /// Jalankan fungsi tulen
    f()
}

fungsi dengan_kesan_tulis<T>(
    f: Fn() -> T
) -> T kesan Tulis {
    /// Jalankan fungsi dengan kesan Tulis
    f()
}

fungsi dengan_kesan_baca<T>(
    f: Fn() -> T
) -> T kesan Baca {
    /// Jalankan fungsi dengan kesan Baca
    f()
}

fungsi dengan_kesan_berganda<T>(
    f: Fn() -> T
) -> T kesan (Tulis, Baca) {
    /// Jalankan fungsi dengan kesan berganda
    f()
}

fungsi kompos_dengan_kesan<T>(
    f1: Fn() -> T,
    f2: Fn(T) -> T
) -> T kesan (Tulis, Baca) {
    /// Komposisi dua fungsi dengan kesan
    biar hasil1 = f1();
    f2(hasil1)
}

fungsi tangani_kesan_dengan_hasil<T>(
    f: Fn() -> Hasil<T, Teks>
) -> T kesan (Tulis, Baca) {
    /// Tangani kesan dengan penanganan ralat
    padan f() {
        Ok(t) -> {
            cetak("Berjaya\n");
            t
        },
        Ralat(e) -> {
            cetak("Ralat: ");
            cetak(e);
            cetak("\n");
            /// Nilai lalai
            padan ambil_nilai_lalai() {
                Ok(v) -> v,
                Ralat(_) -> {
                    /// Nilai terakhir
                    padan f() {
                        Ok(t) -> t,
                        Ralat(e) -> {
                            cetak("Kegagalan berganda\n");
                            /// Jangan dapat t di sini
                            panic("Gagal mendapatkan nilai")
                        },
                    }
                },
            }
        },
    }
}

fungsi ambil_nilai_lalai<T>() -> Hasil<T, Teks> kesan Bersih {
    Ok(0)  /// Simulasi
}

fungsi jalankan_dengan_konteks(
    konteks: Teks,
    f: Fn() -> Nombor
) -> Nombor kesan (Tulis, Baca) {
    cetak("Konteks: ");
    cetak(konteks);
    cetak("\n");

    biar hasil = f();

    cetak("Selesai\n");
    hasil
}

fungsi pilin_kesan(
    pilihan: Benar,
    f_tulis: Fn() -> Nombor,
    f_baca: Fn() -> Nombor
) -> Nombor kesan (Tulis, Baca) {
    /// Pilih kesan berdasarkan keadaan
    kalau pilihan {
        f_tulis()
    } lain {
        f_baca()
    }
}

fungsi kesan_yang_disertakan<T>(
    kesan_a: Fn() -> T,
    kesan_b: Fn(T) -> T
) -> T kesan (Tulis, Baca, Masa) {
    /// Kesan yang disertakan
    cetak("Mula\n");
    biar hasil_a = kesan_a();
    biar hasil_b = kesan_b(hasil_a);
    cetak("Selesai\n");
    hasil_b
}

fungsi utama() -> Nombor kesan (Tulis, Baca) {
    cetak("=== Pengendali Kesan ===\n");

    /// Dengan kesan tulis
    biar hasil1 = dengan_kesan_tulis(fungsi() -> Nombor {
        cetak("Fungsi 1\n");
        pulang 1;
    });

    cetak("Hasil 1: ");
    cetak(hasil1);
    cetak("\n");

    /// Dengan kesan berganda
    biar hasil2 = dengan_kesan_berganda(fungsi() -> Nombor {
        cetak("Fungsi 2\n");
        pulang 2;
    });

    cetak("Hasil 2: ");
    cetak(hasil2);
    cetak("\n");

    /// Komposisi
    biar hasil3 = kompos_dengan_kesan(
        fungsi() -> Nombor { 5 },
        fungsi(x: Nombor) -> Nombor {
            cetak("Komposisi: ");
            cetak(x);
            cetak("\n");
            x * 2
        }
    );

    cetak("Hasil 3: ");
    cetak(hasil3);
    cetak("\n");

    cetak("Selesai\n");
    pulang 0;
}

/// GRAMMAR NOTE: Effects compose by union (Tulis, Baca, Masa, etc).
/// Handlers can modify execution context for effects.
/// Type system enforces effect ordering and composition.

// === 07_EXAMPLES/02_effects/effect_inference.rii ===
/// EFFECT_INFERENCE.RII - Effect Type Inference
/// Penyimpulan jenis kesan secara automatik
/// Demonstrates: implicit effect tracking, type inference

/// Compiler automatically infers kesan Bersih
fungsi tambah(x: Nombor, y: Nombor) -> Nombor {
    x + y
}

/// Compiler automatically infers kesan Tulis
fungsi cetak_nombor(x: Nombor) {
    cetak(x);
    cetak("\n");
}

/// Compiler automatically infers kesan (Tulis, Bersih)
fungsi cetak_hasil(x: Nombor, y: Nombor) {
    cetak("Hasil: ");
    cetak(x + y);
    cetak("\n");
}

/// Compiler infers kesan (Baca, Bersih)
fungsi baca_dan_tambah(y: Nombor) -> Mungkin<Nombor> {
    padan baca_nombor_dari_pengguna() {
        Ok(x) -> Ada(x + y),
        Ralat(_) -> Tidak,
    }
}

/// Return type help inference
fungsi operasi_kompleks(x: Nombor) -> Hasil<Nombor, Teks> {
    kalau x < 0 {
        Ralat("Negatif")
    } lain {
        Ok(x * 2)
    }
}

/// Generic function - effect inferred from parameter
fungsi peta_dengan_inferensi<T1, T2>(
    senarai: Senarai<T1>,
    f: Fn(T1) -> T2
) -> Senarai<T2> {
    senarai.peta(f)
}

/// Tupling inference
fungsi pasangan_daripada_pembacaan() -> Mungkin<(Teks, Nombor)> {
    padan baca_dan_tambah(5) {
        Ada(n) -> {
            biar t = minta_input("Nama");
            Ada((t, n))
        },
        Tidak -> Tidak,
    }
}

/// Conditional inference
fungsi bersyarat_berbeza(keadaan: Benar) {
    kalau keadaan {
        cetak("Benar\n");
    } lain {
        cetak("Salah\n");
    }
}

fungsi utama() -> Nombor {
    cetak("=== Penyimpulan Jenis Kesan ===\n");

    /// Penyimpulan bersih
    biar a = tambah(5, 3);
    cetak("Tambah: ");
    cetak(a);
    cetak("\n");

    /// Penyimpulan Tulis
    cetak_nombor(10);

    /// Penyimpulan gabung
    cetak_hasil(20, 30);

    /// Penyimpulan dengan generik
    biar senarai = [1, 2, 3];
    biar ubahan = peta_dengan_inferensi(senarai, fungsi(x: Nombor) -> Nombor {
        x * 2
    });

    cetak("Ubahan: ");
    cetak(ubahan);
    cetak("\n");

    cetak("Selesai\n");
    pulang 0;
}

/// GRAMMAR NOTE: Effect inference reduces annotation burden.
/// Compiler tracks effects through call chains.
/// Explicit annotations still available for clarity.
/// Type checker unifies inferred effects with declarations.

// === 07_EXAMPLES/02_effects/effect_polymorphism.rii ===
/// EFFECT_POLYMORPHISM.RII - Polymorphic Effects
/// Kesan polimorfik untuk fleksibilitas
/// Demonstrates: effect parameters, generic effects

fungsi laku<E, T>(
    f: Fn() -> T
) -> T kesan E {
    /// Fungsi polimorfik dalam kesan
    /// (Pseudocode - actual syntax may vary)
    f()
}

fungsi peta_dengan_kesan<E, T1, T2>(
    senarai: Senarai<T1>,
    f: Fn(T1) -> T2
) -> Senarai<T2> kesan E {
    /// Peta yang mengekalkan kesan
    senarai.peta(f)
}

fungsi tapis_dengan_kesan<E, T>(
    senarai: Senarai<T>,
    f: Fn(T) -> Benar
) -> Senarai<T> kesan E {
    /// Tapis yang mengekalkan kesan
    senarai.tapis(f)
}

fungsi lipat_dengan_kesan<E, T, Akum>(
    senarai: Senarai<T>,
    f: Fn(Akum, T) -> Akum,
    awal: Akum
) -> Akum kesan E {
    /// Lipat yang mengekalkan kesan
    senarai.lipat(awal, f)
}

fungsi ubah_dengan_kesan<E, T>(
    f: Fn() -> T,
    g: Fn(T) -> T
) -> T kesan E {
    /// Gabung dua operasi dengan kesan yang sama
    biar hasil1 = f();
    g(hasil1)
}

fungsi tangani_kesan_atau_sulit(
    dengan_kesan: Fn() -> Nombor
) -> Hasil<Nombor, Teks> kesan Bersih {
    /// Tangani kesan atau sulit (restrict)
    Ok(0)
}

fungsi utama() -> Nombor kesan (Tulis, Baca) {
    cetak("=== Kesan Polimorfik ===\n");

    /// Gunakan peta dengan kesan
    biar senarai = [1, 2, 3, 4, 5];

    cetak("Senarai asal: ");
    cetak(senarai);
    cetak("\n");

    /// Tapis dengan cetak
    biar tapis = tapis_dengan_kesan(senarai, fungsi(x: Nombor) -> Benar {
        cetak("Memeriksa: ");
        cetak(x);
        cetak("\n");
        x > 2
    });

    cetak("Selepas tapis\n");

    cetak("Selesai\n");
    pulang 0;
}

/// GRAMMAR NOTE: Effect parameters make functions reusable across effects.
/// Functions can be called in contexts with superset of required effects.
/// Enables abstract effect-polymorphic libraries.

// === 07_EXAMPLES/02_effects/filesystem.rii ===
/// FILESYSTEM.RII - File System Operations
/// Operasi sistem fail
/// Demonstrates: SistemFail effect, file manipulation, directory ops

fungsi buat_fail(nama: Teks) -> Hasil<Nombor, Teks> kesan SistemFail {
    /// Buat fail baru
    padan buka_fail_untuk_tulis(nama) {
        Ok(fail) -> {
            tutup_fail(fail);
            Ok(0)
        },
        Ralat(e) -> Ralat("Tidak dapat buat fail: {e}"),
    }
}

fungsi padam_fail(nama: Teks) -> Hasil<Nombor, Teks> kesan SistemFail {
    /// Padam fail
    Ok(0)  /// Simulasi
}

fungsi senaraikan_fail(direktori: Teks) -> Hasil<Senarai<Teks>, Teks> kesan SistemFail {
    /// Senaraikan fail dalam direktori
    Ok(["file1.txt", "file2.txt"])  /// Simulasi
}

fungsi salin_fail(sumber: Teks, destinasi: Teks) -> Hasil<Nombor, Teks> kesan (SistemFail, Baca, Tulis) {
    /// Salin fail dari sumber ke destinasi
    padan baca_fail_sepenuhnya(sumber) {
        Ok(kandungan) -> {
            padan tulis_ke_fail(destinasi, kandungan) {
                Ok(_) -> Ok(0),
                Ralat(e) -> Ralat("Salin gagal"),
            }
        },
        Ralat(e) -> Ralat("Baca sumber gagal"),
    }
}

fungsi pindah_fail(sumber: Teks, destinasi: Teks) -> Hasil<Nombor, Teks> kesan SistemFail {
    /// Pindah fail
    Ok(0)  /// Simulasi
}

fungsi ada_fail(nama: Teks) -> Benar kesan SistemFail {
    /// Periksa sama ada fail wujud
    betul  /// Simulasi
}

fungsi ambil_saiz_fail(nama: Teks) -> Hasil<Nombor, Teks> kesan SistemFail {
    /// Ambil saiz fail dalam bait
    Ok(1024)  /// Simulasi
}

fungsi buat_direktori(nama: Teks) -> Hasil<Nombor, Teks> kesan SistemFail {
    /// Buat direktori
    Ok(0)
}

fungsi padam_direktori(nama: Teks) -> Hasil<Nombor, Teks> kesan SistemFail {
    /// Padam direktori kosong
    Ok(0)
}

fungsi dapatkan_direktori_kerja() -> Hasil<Teks, Teks> kesan SistemFail {
    /// Dapatkan direktori kerja semasa
    Ok("/home/pengguna")
}

fungsi tukar_direktori_kerja(nama: Teks) -> Hasil<Nombor, Teks> kesan SistemFail {
    /// Tukar direktori kerja
    Ok(0)
}

fungsi buat_struktur_direktori(
    akar: Teks,
    senarai_direktori: Senarai<Teks>
) -> Hasil<Nombor, Teks> kesan SistemFail {
    /// Buat struktur direktori bersarang
    untuk dir dalam senarai_direktori {
        biar nama_penuh = akar + "/" + dir;
        padan buat_direktori(nama_penuh) {
            Ok(_) -> { /* teruskan */ },
            Ralat(e) -> pulang Ralat("Gagal buat direktori"),
        }
    }

    Ok(0)
}

fungsi utama() -> Nombor kesan SistemFail {
    cetak("=== Operasi Fail ===\n");

    /// Buat direktori
    padan buat_direktori("data") {
        Ok(_) -> cetak("Direktori dibuat\n"),
        Ralat(e) -> cetak("Ralat\n"),
    }

    /// Senaraikan fail
    padan senaraikan_fail(".") {
        Ok(fail_fail) -> {
            cetak("Fail:\n");
            untuk f dalam fail_fail {
                cetak(f);
                cetak("\n");
            }
        },
        Ralat(e) -> cetak("Ralat senarai\n"),
    }

    /// Dapatkan direktori kerja
    padan dapatkan_direktori_kerja() {
        Ok(dir) -> {
            cetak("Direktori kerja: ");
            cetak(dir);
            cetak("\n");
        },
        Ralat(e) -> cetak("Ralat\n"),
    }

    cetak("Selesai\n");
    pulang 0;
}

/// GRAMMAR NOTE: kesan SistemFail for file system operations.
/// Operations may fail - return Hasil<T, E>.
/// File handles properly managed (automatic close).

// === 07_EXAMPLES/02_effects/io_read.rii ===
/// IO_READ.RII - Reading Input Operations
/// Operasi membaca input
/// Demonstrates: Baca effect, input operations, file reading

fungsi baca_baris_dari_pengguna() -> Teks kesan Baca {
    /// Baca satu baris dari stdin
    baca_garisan()
}

fungsi baca_nombor_dari_pengguna() -> Hasil<Nombor, Teks> kesan Baca {
    /// Baca nombor dari pengguna
    biar masukan = baca_garisan();
    padan tukar_string_ke_nombor(masukan) {
        Ada(n) -> Ok(n),
        Tidak -> Ralat("Bukan nombor sah"),
    }
}

fungsi baca_fail_sepenuhnya(nama_fail: Teks) -> Hasil<Teks, Teks> kesan Baca {
    /// Baca isi fail sepenuhnya
    padan buka_fail(nama_fail) {
        Ok(fail) -> {
            biar kandungan = baca_semua_dari_fail(fail);
            tutup_fail(fail);
            Ok(kandungan)
        },
        Ralat(e) -> Ralat("Tidak dapat buka fail: {e}"),
    }
}

fungsi baca_fail_baris_demi_baris(
    nama_fail: Teks,
    f: Fn(Teks) -> Nombor
) -> Hasil<Nombor, Teks> kesan Baca {
    /// Baca fail baris demi baris
    padan buka_fail(nama_fail) {
        Ok(fail) -> {
            biar ubah jumlah = 0;

            ulang {
                padan baca_baris_dari_fail(fail) {
                    Ok(baris) -> {
                        f(baris);
                        jumlah = jumlah + 1;
                    },
                    Ralat(_) -> putus,
                }
            }

            tutup_fail(fail);
            Ok(jumlah)
        },
        Ralat(e) -> Ralat("Fail tidak dapat dibuka"),
    }
}

fungsi baca_alam_sekitar(nama_pembolehubah: Teks) -> Mungkin<Teks> kesan Baca {
    /// Baca pembolehubah alam sekitar
    padan ambil_alam_sekitar(nama_pembolehubah) {
        Ada(nilai) -> Ada(nilai),
        Tidak -> Tidak,
    }
}

fungsi baca_konfigurasi_dari_fail(nama_fail: Teks) -> Hasil<Teks, Teks> kesan Baca {
    /// Baca fail konfigurasi
    padan baca_fail_sepenuhnya(nama_fail) {
        Ok(kandungan) -> Ok(kandungan),
        Ralat(e) -> Ralat("Tidak dapat baca konfigurasi: {e}"),
    }
}

fungsi baca_json_dari_fail(nama_fail: Teks) -> Hasil<Teks, Teks> kesan Baca {
    /// Baca JSON dari fail
    padan baca_fail_sepenuhnya(nama_fail) {
        Ok(kandungan) -> {
            /// Validasi JSON mudah
            kalau kandungan.ada("{") {
                Ok(kandungan)
            } lain {
                Ralat("JSON tidak sah")
            }
        },
        Ralat(e) -> Ralat(e),
    }
}

fungsi minta_input(
    gesaan: Teks
) -> Teks kesan (Tulis, Baca) {
    /// Minta input dengan gesaan
    cetak(gesaan);
    cetak(": ");
    baca_garisan()
}

fungsi minta_input_nombor(
    gesaan: Teks
) -> Hasil<Nombor, Teks> kesan (Tulis, Baca) {
    /// Minta input nombor dengan gesaan
    cetak(gesaan);
    cetak(": ");
    biar masukan = baca_garisan();
    padan tukar_string_ke_nombor(masukan) {
        Ada(n) -> Ok(n),
        Tidak -> Ralat("Input bukan nombor sah"),
    }
}

fungsi utama() -> Nombor kesan (Tulis, Baca) {
    cetak("=== Operasi Baca ===\n");

    /// Minta nama
    biar nama = minta_input("Masukkan nama");
    cetak("Nama: ");
    cetak(nama);
    cetak("\n");

    /// Minta umur
    padan minta_input_nombor("Masukkan umur") {
        Ok(umur) -> {
            cetak("Umur: ");
            cetak(umur);
            cetak("\n");
        },
        Ralat(e) -> {
            cetak("Ralat: ");
            cetak(e);
            cetak("\n");
        },
    }

    /// Baca pembolehubah alam sekitar
    padan baca_alam_sekitar("PATH") {
        Ada(path) -> {
            cetak("PATH dijumpai\n");
        },
        Tidak -> {
            cetak("PATH tidak dijumpai\n");
        },
    }

    cetak("Selesai\n");
    pulang 0;
}

/// GRAMMAR NOTE: kesan Baca indicates input operations.
/// Side effect tracked in type system.
/// Functions with Baca cannot be called from pure contexts.
/// Order of Baca effects matters.

// === 07_EXAMPLES/02_effects/io_write.rii ===
/// IO_WRITE.RII - Writing Output Operations
/// Operasi menulis output
/// Demonstrates: Tulis effect, output operations, buffering

fungsi tulis_teks(t: Teks) -> Nombor kesan Tulis {
    /// Tulis teks ke stdout
    cetak(t);
    0
}

fungsi tulis_garisan(t: Teks) -> Nombor kesan Tulis {
    /// Tulis garisan ke stdout
    cetak(t);
    cetak("\n");
    0
}

fungsi tulis_ke_fail(nama_fail: Teks, kandungan: Teks) -> Hasil<Nombor, Teks> kesan Tulis {
    /// Tulis kandungan ke fail
    padan buka_fail_untuk_tulis(nama_fail) {
        Ok(fail) -> {
            tulis_ke_fail_handle(fail, kandungan);
            tutup_fail(fail);
            Ok(0)
        },
        Ralat(e) -> Ralat("Tidak dapat buka fail untuk tulis: {e}"),
    }
}

fungsi sambung_ke_fail(nama_fail: Teks, kandungan: Teks) -> Hasil<Nombor, Teks> kesan Tulis {
    /// Sambung kandungan ke fail sedia ada
    padan buka_fail_untuk_sambung(nama_fail) {
        Ok(fail) -> {
            tulis_ke_fail_handle(fail, kandungan);
            tutup_fail(fail);
            Ok(0)
        },
        Ralat(e) -> Ralat("Tidak dapat buka fail: {e}"),
    }
}

fungsi tulis_json_ke_fail(nama_fail: Teks, json: Teks) -> Hasil<Nombor, Teks> kesan Tulis {
    /// Tulis JSON ke fail
    padan tulis_ke_fail(nama_fail, json) {
        Ok(_) -> Ok(0),
        Ralat(e) -> Ralat("Tidak dapat tulis JSON: {e}"),
    }
}

fungsi tulis_log(
    tahap: Teks,
    mesej: Teks
) -> Nombor kesan (Tulis, Masa) {
    /// Tulis ke log dengan tahap
    biar masa = ambil_waktu_kini();
    biar format = "[{tahap}] {masa}: {mesej}\n";
    cetak(format);
    0
}

fungsi tulis_maklumat(m: Teks) -> Nombor kesan Tulis {
    tulis_log("INFO", m)
}

fungsi tulis_amaran(m: Teks) -> Nombor kesan Tulis {
    tulis_log("AMARAN", m)
}

fungsi tulis_ralat(m: Teks) -> Nombor kesan Tulis {
    tulis_log("RALAT", m)
}

fungsi tulis_ayat(
    nama_fail: Teks,
    garisan_garisan: Senarai<Teks>
) -> Hasil<Nombor, Teks> kesan Tulis {
    /// Tulis beberapa garisan ke fail
    padan buka_fail_untuk_tulis(nama_fail) {
        Ok(fail) -> {
            untuk garisan dalam garisan_garisan {
                tulis_ke_fail_handle(fail, garisan);
                tulis_ke_fail_handle(fail, "\n");
            }

            tutup_fail(fail);
            Ok(garisan_garisan.panjang())
        },
        Ralat(e) -> Ralat("Tidak dapat buka fail"),
    }
}

fungsi tulis_dengan_buffer(
    nama_fail: Teks,
    f: Fn() -> Teks
) -> Hasil<Nombor, Teks> kesan Tulis {
    /// Tulis dengan buffer
    padan buka_fail_untuk_tulis(nama_fail) {
        Ok(fail) -> {
            biar kandungan = f();
            tulis_ke_fail_handle(fail, kandungan);
            tutup_fail(fail);
            Ok(0)
        },
        Ralat(e) -> Ralat("Fail gagal"),
    }
}

fungsi tulis_csv(
    nama_fail: Teks,
    data: Senarai<(Teks, Teks, Nombor)>
) -> Hasil<Nombor, Teks> kesan Tulis {
    /// Tulis data CSV
    padan buka_fail_untuk_tulis(nama_fail) {
        Ok(fail) -> {
            untuk (a, b, c) dalam data {
                biar baris = "{a},{b},{c}\n";
                tulis_ke_fail_handle(fail, baris);
            }

            tutup_fail(fail);
            Ok(data.panjang())
        },
        Ralat(e) -> Ralat("Fail gagal"),
    }
}

fungsi utama() -> Nombor kesan Tulis {
    cetak("=== Operasi Tulis ===\n");

    /// Tulis teks
    tulis_teks("Hello");
    tulis_garisan(" World");

    /// Tulis maklumat
    tulis_maklumat("Aplikasi dimulai");
    tulis_amaran("Ini adalah amaran");
    tulis_ralat("Ini adalah ralat");

    /// Tulis ke fail
    padan tulis_ke_fail("output.txt", "Kandungan fail test") {
        Ok(_) -> cetak("Fail ditulis berjaya\n"),
        Ralat(e) -> cetak("Ralat: "),
    }

    cetak("Selesai\n");
    pulang 0;
}

/// GRAMMAR NOTE: kesan Tulis indicates output operations.
/// Effect tracked in type system.
/// Functions with Tulis can call other Tulis or Bersih functions.
/// Cannot be called from pure contexts.

// === 07_EXAMPLES/02_effects/network.rii ===
/// NETWORK.RII - Network Operations
/// Operasi rangkaian
/// Demonstrates: Rangkaian effect, HTTP, sockets

fungsi buat_sambungan_http(url: Teks) -> Hasil<Teks, Teks> kesan Rangkaian {
    /// Buat sambungan HTTP dan dapatkan tindakbalas
    /// Simulasi - dalam praktik akan gunakan HTTP library
    Ok("respons_dari_server")
}

fungsi hantar_permintaan_get(url: Teks) -> Hasil<Teks, Teks> kesan Rangkaian {
    /// Hantar permintaan GET
    buat_sambungan_http(url)
}

fungsi hantar_permintaan_post(
    url: Teks,
    badan: Teks
) -> Hasil<Teks, Teks> kesan Rangkaian {
    /// Hantar permintaan POST
    Ok("respons_post")
}

fungsi ambil_kepala_http(url: Teks) -> Hasil<Teks, Teks> kesan Rangkaian {
    /// Ambil kepala HTTP dari URL
    Ok("200 OK")
}

fungsi sambung_ke_pelayan(
    pelayan: Teks,
    port: Nombor
) -> Hasil<Teks, Teks> kesan Rangkaian {
    /// Sambung ke pelayan menggunakan socket
    Ok("sambungan_dibuka")
}

fungsi hantar_paket(
    sambungan: Teks,
    data: Teks
) -> Hasil<Nombor, Teks> kesan Rangkaian {
    /// Hantar paket melalui sambungan
    Ok(data.panjang())
}

fungsi terima_paket(
    sambungan: Teks
) -> Hasil<Teks, Teks> kesan Rangkaian {
    /// Terima paket dari sambungan
    Ok("data_dari_pelayan")
}

fungsi tutup_sambungan(
    sambungan: Teks
) -> Hasil<Nombor, Teks> kesan Rangkaian {
    /// Tutup sambungan
    Ok(0)
}

fungsi permintaan_dns(nama_hos: Teks) -> Hasil<Teks, Teks> kesan Rangkaian {
    /// Lakukan permintaan DNS
    Ok("192.168.1.1")
}

fungsi unduh_fail(
    url: Teks,
    nama_fail_tujuan: Teks
) -> Hasil<Nombor, Teks> kesan (Rangkaian, Tulis) {
    /// Unduh fail dari URL
    padan hantar_permintaan_get(url) {
        Ok(kandungan) -> {
            padan tulis_ke_fail(nama_fail_tujuan, kandungan) {
                Ok(_) -> Ok(0),
                Ralat(e) -> Ralat("Tulis gagal"),
            }
        },
        Ralat(e) -> Ralat("Unduh gagal"),
    }
}

fungsi muat_naik_fail(
    url: Teks,
    nama_fail: Teks
) -> Hasil<Teks, Teks> kesan (Rangkaian, Baca) {
    /// Muat naik fail ke URL
    padan baca_fail_sepenuhnya(nama_fail) {
        Ok(kandungan) -> {
            hantar_permintaan_post(url, kandungan)
        },
        Ralat(e) -> Ralat("Baca fail gagal"),
    }
}

fungsi utama() -> Nombor kesan (Rangkaian, Tulis) {
    cetak("=== Operasi Rangkaian ===\n");

    /// Dapatkan perkhidmatan dari HTTP
    padan hantar_permintaan_get("http://example.com") {
        Ok(respons) -> {
            cetak("Respons: ");
            cetak(respons);
            cetak("\n");
        },
        Ralat(e) -> cetak("Ralat\n"),
    }

    /// Lakukan permintaan DNS
    padan permintaan_dns("example.com") {
        Ok(ip) -> {
            cetak("IP: ");
            cetak(ip);
            cetak("\n");
        },
        Ralat(e) -> cetak("Ralat DNS\n"),
    }

    /// Sambung ke pelayan
    padan sambung_ke_pelayan("localhost", 8080) {
        Ok(conn) -> {
            cetak("Sambungan dibuka\n");

            /// Hantar data
            padan hantar_paket(conn, "hello") {
                Ok(_) -> cetak("Data dihantar\n"),
                Ralat(e) -> cetak("Hantar gagal\n"),
            }

            /// Tutup sambungan
            padan tutup_sambungan(conn) {
                Ok(_) -> cetak("Sambungan ditutup\n"),
                Ralat(e) -> cetak("Tutup gagal\n"),
            }
        },
        Ralat(e) -> cetak("Sambung gagal\n"),
    }

    cetak("Selesai\n");
    pulang 0;
}

/// GRAMMAR NOTE: kesan Rangkaian for network operations.
/// May fail due to network conditions.
/// Order matters for protocol correctness.

// === 07_EXAMPLES/02_effects/perform_custom.rii ===
/// PERFORM_CUSTOM.RII - Custom Effect Operations
/// Kesan khusus dan operasi laku (perform)
/// Demonstrates: custom effects, effect interpretation

jenis Kesan_Bersesuaian {
    TulisBersesuaian(Teks),
    BacaBersesuaian(Teks),
    Selesai,
}

fungsi buat_kesan_bersesuaian(operasi: Kesan_Bersesuaian) -> Nombor kesan Bersih {
    /// Buat kesan bersesuaian
    padan operasi {
        Kesan_Bersesuaian.TulisBersesuaian(msg) -> {
            cetak("Tulis Bersesuaian: ");
            cetak(msg);
            cetak("\n");
            0
        },
        Kesan_Bersesuaian.BacaBersesuaian(nama) -> {
            cetak("Baca Bersesuaian: ");
            cetak(nama);
            cetak("\n");
            0
        },
        Kesan_Bersesuaian.Selesai -> {
            cetak("Selesai\n");
            0
        },
    }
}

fungsi laku_kesan_bersesuaian(
    kesan: Kesan_Bersesuaian
) -> Hasil<Nombor, Teks> kesan Bersih {
    /// Laku kesan bersesuaian
    Ok(buat_kesan_bersesuaian(kesan))
}

jenis LogLevel {
    Debug,
    Info,
    Amaran,
    Ralat,
}

fungsi log_bersesuaian(
    tahap: LogLevel,
    mesej: Teks
) -> Nombor kesan Tulis {
    /// Log dengan tahap bersesuaian
    biar prefix = padan tahap {
        LogLevel.Debug -> "[DEBUG]",
        LogLevel.Info -> "[INFO]",
        LogLevel.Amaran -> "[AMARAN]",
        LogLevel.Ralat -> "[RALAT]",
    };

    cetak(prefix);
    cetak(" ");
    cetak(mesej);
    cetak("\n");

    0
}

fungsi tangani_kesan_bersesuaian<T>(
    f: Fn() -> T
) -> T kesan Bersih {
    /// Tangani kesan bersesuaian
    f()
}

fungsi utama() -> Nombor kesan Tulis {
    cetak("=== Kesan Bersesuaian ===\n");

    /// Laku kesan bersesuaian tulis
    padan laku_kesan_bersesuaian(Kesan_Bersesuaian.TulisBersesuaian("Mesej khusus")) {
        Ok(_) -> cetak("Laku berjaya\n"),
        Ralat(e) -> cetak("Ralat\n"),
    }

    /// Log bersesuaian dengan pelbagai tahap
    log_bersesuaian(LogLevel.Debug, "Maklumat debug");
    log_bersesuaian(LogLevel.Info, "Maklumat umum");
    log_bersesuaian(LogLevel.Amaran, "Ini adalah amaran");
    log_bersesuaian(LogLevel.Ralat, "Ini adalah ralat");

    cetak("Selesai\n");
    pulang 0;
}

/// SECURITY NOTE: Custom effects enable domain-specific abstractions.
/// Type system tracks custom effects like builtin effects.

// === 07_EXAMPLES/02_effects/pure_functions.rii ===
/// PURE_FUNCTIONS.RII - Pure Function Semantics
/// Fungsi tulen tanpa kesan samping
/// Demonstrates: Bersih effect, referential transparency, pure computation

fungsi tambah_dua(x: Nombor) -> Nombor kesan Bersih {
    /// Fungsi tulen - tanpa kesan samping
    /// Pure function - no side effects
    pulang x + 2;
}

fungsi gandakan(x: Nombor) -> Nombor kesan Bersih {
    /// Fungsi tulen
    x * 2
}

fungsi kuadrat(x: Nombor) -> Nombor kesan Bersih {
    x * x
}

fungsi ubah_ke_teks(x: Nombor) -> Teks kesan Bersih {
    /// Tulen - tiada I/O
    "nilai_{x}"
}

fungsi jumlah_senarai(s: Senarai<Nombor>) -> Nombor kesan Bersih {
    /// Tulen - pengiraan sahaja
    s.lipat(0, fungsi(a: Nombor, b: Nombor) -> Nombor {
        a + b
    })
}

fungsi panjang_min(s1: Senarai<Teks>, s2: Senarai<Teks>) -> Nombor kesan Bersih {
    /// Tulen - perbandingan sahaja
    biar p1 = s1.panjang();
    biar p2 = s2.panjang();
    kalau p1 < p2 { p1 } lain { p2 }
}

fungsi gabung_teks_tulen(
    a: Teks,
    b: Teks,
    c: Teks
) -> Teks kesan Bersih {
    /// Tulen - tiada ketergantungan eksternal
    a + " " + b + " " + c
}

fungsi kamposan(
    f: Fn(Nombor) -> Nombor,
    g: Fn(Nombor) -> Nombor
) -> Fn(Nombor) -> Nombor kesan Bersih {
    /// Komposisi tulen
    fungsi hasil(x: Nombor) -> Nombor {
        f(g(x))
    }

    hasil
}

fungsi cari_maksimum(s: Senarai<Nombor>) -> Mungkin<Nombor> kesan Bersih {
    /// Cari maksimum - tulen
    kalau s.panjang() == 0 {
        Tidak
    } lain {
        Ada(s.lipat(s[0], fungsi(max: Nombor, x: Nombor) -> Nombor {
            kalau x > max { x } lain { max }
        }))
    }
}

fungsi susun_gelombang(s: Senarai<Nombor>) -> Senarai<Nombor> kesan Bersih {
    /// Susun - tulen
    s.tapis(fungsi(x: Nombor) -> Benar {
        betul  /// Placeholder
    })
}

fungsi sah_emel_tulen(e: Teks) -> Benar kesan Bersih {
    /// Validasi emel - tulen
    e.ada("@") && e.ada(".")
}

fungsi utama() -> Nombor kesan Tulis {
    cetak("=== Fungsi Tulen ===\n");

    /// Panggil fungsi tulen
    biar hasil1 = tambah_dua(5);
    cetak("5 + 2 = ");
    cetak(hasil1);
    cetak("\n");

    /// Jumlah senarai
    biar s = [1, 2, 3, 4, 5];
    biar jumlah = jumlah_senarai(s);
    cetak("Jumlah: ");
    cetak(jumlah);
    cetak("\n");

    /// Komposisi
    biar komposit = kamposan(gandakan, kuadrat);
    biar hasil2 = komposit(3);  /// 3^2 = 9, 9*2 = 18
    cetak("Komposisi: ");
    cetak(hasil2);
    cetak("\n");

    /// Cari maksimum
    padan cari_maksimum(s) {
        Ada(max) -> {
            cetak("Maksimum: ");
            cetak(max);
            cetak("\n");
        },
        Tidak -> cetak("Senarai kosong\n"),
    }

    cetak("Semua tulen\n");
    pulang 0;
}

/// GRAMMAR NOTE: kesan Bersih indicates pure functions.
/// Compiler guarantees no side effects.
/// Same input always produces same output.
/// Enables aggressive optimization and memoization.

// === 07_EXAMPLES/02_effects/pure_io_boundary.rii ===
/// PURE_IO_BOUNDARY.RII - Pure/IO Boundary Management
/// Sempadan antara fungsi tulen dan I/O
/// Demonstrates: maintaining purity, IO at periphery, functional core

/// Tulen - core logic
fungsi kiira_gaji(
    gaji_asas: Nombor,
    jam_lebih_waktu: Nombor
) -> Nombor {
    biar gaji_biasa = gaji_asas;
    biar gaji_lebih = jam_lebih_waktu * 50;
    gaji_biasa + gaji_lebih
}

/// Tulen - core logic
fungsi sahkan_emel(e: Teks) -> Benar {
    e.ada("@") && e.ada(".")
}

/// Tulen - core logic
fungsi wajar_kredit(skor: Nombor) -> Benar {
    skor >= 700
}

/// I/O wrapper - ambil input dan panggil logic tulen
fungsi ambil_gaji_dari_pengguna() -> Hasil<Nombor, Teks> kesan (Tulis, Baca) {
    cetak("Masukkan gaji asas: ");
    padan baca_nombor_dari_pengguna() {
        Ok(gaji) -> {
            cetak("Masukkan jam lebih waktu: ");
            padan baca_nombor_dari_pengguna() {
                Ok(lebih) -> {
                    /// Panggil tulen logic
                    Ok(kiira_gaji(gaji, lebih))
                },
                Ralat(e) -> Ralat(e),
            }
        },
        Ralat(e) -> Ralat(e),
    }
}

/// I/O wrapper - ambil emel dan validasi
fungsi ambil_emel_terpilih() -> Hasil<Benar, Teks> kesan (Tulis, Baca) {
    cetak("Masukkan emel: ");
    biar e = baca_garisan();

    /// Panggil tulen logic
    Ok(sahkan_emel(e))
}

/// I/O wrapper - ambil skor dan periksa kelayakan
fungsi periksa_kelayakan_kredit() -> Hasil<Benar, Teks> kesan (Tulis, Baca) {
    cetak("Masukkan skor kredit: ");
    padan baca_nombor_dari_pengguna() {
        Ok(skor) -> {
            /// Panggil tulen logic
            Ok(wajar_kredit(skor))
        },
        Ralat(e) -> Ralat(e),
    }
}

/// Wrapper yang menggabungkan tulen dan I/O
fungsi proses_permohonan_gaji() -> Hasil<Nombor, Teks> kesan (Tulis, Baca) {
    cetak("=== Permohonan Gaji ===\n");

    padan ambil_gaji_dari_pengguna() {
        Ok(gaji) -> {
            cetak("Gaji dikira: ");
            cetak(gaji);
            cetak("\n");
            Ok(gaji)
        },
        Ralat(e) -> Ralat(e),
    }
}

/// Wrapper gabungan dengan pelbagai validasi
fungsi proses_permohonan_lengkap() -> Hasil<Benar, Teks> kesan (Tulis, Baca) {
    cetak("=== Permohonan Lengkap ===\n");

    /// Validasi emel
    padan ambil_emel_terpilih() {
        Ok(emel_sah) kalau emel_sah -> {
            cetak("Emel sah\n");

            /// Periksa kredit
            padan periksa_kelayakan_kredit() {
                Ok(wajar) -> {
                    kalau wajar {
                        cetak("Kelayakan: LAYAK\n");
                        Ok(betul)
                    } lain {
                        cetak("Kelayakan: TIDAK LAYAK\n");
                        Ok(salah)
                    }
                },
                Ralat(e) -> Ralat(e),
            }
        },
        Ok(_) -> {
            cetak("Emel tidak sah\n");
            Ok(salah)
        },
        Ralat(e) -> Ralat(e),
    }
}

fungsi utama() -> Nombor kesan (Tulis, Baca) {
    cetak("=== Sempadan Tulen/I/O ===\n");

    padan proses_permohonan_gaji() {
        Ok(gaji) -> {
            cetak("Diproses: ");
            cetak(gaji);
            cetak("\n");
        },
        Ralat(e) -> cetak("Ralat\n"),
    }

    padan proses_permohonan_lengkap() {
        Ok(_) -> cetak("Permohonan lengkap\n"),
        Ralat(e) -> cetak("Ralat\n"),
    }

    cetak("Selesai\n");
    pulang 0;
}

/// ARCHITECTURE NOTE: Pure functions at core, I/O at periphery.
/// Makes functions testable and composable.
/// Separates logic from side effects clearly.
/// Type system enforces this separation.

// === 07_EXAMPLES/02_effects/random.rii ===
/// RANDOM.RII - Random Number Generation
/// Penjenayaan nombor rawak
/// Demonstrates: Rawak effect, randomness, seeding

fungsi rawak_nombor(had_min: Nombor, had_maks: Nombor) -> Nombor kesan Rawak {
    /// Hasilkan nombor rawak antara had_min dan had_maks
    /// Simulasi
    had_min
}

fungsi rawak_boolean() -> Benar kesan Rawak {
    /// Hasilkan boolean rawak
    betul
}

fungsi rawak_pilih<T>(senarai: Senarai<T>) -> Mungkin<T> kesan Rawak {
    /// Pilih elemen rawak dari senarai
    kalau senarai.panjang() == 0 {
        Tidak
    } lain {
        biar indeks = rawak_nombor(0, senarai.panjang() - 1);
        Ada(senarai[indeks])
    }
}

fungsi rawak_gocoh<T>(ubah senarai: Senarai<T>) -> Senarai<T> kesan Rawak {
    /// Gocoh (shuffle) senarai
    /// Simulasi - dalam praktik gunakan Fisher-Yates
    senarai
}

fungsi rawak_sampel<T>(
    senarai: Senarai<T>,
    saiz: Nombor
) -> Senarai<T> kesan Rawak {
    /// Ambil sampel rawak dari senarai
    biar ubah sampel: Senarai<T> = [];
    untuk i dalam 0..saiz {
        padan rawak_pilih(senarai) {
            Ada(item) -> sampel = sampel.tambah(item),
            Tidak -> { },
        }
    }

    sampel
}

fungsi hasilkan_id_rawak(panjang: Nombor) -> Teks kesan Rawak {
    /// Hasilkan ID rawak
    biar ubah id = "";
    untuk i dalam 0..panjang {
        biar aksara_indeks = rawak_nombor(0, 35);
        id = id + "x";
    }

    id
}

fungsi rawak_teks_dari_senarai(senarai: Senarai<Teks>) -> Mungkin<Teks> kesan Rawak {
    /// Pilih teks rawak dari senarai
    rawak_pilih(senarai)
}

fungsi buat_dadu_rawak(bilangan_sisi: Nombor) -> Nombor kesan Rawak {
    /// Buat dadu rawak
    rawak_nombor(1, bilangan_sisi)
}

fungsi simulasi_perlandingan(
    peluang_menang: Nombor
) -> Benar kesan Rawak {
    /// Simulasi pelandingan dengan peluang tertentu
    biar nilai_rawak = rawak_nombor(1, 100);
    nilai_rawak <= peluang_menang
}

fungsi utama() -> Nombor kesan (Rawak, Tulis) {
    cetak("=== Penjenjaran Nombor Rawak ===\n");

    /// Hasilkan nombor rawak
    biar n = rawak_nombor(1, 100);
    cetak("Nombor rawak (1-100): ");
    cetak(n);
    cetak("\n");

    /// Hasilkan boolean rawak
    biar b = rawak_boolean();
    cetak("Boolean rawak: ");
    cetak(b);
    cetak("\n");

    /// Hasilkan ID rawak
    biar id = hasilkan_id_rawak(10);
    cetak("ID rawak: ");
    cetak(id);
    cetak("\n");

    /// Pilih dari senarai
    biar senarai = ["Ahmad", "Siti", "Budi"];
    padan rawak_pilih(senarai) {
        Ada(nama) -> {
            cetak("Nama rawak: ");
            cetak(nama);
            cetak("\n");
        },
        Tidak -> cetak("Senarai kosong\n"),
    }

    /// Buat dadu
    biar dadu = buat_dadu_rawak(6);
    cetak("Dadu (1-6): ");
    cetak(dadu);
    cetak("\n");

    cetak("Selesai\n");
    pulang 0;
}

/// GRAMMAR NOTE: kesan Rawak for random operations.
/// Same function call may return different results.
/// Often used with Kripto for generating keys/nonces.

// === 07_EXAMPLES/02_effects/time_effect.rii ===
/// TIME_EFFECT.RII - Time and Timing Operations
/// Operasi masa dan masa tamat
/// Demonstrates: Masa effect, delays, timing

fungsi ambil_waktu_kini() -> Nombor kesan Masa {
    /// Ambil waktu kini dalam saat (Unix timestamp)
    0  /// Simulasi
}

fungsi tunda(bilangan_milisaat: Nombor) -> Nombor kesan Masa {
    /// Tunggu bilangan milisaat
    0
}

fungsi tunda_saat(bilangan_saat: Nombor) -> Nombor kesan Masa {
    /// Tunggu bilangan saat
    tunda(bilangan_saat * 1000)
}

fungsi cek_masa_tamat(masa_tamat: Nombor) -> Benar kesan Masa {
    /// Periksa sama ada masa tamat telah berlalu
    biar waktu_kini = ambil_waktu_kini();
    waktu_kini >= masa_tamat
}

fungsi hitung_masa_berlalu(waktu_mula: Nombor) -> Nombor kesan Masa {
    /// Hitung waktu berlalu sejak waktu_mula
    biar waktu_kini = ambil_waktu_kini();
    waktu_kini - waktu_mula
}

fungsi jalankan_dengan_masa_tamat<T>(
    f: Fn() -> T,
    masa_tamat_milisaat: Nombor
) -> Hasil<T, Teks> kesan Masa {
    /// Jalankan fungsi dengan masa tamat
    biar mula = ambil_waktu_kini();
    biar hasil = f();
    biar berlalu = hitung_masa_berlalu(mula);

    kalau berlalu <= masa_tamat_milisaat {
        Ok(hasil)
    } lain {
        Ralat("Masa tamat")
    }
}

fungsi ulang_dengan_selang(
    f: Fn() -> Nombor,
    selang_milisaat: Nombor
) -> Hasil<Nombor, Teks> kesan (Masa, Tulis) {
    /// Ulang fungsi dengan selang
    biar ubah kiraan = 0;

    ulang {
        f();
        kiraan = kiraan + 1;

        kalau kiraan >= 5 {
            putus;
        }

        tunda(selang_milisaat);
    }

    Ok(kiraan)
}

fungsi penepat_waktu(nama: Teks, f: Fn() -> Nombor) -> Hasil<Nombor, Teks> kesan (Masa, Tulis) {
    /// Jalankan fungsi dan catat waktu yang diambil
    cetak("Memulai ");
    cetak(nama);
    cetak("...\n");

    biar mula = ambil_waktu_kini();
    f();
    biar berlalu = hitung_masa_berlalu(mula);

    cetak("Selesai dalam ");
    cetak(berlalu);
    cetak(" milisaat\n");

    Ok(berlalu)
}

fungsi tunggu_sehingga_keadaan(
    keadaan: Fn() -> Benar,
    masa_tamat_saat: Nombor
) -> Hasil<Benar, Teks> kesan Masa {
    /// Tunggu sehingga keadaan dipenuhi
    biar mula = ambil_waktu_kini();
    biar masa_tamat = mula + (masa_tamat_saat * 1000);

    ulang {
        kalau keadaan() {
            pulang Ok(betul);
        }

        kalau cek_masa_tamat(masa_tamat) {
            pulang Ralat("Masa tamat");
        }

        tunda(100);
    }
}

fungsi utama() -> Nombor kesan (Masa, Tulis) {
    cetak("=== Operasi Masa ===\n");

    /// Ambil waktu kini
    biar waktu = ambil_waktu_kini();
    cetak("Waktu kini: ");
    cetak(waktu);
    cetak(" saat\n");

    /// Tunda
    cetak("Menunggu 2 saat...\n");
    tunda_saat(2);
    cetak("Selesai menunggu\n");

    /// Penepat waktu
    biar ubah ujian = fungsi() -> Nombor {
        tunda_saat(1);
        pulang 0;
    };

    padan penepat_waktu("ujian", ujian) {
        Ok(ms) -> {
            cetak("Ujian mengambil ");
            cetak(ms);
            cetak(" milisaat\n");
        },
        Ralat(e) -> cetak("Ralat\n"),
    }

    cetak("Selesai\n");
    pulang 0;
}

/// GRAMMAR NOTE: kesan Masa for time-sensitive operations.
/// May have side effects on execution timing.
/// Important for real-time applications.

// === 07_EXAMPLES/03_applications/api_gateway.rii ===
/// api_gateway.rii
/// API Gateway with authentication and request routing
/// Demonstrates Rangkaian + Kripto effects for secure API access
///
/// Features:
/// - Authentication token validation
/// - Request routing based on path
/// - Rate limiting per token
/// - Cryptographic signature verification

modul pintu_api;

guna std::rangkaian;
guna std::kripto;
guna std::teks;
guna std::senarai;

/// API token with authentication metadata
jenis Token = {
    nilai: Teks,
    pengguna: Teks,
    kelulusan: Senarai<Teks>,
    masa_tamat: Nombor,
};

jenis PermintaanAPI = {
    token: Teks,
    kaedah: Teks,
    laluan: Teks,
    tubuh: Teks,
    tandatangan: Teks,
};

jenis BalasanAPI = {
    kod: Nombor,
    jasad: Teks,
    tandatangan: Teks,
};

/// Validate token cryptographically
/// Kesan: Kripto (cryptographic operations)
fungsi sahkan_token(token: Teks, kunci_rahsia: Rahsia<Teks>) -> Mungkin<Token> kesan Kripto {
    // Verify HMAC signature
    biar hasil_hmac = Kripto::sahkan_hmac(token, kunci_rahsia);

    padan hasil_hmac {
        Betul => {
            // Extract token fields (simplified)
            pulang Ada({
                nilai: token,
                pengguna: "pengguna@contoh.my",
                kelulusan: ["baca", "tulis"],
                masa_tamat: 1700000000,
            });
        },
        Salah => {
            pulang Tiada;
        },
    };
}

/// Check if token has required permission
fungsi ada_kelulusan(token: Token, kelulusan_perlu: Teks) -> Benar kesan Bersih {
    untuk perm dalam token.kelulusan {
        kalau perm == kelulusan_perlu {
            pulang betul;
        }
    }
    pulang salah;
}

/// Route to appropriate service
/// Kesan: Rangkaian (for calling downstream services)
fungsi laluan_permintaan(
    permintaan: PermintaanAPI,
    token: Token
) -> Mungkin<Teks> kesan Rangkaian {
    kalau permintaan.laluan == "/pengguna/profil" {
        kalau ada_kelulusan(token, "baca") {
            pulang Ada("{\"nama\":\"Ahmad\",\"negara\":\"Malaysia\"}");
        } lain {
            pulang Tiada;
        }
    } lain kalau permintaan.laluan == "/pengguna/kemaskini" {
        kalau ada_kelulusan(token, "tulis") {
            pulang Ada("{\"berjaya\":true}");
        } lain {
            pulang Tiada;
        }
    } lain kalau permintaan.laluan == "/produk/senarai" {
        // Retrieve from upstream service
        biar respons = Rangkaian::get_api("http://perkhidmatan-produk:3000/senarai");
        pulang Ada(respons);
    } lain {
        pulang Tiada;
    };
}

/// Generate response signature
fungsi tandatangani_balasan(
    jasad: Teks,
    kunci_rahsia: Rahsia<Teks>
) -> Teks kesan Kripto {
    pulang Kripto::hmac_sha256(jasad, kunci_rahsia);
}

/// Process API request with full authentication flow
/// Kesan: Rangkaian + Kripto
fungsi proses_permintaan(
    permintaan_mentah: Teks,
    kunci_rahsia: Rahsia<Teks>
) -> BalasanAPI kesan (Rangkaian | Kripto) {
    // Parse raw request
    biar permintaan = huraikan_api(permintaan_mentah);

    // Authenticate token
    biar hasil_token = sahkan_token(permintaan.token, kunci_rahsia);

    padan hasil_token {
        Ada(token) => {
            // Route to appropriate handler
            biar hasil_laluan = laluan_permintaan(permintaan, token);
            padan hasil_laluan {
                Ada(jasad) => {
                    // Sign response
                    biar tandatangan = tandatangani_balasan(jasad, kunci_rahsia);
                    pulang {
                        kod: 200,
                        jasad: jasad,
                        tandatangan: tandatangan,
                    };
                },
                Tiada => {
                    pulang {
                        kod: 403,
                        jasad: "{\"ralat\":\"Akses ditolak\"}",
                        tandatangan: "",
                    };
                },
            };
        },
        Tiada => {
            pulang {
                kod: 401,
                jasad: "{\"ralat\":\"Pengesahan gagal\"}",
                tandatangan: "",
            };
        },
    };
}

/// Main gateway handler
awam fungsi utama_gateway(permintaan: Teks, kunci: Rahsia<Teks>) -> BalasanAPI kesan (Rangkaian | Kripto) {
    proses_permintaan(permintaan, kunci);
}

// Helper functions
fungsi huraikan_api(teks: Teks) -> PermintaanAPI kesan Bersih {
    pulang {
        token: "",
        kaedah: "GET",
        laluan: "/",
        tubuh: "",
        tandatangan: "",
    };
}

// === 07_EXAMPLES/03_applications/calculator.rii ===
/// calculator.rii
/// Scientific calculator with pattern matching
/// Demonstrates pure computation and algebraic data types
///
/// Features:
/// - Expression evaluation
/// - Pattern matching for operations
/// - Error handling with algebraic types

modul kalkulator;

guna std::teks;
guna std::senarai;

jenis Operasi =
    | Tambah
    | Tolak
    | Darab
    | Bahagi
    | Kuasa
    | Modulo;

jenis Ungkapan =
    | Nombor(Nombor)
    | BinariOp { operasi: Operasi, kiri: Ungkapan, kanan: Ungkapan }
    | Fungsi { nama: Teks, arg: Ungkapan };

/// Parse infix expression string
/// "3 + 4 * 5" -> BinariOp(+, 3, BinariOp(*, 4, 5))
fungsi huraikan_ungkapan(teks: Teks) -> Mungkin<Ungkapan> kesan Bersih {
    biar token = tokenisasi(teks);
    biar hasil = parse_token(token, 0);

    padan hasil {
        Ada((ungkapan, _)) => Ada(ungkapan),
        Tiada => Tiada,
    };
}

/// Tokenize expression string
fungsi tokenisasi(teks: Teks) -> Senarai<Teks> kesan Bersih {
    biar token = [];
    biar kata_semasa = "";

    untuk aksara dalam teks::ke_senarai(teks) {
        kalau aksara == " " {
            kalau kata_semasa != "" {
                token = token + [kata_semasa];
                kata_semasa = "";
            }
        } lain kalau aksara == "+" {
            kalau kata_semasa != "" {
                token = token + [kata_semasa];
                kata_semasa = "";
            }
            token = token + ["+"];
        } lain kalau aksara == "-" {
            kalau kata_semasa != "" {
                token = token + [kata_semasa];
                kata_semasa = "";
            }
            token = token + ["-"];
        } lain kalau aksara == "*" {
            kalau kata_semasa != "" {
                token = token + [kata_semasa];
                kata_semasa = "";
            }
            token = token + ["*"];
        } lain kalau aksara == "/" {
            kalau kata_semasa != "" {
                token = token + [kata_semasa];
                kata_semasa = "";
            }
            token = token + ["/"];
        } lain {
            kata_semasa = kata_semasa + aksara;
        }
    }

    kalau kata_semasa != "" {
        token = token + [kata_semasa];
    }

    pulang token;
}

/// Parse tokens into expression tree (simplified)
fungsi parse_token(token: Senarai<Teks>, indeks: Nombor) -> Mungkin<(Ungkapan, Nombor)> kesan Bersih {
    kalau indeks >= panjang_senarai(token) {
        pulang Tiada;
    }

    biar tok_semasa = token[indeks];
    biar hasil_prim = parse_utama(tok_semasa);

    padan hasil_prim {
        Ada(ungkapan) => Ada((ungkapan, indeks + 1)),
        Tiada => Tiada,
    };
}

/// Parse primary (number or function)
fungsi parse_utama(tok: Teks) -> Mungkin<Ungkapan> kesan Bersih {
    // Try to parse as number
    biar mungkin_nom = teks::ke_nombor(tok);
    padan mungkin_nom {
        Ada(nom) => pulang Ada(Nombor(nom)),
        Tiada => {
            // Could be function name
            kalau tok == "punca" {
                pulang Ada(Fungsi { nama: "punca", arg: Nombor(0) });
            } lain kalau tok == "sin" {
                pulang Ada(Fungsi { nama: "sin", arg: Nombor(0) });
            } lain kalau tok == "cos" {
                pulang Ada(Fungsi { nama: "cos", arg: Nombor(0) });
            } lain {
                pulang Tiada;
            }
        },
    };
}

/// Evaluate expression tree
fungsi nilai(ungkapan: Ungkapan) -> Mungkin<Nombor> kesan Bersih {
    padan ungkapan {
        Nombor(n) => Ada(n),
        BinariOp { operasi: op, kiri: kiri, kanan: kanan } => {
            biar nilai_kiri = nilai(kiri);
            biar nilai_kanan = nilai(kanan);

            padan (nilai_kiri, nilai_kanan) {
                (Ada(nk), Ada(nn)) => {
                    pulang hitung_binari(op, nk, nn);
                },
                _ => Tiada,
            };
        },
        Fungsi { nama: nm, arg: arg } => {
            biar nilai_arg = nilai(arg);
            padan nilai_arg {
                Ada(n) => hitung_fungsi(nm, n),
                Tiada => Tiada,
            };
        },
    };
}

/// Binary operation calculation
fungsi hitung_binari(op: Operasi, kiri: Nombor, kanan: Nombor) -> Mungkin<Nombor> kesan Bersih {
    padan op {
        Tambah => Ada(kiri + kanan),
        Tolak => Ada(kiri - kanan),
        Darab => Ada(kiri * kanan),
        Bahagi => {
            kalau kanan == 0 {
                Tiada
            } lain {
                Ada(kiri / kanan)
            }
        },
        Kuasa => Ada(kiri ^ kanan),
        Modulo => {
            kalau kanan == 0 {
                Tiada
            } lain {
                Ada(kiri % kanan)
            }
        },
    };
}

/// Mathematical function evaluation
fungsi hitung_fungsi(nama: Teks, nilai: Nombor) -> Mungkin<Nombor> kesan Bersih {
    padan nama {
        "punca" => {
            kalau nilai < 0 {
                Tiada
            } lain {
                Ada(math_sqrt(nilai))
            }
        },
        "sin" => Ada(math_sin(nilai)),
        "cos" => Ada(math_cos(nilai)),
        "tan" => Ada(math_tan(nilai)),
        "ln" => {
            kalau nilai <= 0 {
                Tiada
            } lain {
                Ada(math_ln(nilai))
            }
        },
        "log" => {
            kalau nilai <= 0 {
                Tiada
            } lain {
                Ada(math_log10(nilai))
            }
        },
        _ => Tiada,
    };
}

/// Main calculator REPL
awam fungsi utama() -> kesan Tulis {
    cetak_baris("=== KALKULATOR SAINTIFIK ===");
    cetak_baris("Operasi: + - * / ^ %");
    cetak_baris("Fungsi: punca sin cos tan ln log");

    ulang {
        cetak_baris("\nMasukkan ungkapan (atau 'keluar'):");
        biar input = baca_baris();

        kalau input == "keluar" {
            ulang_akhir;
        }

        biar mungkin_ungkapan = huraikan_ungkapan(input);
        padan mungkin_ungkapan {
            Ada(ungkapan) => {
                biar mungkin_hasil = nilai(ungkapan);
                padan mungkin_hasil {
                    Ada(hasil) => {
                        cetak_baris(format!("Hasil: {}", hasil));
                    },
                    Tiada => {
                        cetak_baris("Ralat: Tidak dapat menghitung");
                    },
                };
            },
            Tiada => {
                cetak_baris("Ralat: Ungkapan tidak sah");
            },
        };
    };
}

// Helper functions
fungsi panjang_senarai(senarai: Senarai<T>) -> Nombor kesan Bersih {
    pulang 0;
}

fungsi baca_baris() -> Teks kesan Tulis {
    pulang "";
}

// Math library stubs
fungsi math_sqrt(n: Nombor) -> Nombor kesan Bersih {
    pulang 0;
}

fungsi math_sin(n: Nombor) -> Nombor kesan Bersih {
    pulang 0;
}

fungsi math_cos(n: Nombor) -> Nombor kesan Bersih {
    pulang 0;
}

fungsi math_tan(n: Nombor) -> Nombor kesan Bersih {
    pulang 0;
}

fungsi math_ln(n: Nombor) -> Nombor kesan Bersih {
    pulang 0;
}

fungsi math_log10(n: Nombor) -> Nombor kesan Bersih {
    pulang 0;
}

// === 07_EXAMPLES/03_applications/chat_app.rii ===
/// chat_app.rii
/// Simple chat application with message routing
/// Demonstrates Rangkaian effect for real-time messaging
///
/// Features:
/// - User connection management
/// - Message broadcasting
/// - Connection lifecycle handling

modul aplikasi_perbualan;

guna std::rangkaian;
guna std::senarai;
guna std::teks;
guna std::masa;

jenis PenggunaPengguna = {
    id: Nombor,
    nama: Teks,
    sambungan: Rangkaian::Socket,
    masa_bersambung: Nombor,
};

jenis Pesanan = {
    pengirim: Teks,
    isi: Teks,
    masa_hantar: Nombor,
    jenis: Teks, // "teks" atau "notifikasi"
};

/// Store of connected users
biar ubah pengguna_bersambung: Senarai<PenggunaPengguna> = [];

/// Broadcast message to all connected users
/// Kesan: Rangkaian (sends to all connections)
fungsi siarkan_pesanan(pesanan: Pesanan) -> kesan Rangkaian {
    biar teks_pesanan = enkod_pesanan(pesanan);

    untuk pengguna dalam pengguna_bersambung {
        laku Rangkaian::tulis(pengguna.sambungan, teks_pesanan);
    }
}

/// Encode message for transmission
fungsi enkod_pesanan(pesanan: Pesanan) -> Teks kesan Bersih {
    biar masa_teks = Masa::format_unix(pesanan.masa_hantar);
    pulang format!(
        "[{}] {}: {}",
        masa_teks,
        pesanan.pengirim,
        pesanan.isi
    );
}

/// Handle incoming message from client
/// Kesan: Rangkaian
fungsi uruskan_pesanan(
    pengguna_id: Nombor,
    data_mentah: Teks
) -> kesan Rangkaian {
    biar masa_sekarang = Masa::masa_unix();
    biar pesanan = {
        pengirim: kari_nama_pengguna(pengguna_id),
        isi: data_mentah,
        masa_hantar: masa_sekarang,
        jenis: "teks",
    };

    siarkan_pesanan(pesanan);
}

/// Register new user connection
/// Kesan: Rangkaian (modified user list)
fungsi daftar_pengguna(
    nama: Teks,
    sambungan: Rangkaian::Socket
) -> Nombor kesan Rangkaian {
    biar id_baru = panjang(pengguna_bersambung) + 1;
    biar masa_sekarang = Masa::masa_unix();

    biar pengguna_baru = {
        id: id_baru,
        nama: nama,
        sambungan: sambungan,
        masa_bersambung: masa_sekarang,
    };

    pengguna_bersambung = pengguna_bersambung + [pengguna_baru];

    // Notify others about new user
    biar pesanan_notif = {
        pengirim: "SISTEM",
        isi: format!("{} telah menyertai perbualan", nama),
        masa_hantar: masa_sekarang,
        jenis: "notifikasi",
    };
    siarkan_pesanan(pesanan_notif);

    pulang id_baru;
}

/// Unregister user connection
fungsi cabut_daftar_pengguna(id_pengguna: Nombor) -> kesan Rangkaian {
    biar nama = kari_nama_pengguna(id_pengguna);
    pengguna_bersambung = saring_pengguna(pengguna_bersambung, id_pengguna);

    // Notify others about user leaving
    biar pesanan_notif = {
        pengirim: "SISTEM",
        isi: format!("{} telah keluar dari perbualan", nama),
        masa_hantar: Masa::masa_unix(),
        jenis: "notifikasi",
    };
    siarkan_pesanan(pesanan_notif);
}

/// Retrieve username for user ID
fungsi kari_nama_pengguna(id: Nombor) -> Teks kesan Bersih {
    untuk pengguna dalam pengguna_bersambung {
        kalau pengguna.id == id {
            pulang pengguna.nama;
        }
    }
    pulang "Pengguna Tidak Diketahui";
}

/// Filter out user from list
fungsi saring_pengguna(senarai: Senarai<PenggunaPengguna>, id_kecuali: Nombor) -> Senarai<PenggunaPengguna> kesan Bersih {
    biar hasil = [];
    untuk pengguna dalam senarai {
        kalau pengguna.id != id_kecuali {
            hasil = hasil + [pengguna];
        }
    }
    pulang hasil;
}

/// Main chat server handler
awam fungsi utama_pelayan(pelabuhan: Nombor) -> kesan Rangkaian {
    biar socket_pelayan = Rangkaian::buat_pelayan("0.0.0.0", pelabuhan);
    cetak_baris(format!("Pemserver perbualan mendengarkan pada port {}", pelabuhan));

    ulang {
        biar hasil_terima = coba Rangkaian::terima_sambungan(socket_pelayan);
        padan hasil_terima {
            Berjaya(sambungan) => {
                // Receive name from client
                biar nama = Rangkaian::baca_teks(sambungan, 256);
                biar id_pengguna = daftar_pengguna(nama, sambungan);

                // Listen for messages
                ulang {
                    biar hasil_baca = coba Rangkaian::baca(sambungan, 1024);
                    padan hasil_baca {
                        Berjaya(data) => {
                            uruskan_pesanan(id_pengguna, data);
                        },
                        Kegagalan(_) => {
                            cabut_daftar_pengguna(id_pengguna);
                            ulang_akhir;
                        },
                    };
                };
            },
            Kegagalan(_) => {
                cetak_baris("Ralat menerima sambungan");
            },
        };
    };
}

// === 07_EXAMPLES/03_applications/config_parser.rii ===
/// config_parser.rii
/// Configuration file parser for TOML/INI-like format
/// Demonstrates parsing, validation, and data structure handling
///
/// Features:
/// - Parse key=value configuration
/// - Section support [section]
/// - Type conversion and validation
/// - Comment handling

modul pengurai_konfigurasi;

guna std::fail;
guna std::teks;
guna std::senarai;

jenis NilaiKonfigurasi =
    | Teks(Teks)
    | Nombor(Nombor)
    | Benar(Benar)
    | Senarai(Senarai<NilaiKonfigurasi>);

jenis Bahagian = {
    nama: Teks,
    kunci_nilai: Senarai<(Teks, NilaiKonfigurasi)>,
};

jenis Konfigurasi = {
    bahagian: Senarai<Bahagian>,
};

/// Load and parse configuration file
/// Kesan: SistemFail (file I/O)
fungsi muat_konfigurasi(laluan: Teks) -> Mungkin<Konfigurasi> kesan SistemFail {
    biar hasil_baca = coba SistemFail::baca_fail(laluan);

    padan hasil_baca {
        Berjaya(kandungan) => {
            biar konfigurasi = huraikan_konfigurasi(kandungan);
            pulang Ada(konfigurasi);
        },
        Kegagalan(_) => {
            pulang Tiada;
        },
    };
}

/// Parse configuration text
fungsi huraikan_konfigurasi(kandungan: Teks) -> Konfigurasi kesan Bersih {
    biar baris_senarai = teks::pecah_oleh(kandungan, "\n");
    biar bahagian_semasa = "umum";
    biar kunci_nilai_semasa = [];
    biar bahagian = [];

    untuk baris dalam baris_senarai {
        biar baris_rapi = teks::rapi(baris);

        // Skip empty and comment lines
        kalau baris_rapi == "" {
            // Skip
        } lain kalau teks::mula_dengan(baris_rapi, "#") {
            // Skip comment
        } lain kalau teks::mula_dengan(baris_rapi, "[") {
            // New section
            kalau panjang(kunci_nilai_semasa) > 0 {
                bahagian = bahagian + [{
                    nama: bahagian_semasa,
                    kunci_nilai: kunci_nilai_semasa,
                }];
                kunci_nilai_semasa = [];
            }

            biar nama_bahagian = ekstrak_nama_bahagian(baris_rapi);
            bahagian_semasa = nama_bahagian;
        } lain {
            // Key=value line
            biar hasil_parse = parse_kunci_nilai(baris_rapi);
            padan hasil_parse {
                Ada((kunci, nilai)) => {
                    kunci_nilai_semasa = kunci_nilai_semasa + [(kunci, nilai)];
                },
                Tiada => {
                    // Skip invalid line
                },
            };
        }
    }

    // Add final section
    kalau panjang(kunci_nilai_semasa) > 0 {
        bahagian = bahagian + [{
            nama: bahagian_semasa,
            kunci_nilai: kunci_nilai_semasa,
        }];
    }

    pulang { bahagian: bahagian };
}

/// Extract section name from "[section]"
fungsi ekstrak_nama_bahagian(baris: Teks) -> Teks kesan Bersih {
    biar tanpa_kiri = teks::buang_prefiks(baris, "[");
    biar tanpa_kanan = teks::buang_sufiks(tanpa_kiri, "]");
    pulang teks::rapi(tanpa_kanan);
}

/// Parse key=value line
fungsi parse_kunci_nilai(baris: Teks) -> Mungkin<(Teks, NilaiKonfigurasi)> kesan Bersih {
    biar bahagian = teks::pecah_oleh(baris, "=");

    kalau panjang(bahagian) != 2 {
        pulang Tiada;
    }

    biar kunci = teks::rapi(bahagian[0]);
    biar nilai_teks = teks::rapi(bahagian[1]);

    biar nilai = parse_nilai(nilai_teks);

    pulang Ada((kunci, nilai));
}

/// Parse value into appropriate type
fungsi parse_nilai(teks: Teks) -> NilaiKonfigurasi kesan Bersih {
    // Try as boolean
    kalau teks == "benar" {
        pulang Benar(betul);
    } lain kalau teks == "salah" {
        pulang Benar(salah);
    }

    // Try as number
    biar mungkin_nombor = teks::ke_nombor(teks);
    padan mungkin_nombor {
        Ada(nom) => pulang Nombor(nom),
        Tiada => {
            // Treat as string (remove quotes if present)
            kalau teks::mula_dengan(teks, "\"") {
                biar tanpa_kiri = teks::buang_prefiks(teks, "\"");
                biar tanpa_kanan = teks::buang_sufiks(tanpa_kiri, "\"");
                pulang Teks(tanpa_kanan);
            } lain {
                pulang Teks(teks);
            }
        },
    };
}

/// Get value from configuration by section and key
fungsi dapat_nilai(
    konfigurasi: Konfigurasi,
    nama_bahagian: Teks,
    kunci: Teks
) -> Mungkin<NilaiKonfigurasi> kesan Bersih {
    untuk bahagian dalam konfigurasi.bahagian {
        kalau bahagian.nama == nama_bahagian {
            untuk (k, v) dalam bahagian.kunci_nilai {
                kalau k == kunci {
                    pulang Ada(v);
                }
            }
        }
    }

    pulang Tiada;
}

/// Get string value with default
fungsi dapat_teks(
    konfigurasi: Konfigurasi,
    bahagian: Teks,
    kunci: Teks,
    lalai: Teks
) -> Teks kesan Bersih {
    biar mungkin_nilai = dapat_nilai(konfigurasi, bahagian, kunci);

    padan mungkin_nilai {
        Ada(Teks(t)) => pulang t,
        Ada(_) => pulang lalai,
        Tiada => pulang lalai,
    };
}

/// Get number value with default
fungsi dapat_nombor(
    konfigurasi: Konfigurasi,
    bahagian: Teks,
    kunci: Teks,
    lalai: Nombor
) -> Nombor kesan Bersih {
    biar mungkin_nilai = dapat_nilai(konfigurasi, bahagian, kunci);

    padan mungkin_nilai {
        Ada(Nombor(n)) => pulang n,
        Ada(_) => pulang lalai,
        Tiada => pulang lalai,
    };
}

/// Main demo
awam fungsi utama() -> kesan SistemFail {
    cetak_baris("Pengurai Konfigurasi RIINA");

    biar hasil_muat = muat_konfigurasi("config.ini");
    padan hasil_muat {
        Ada(config) => {
            cetak_baris("Konfigurasi dimuat berjaya");

            // Example: Get database config
            biar db_host = dapat_teks(config, "pangkalan_data", "hos", "localhost");
            biar db_port = dapat_nombor(config, "pangkalan_data", "pelabuhan", 5432);

            cetak_baris(format!("DB Host: {}", db_host));
            cetak_baris(format!("DB Port: {}", db_port));
        },
        Tiada => {
            cetak_baris("Gagal memuat konfigurasi");
        },
    };
}

// === 07_EXAMPLES/03_applications/data_pipeline.rii ===
/// data_pipeline.rii
/// ETL (Extract-Transform-Load) data pipeline
/// Demonstrates data transformation and effect composition
///
/// Features:
/// - Source data reading
/// - Transformation stages
/// - Filtering and mapping
/// - Result writing

modul saluran_data;

guna std::fail;
guna std::teks;
guna std::senarai;

jenis RekodSumber = {
    id: Nombor,
    nama: Teks,
    umur: Nombor,
    jabatan: Teks,
    gaji: Nombor,
};

jenis RekodTransformasi = {
    id: Nombor,
    nama_huruf_besar: Teks,
    umur: Nombor,
    kategori_jabatan: Teks,
    gaji_tahunan: Nombor,
    gaji_bulanan: Nombor,
};

jenis Saringan =
    | SaringanJabatan(Teks)
    | SaringanGaji(Nombor, Nombor)
    | SaringanUmur(Nombor, Nombor);

/// Stage 1: Extract from source
/// Kesan: SistemFail (reads from file)
fungsi ekstrak_sumber(fail_sumber: Teks) -> Mungkin<Senarai<RekodSumber>> kesan SistemFail {
    biar hasil_baca = coba SistemFail::baca_fail(fail_sumber);

    padan hasil_baca {
        Berjaya(kandungan) => {
            biar rekod = huraikan_csv(kandungan);
            pulang Ada(rekod);
        },
        Kegagalan(_) => {
            pulang Tiada;
        },
    };
}

/// Stage 2: Transform data
fungsi transformasi_rekod(sumber: RekodSumber) -> RekodTransformasi kesan Bersih {
    pulang {
        id: sumber.id,
        nama_huruf_besar: huruf_besar(sumber.nama),
        umur: sumber.umur,
        kategori_jabatan: kategorikan_jabatan(sumber.jabatan),
        gaji_tahunan: sumber.gaji,
        gaji_bulanan: sumber.gaji / 12,
    };
}

/// Stage 3: Filter records
fungsi saringi_rekod(rekod: RekodTransformasi, saringan: Saringan) -> Benar kesan Bersih {
    padan saringan {
        SaringanJabatan(jabatan) => {
            pulang rekod.kategori_jabatan == jabatan;
        },
        SaringanGaji(min, max) => {
            pulang rekod.gaji_tahunan >= min && rekod.gaji_tahunan <= max;
        },
        SaringanUmur(min, max) => {
            pulang rekod.umur >= min && rekod.umur <= max;
        },
    };
}

/// Stage 4: Load results
/// Kesan: SistemFail (writes to file)
fungsi muatkan_hasil(
    fail_keluaran: Teks,
    rekod_transformasi: Senarai<RekodTransformasi>
) -> kesan SistemFail {
    biar csv_keluaran = jana_csv_transformasi(rekod_transformasi);

    biar hasil_tulis = coba SistemFail::tulis_fail(fail_keluaran, csv_keluaran);

    padan hasil_tulis {
        Berjaya(_) => {
            cetak_baris(format!("Hasil ditulis ke {}", fail_keluaran));
        },
        Kegagalan(ralat) => {
            cetak_baris(format!("Gagal menulis hasil: {}", ralat));
        },
    };
}

/// Complete pipeline execution
/// Kesan: SistemFail (composition of I/O operations)
fungsi jalankan_saluran(
    fail_sumber: Teks,
    fail_keluaran: Teks,
    saringan_senarai: Senarai<Saringan>
) -> kesan SistemFail {
    cetak_baris("=== MEMULAKAN SALURAN DATA ===");
    cetak_baris("Tahap 1: Ekstrak");

    // Extract
    biar hasil_ekstrak = ekstrak_sumber(fail_sumber);

    padan hasil_ekstrak {
        Ada(rekod_sumber) => {
            cetak_baris(format!("Diekstrak {} rekod", panjang(rekod_sumber)));

            cetak_baris("Tahap 2: Transformasi");
            // Transform
            biar rekod_transformasi = [];
            untuk rekod dalam rekod_sumber {
                rekod_transformasi = rekod_transformasi + [transformasi_rekod(rekod)];
            }

            cetak_baris("Tahap 3: Saringi");
            // Filter with all conditions
            biar rekod_tersaring = [];
            untuk rekod dalam rekod_transformasi {
                biar tersaring = betul;

                untuk saringan dalam saringan_senarai {
                    kalau !saringi_rekod(rekod, saringan) {
                        tersaring = salah;
                    }
                }

                kalau tersaring {
                    rekod_tersaring = rekod_tersaring + [rekod];
                }
            }

            cetak_baris(format!("Selepas penyaringan: {} rekod", panjang(rekod_tersaring)));

            cetak_baris("Tahap 4: Muatkan");
            // Load
            muatkan_hasil(fail_keluaran, rekod_tersaring);

            cetak_baris("=== SALURAN SELESAI ===");
        },
        Tiada => {
            cetak_baris("Gagal mengekstrak data sumber");
        },
    };
}

/// Example pipeline with multiple stages
awam fungsi utama() -> kesan SistemFail {
    biar saringan = [
        SaringanGaji(30000, 100000),
        SaringanUmur(25, 55),
    ];

    jalankan_saluran(
        "sumber.csv",
        "keluaran_tersaring.csv",
        saringan
    );
}

// Helper functions
fungsi huraikan_csv(kandungan: Teks) -> Senarai<RekodSumber> kesan Bersih {
    pulang [];
}

fungsi jana_csv_transformasi(rekod: Senarai<RekodTransformasi>) -> Teks kesan Bersih {
    pulang "";
}

fungsi huruf_besar(teks: Teks) -> Teks kesan Bersih {
    pulang teks;
}

fungsi kategorikan_jabatan(jabatan: Teks) -> Teks kesan Bersih {
    kalau teks::mengandungi(jabatan, "Manajer") {
        pulang "Pengurusan";
    } lain kalau teks::mengandungi(jabatan, "Jurutera") {
        pulang "Teknikal";
    } lain {
        pulang "Umum";
    }
}

fungsi panjang(senarai: Senarai<T>) -> Nombor kesan Bersih {
    pulang 0;
}

modul teks {
    fungsi mengandungi(teks: Teks, cari: Teks) -> Benar kesan Bersih {
        pulang betul;
    }
}

// === 07_EXAMPLES/03_applications/email_validator.rii ===
/// email_validator.rii
/// Email validation with sanitization and security checks
/// Demonstrates string parsing, pattern matching, and validation
///
/// Features:
/// - RFC 5322 format validation
/// - Domain verification
/// - Sanitization of user input
/// - Disposable email detection

modul pengesah_emel;

guna std::teks;
guna std::senarai;

jenis HasilPengesahan = {
    sah: Benar,
    emel: Teks,
    pengguna: Teks,
    domain: Teks,
    amaran: Senarai<Teks>,
};

jenis JenisDomain =
    | DOMAIN_PERCAYA
    | DOMAIN_SEKALI_PAKAI
    | DOMAIN_TIDAK_DIKETAHUI;

/// Check if character is valid email character
fungsi aksara_sah_emel(c: Teks) -> Benar kesan Bersih {
    pulang betul; // Simplified
}

/// Check if domain looks valid (basic check)
fungsi domain_sah(domain: Teks) -> Benar kesan Bersih {
    kalau panjang(domain) < 4 {
        pulang salah;
    }

    kalau !teks::mengandungi(domain, ".") {
        pulang salah;
    }

    biar bahagian_domain = teks::pecah(domain, ".");
    kalau panjang(bahagian_domain) < 2 {
        pulang salah;
    }

    pulang betul;
}

/// Check for disposable email providers
fungsi cek_domain_sekali_pakai(domain: Teks) -> Benar kesan Bersih {
    biar domain_sekali_pakai = [
        "tempmail.com",
        "throwaway.email",
        "guerrillamail.com",
        "10minutemail.com",
        "mailinator.com",
        "maildrop.cc",
    ];

    untuk domain_sp dalam domain_sekali_pakai {
        kalau domain == domain_sp {
            pulang betul;
        }
    }

    pulang salah;
}

/// Sanitize email input
fungsi sanitasi_emel(emel_mentah: Teks) -> Teks kesan Bersih {
    // Remove leading/trailing whitespace
    biar emel_rapi = teks::rapi(emel_mentah);

    // Convert to lowercase
    biar emel_kecil = teks::ke_kecil(emel_rapi);

    // Remove any control characters (simplified)
    pulang emel_kecil;
}

/// Parse email into parts
fungsi huraikan_emel(emel: Teks) -> Mungkin<(Teks, Teks)> kesan Bersih {
    kalau !teks::mengandungi(emel, "@") {
        pulang Tiada;
    }

    biar bahagian = teks::pecah(emel, "@");

    kalau panjang(bahagian) != 2 {
        pulang Tiada;
    }

    biar pengguna = bahagian[0];
    biar domain = bahagian[1];

    kalau panjang(pengguna) == 0 || panjang(domain) == 0 {
        pulang Tiada;
    }

    pulang Ada((pengguna, domain));
}

/// Validate complete email
fungsi sahkan_emel(emel_mentah: Teks) -> HasilPengesahan kesan Bersih {
    biar emel = sanitasi_emel(emel_mentah);
    biar amaran = [];

    kalau panjang(emel) > 254 {
        pulang {
            sah: salah,
            emel: emel,
            pengguna: "",
            domain: "",
            amaran: ["Emel terlalu panjang (max 254 aksara)"],
        };
    }

    biar hasil_hurai = huraikan_emel(emel);

    padan hasil_hurai {
        Ada((pengguna, domain)) => {
            kalau panjang(pengguna) > 64 {
                amaran = amaran + ["Bahagian pengguna terlalu panjang"];
            }

            kalau !domain_sah(domain) {
                pulang {
                    sah: salah,
                    emel: emel,
                    pengguna: pengguna,
                    domain: domain,
                    amaran: ["Format domain tidak sah"],
                };
            }

            kalau cek_domain_sekali_pakai(domain) {
                amaran = amaran + ["Amaran: Domain sekali pakai terdeteksi"];
            }

            // Check for suspicious patterns
            kalau teks::mengandungi(pengguna, "..") {
                amaran = amaran + ["Amaran: Titik berturut-turut terdeteksi"];
            }

            kalau teks::mula_dengan(pengguna, ".") {
                amaran = amaran + ["Amaran: Pengguna bermula dengan titik"];
            }

            kalau teks::tamat_dengan(pengguna, ".") {
                amaran = amaran + ["Amaran: Pengguna tamat dengan titik"];
            }

            biar sah_akhir = panjang(amaran) == 0;

            pulang {
                sah: sah_akhir,
                emel: emel,
                pengguna: pengguna,
                domain: domain,
                amaran: amaran,
            };
        },
        Tiada => {
            pulang {
                sah: salah,
                emel: emel,
                pengguna: "",
                domain: "",
                amaran: ["Format emel tidak sah"],
            };
        },
    };
}

/// Batch validate emails
fungsi sahkan_senarai_emel(senarai_emel: Senarai<Teks>) -> Senarai<HasilPengesahan> kesan Bersih {
    biar hasil = [];

    untuk emel dalam senarai_emel {
        hasil = hasil + [sahkan_emel(emel)];
    }

    pulang hasil;
}

/// Filter only valid emails
fungsi dapat_emel_sah(hasil: Senarai<HasilPengesahan>) -> Senarai<Teks> kesan Bersih {
    biar senarai_sah = [];

    untuk r dalam hasil {
        kalau r.sah {
            senarai_sah = senarai_sah + [r.emel];
        }
    }

    pulang senarai_sah;
}

/// Example: Validate newsletter subscribers
awam fungsi utama() -> kesan Tulis {
    cetak_baris("=== PENGESAH EMEL ===");

    biar senarai_input = [
        "ahmad@example.my",
        "  nurul@company.com  ",
        "invalid.email",
        "spammer@tempmail.com",
        "too..many..dots@domain.my",
        ".startdot@domain.com",
        "veryveryveryveryveryveryveryveryveryveryveryveryverylongemailaddress@example.com",
    ];

    biar hasil_semak = sahkan_senarai_emel(senarai_input);

    untuk r dalam hasil_semak {
        kalau r.sah {
            cetak_baris(format!("âœ“ {} ({}) - SAH", r.emel, r.domain));
        } lain {
            cetak_baris(format!("âœ— {} - TIDAK SAH", r.emel));
            untuk amaran dalam r.amaran {
                cetak_baris(format!("  - {}", amaran));
            }
        }
    }

    biar emel_sah = dapat_emel_sah(hasil_semak);
    cetak_baris(format!("Jumlah emel sah: {}", panjang(emel_sah)));
}

// Helper functions
fungsi panjang(senarai: Senarai<T>) -> Nombor kesan Bersih {
    pulang 0;
}

fungsi format(s: Teks, args: Senarai<Teks>) -> Teks kesan Bersih {
    pulang s;
}

modul teks {
    fungsi mengandungi(teks: Teks, cari: Teks) -> Benar kesan Bersih {
        pulang betul;
    }

    fungsi rapi(teks: Teks) -> Teks kesan Bersih {
        pulang teks;
    }

    fungsi ke_kecil(teks: Teks) -> Teks kesan Bersih {
        pulang teks;
    }

    fungsi pecah(teks: Teks, pembahagi: Teks) -> Senarai<Teks> kesan Bersih {
        pulang [];
    }

    fungsi mula_dengan(teks: Teks, awalan: Teks) -> Benar kesan Bersih {
        pulang salah;
    }

    fungsi tamat_dengan(teks: Teks, akhiran: Teks) -> Benar kesan Bersih {
        pulang salah;
    }
}

// === 07_EXAMPLES/03_applications/health_checker.rii ===
/// health_checker.rii
/// Service health monitoring and status aggregation
/// Demonstrates Rangkaian effect for remote service checks
///
/// Features:
/// - Periodic health check scheduling
/// - Status aggregation
/// - Alert generation
/// - Historical tracking

modul penyemak_kesihatan;

guna std::rangkaian;
guna std::masa;
guna std::teks;
guna std::senarai;

jenis KeadaanKesihatan =
    | SIHAT
    | AMARAN
    | SAKIT
    | TIDAK_DIKETAHUI;

jenis HasilSemakan = {
    nama_perkhidmatan: Teks,
    keadaan: KeadaanKesihatan,
    kod_respons: Nombor,
    masa_tindakbalas_ms: Nombor,
    mesej: Teks,
    masa_semak: Nombor,
};

jenis KonfigurPerkhidmatan = {
    nama: Teks,
    alamat_url: Teks,
    timeout_ms: Nombor,
    had_kesuksesan_ms: Nombor,
};

jenis RekodKesihatan = {
    nama_perkhidmatan: Teks,
    senarai_hasil: Senarai<HasilSemakan>,
    keadaan_semasa: KeadaanKesihatan,
    masa_pembaruan_terakhir: Nombor,
};

/// Global health records
biar ubah rekod_kesihatan: Senarai<RekodKesihatan> = [];
biar ubah amaran: Senarai<Teks> = [];

/// Check single service health
/// Kesan: Rangkaian (makes HTTP requests)
fungsi semak_perkhidmatan(konfigur: KonfigurPerkhidmatan) -> HasilSemakan kesan Rangkaian {
    biar masa_mula = Masa::masa_unix_ms();

    biar hasil_http = coba Rangkaian::get_dengan_timeout(
        konfigur.alamat_url,
        konfigur.timeout_ms
    );

    biar masa_akhir = Masa::masa_unix_ms();
    biar masa_tindakbalas = masa_akhir - masa_mula;

    padan hasil_http {
        Berjaya(respons) => {
            biar keadaan = kalau masa_tindakbalas > konfigur.had_kesuksesan_ms {
                AMARAN
            } lain {
                SIHAT
            };

            pulang {
                nama_perkhidmatan: konfigur.nama,
                keadaan: keadaan,
                kod_respons: respons.kod,
                masa_tindakbalas_ms: masa_tindakbalas,
                mesej: "Respons OK",
                masa_semak: Masa::masa_unix(),
            };
        },
        Kegagalan(ralat) => {
            pulang {
                nama_perkhidmatan: konfigur.nama,
                keadaan: SAKIT,
                kod_respons: 0,
                masa_tindakbalas_ms: konfigur.timeout_ms,
                mesej: format!("Ralat: {}", ralat),
                masa_semak: Masa::masa_unix(),
            };
        },
    };
}

/// Aggregate health status across services
fungsi agregat_kesihatan(senarai_hasil: Senarai<HasilSemakan>) -> KeadaanKesihatan kesan Bersih {
    biar ada_sakit = salah;
    biar ada_amaran = salah;

    untuk hasil dalam senarai_hasil {
        padan hasil.keadaan {
            SAKIT => ada_sakit = betul,
            AMARAN => ada_amaran = betul,
            _ => {},
        };
    }

    kalau ada_sakit {
        pulang SAKIT;
    } lain kalau ada_amaran {
        pulang AMARAN;
    } lain {
        pulang SIHAT;
    };
}

/// Update or create health record
fungsi kemaskini_rekod(hasil_semak: HasilSemakan) -> kesan Bersih {
    biar nama = hasil_semak.nama_perkhidmatan;
    biar didapati = salah;

    biar rekod_baru = [];
    untuk rekod dalam rekod_kesihatan {
        kalau rekod.nama_perkhidmatan == nama {
            didapati = betul;
            biar senarai_baru = rekod.senarai_hasil + [hasil_semak];

            // Keep only last 100 results
            biar senarai_terhad = kalau panjang(senarai_baru) > 100 {
                buang_kepala(senarai_baru, panjang(senarai_baru) - 100)
            } lain {
                senarai_baru
            };

            rekod_baru = rekod_baru + [{
                nama_perkhidmatan: rekod.nama_perkhidmatan,
                senarai_hasil: senarai_terhad,
                keadaan_semasa: hasil_semak.keadaan,
                masa_pembaruan_terakhir: Masa::masa_unix(),
            }];
        } lain {
            rekod_baru = rekod_baru + [rekod];
        }
    }

    kalau !didapati {
        rekod_baru = rekod_baru + [{
            nama_perkhidmatan: nama,
            senarai_hasil: [hasil_semak],
            keadaan_semasa: hasil_semak.keadaan,
            masa_pembaruan_terakhir: Masa::masa_unix(),
        }];
    }

    rekod_kesihatan = rekod_baru;
}

/// Generate alert if status changed
fungsi jana_amaran(nama: Teks, keadaan_lama: KeadaanKesihatan, keadaan_baru: KeadaanKesihatan) -> kesan Bersih {
    biar perlu_amaran = padan (keadaan_lama, keadaan_baru) {
        (SIHAT, SAKIT) => betul,
        (SIHAT, AMARAN) => betul,
        (AMARAN, SAKIT) => betul,
        (SAKIT, SIHAT) => betul,
        (SAKIT, AMARAN) => betul,
        _ => salah,
    };

    kalau perlu_amaran {
        biar mesej_amaran = format!(
            "AMARAN: {} berubah dari {} kepada {} pada {}",
            nama,
            keadaan_ke_teks(keadaan_lama),
            keadaan_ke_teks(keadaan_baru),
            Masa::format_unix(Masa::masa_unix())
        );

        amaran = amaran + [mesej_amaran];
        cetak_baris(mesej_amaran);
    }
}

/// Perform health check on multiple services
fungsi semak_semua_perkhidmatan(konfigur_senarai: Senarai<KonfigurPerkhidmatan>) -> kesan Rangkaian {
    untuk konfigur dalam konfigur_senarai {
        biar hasil = semak_perkhidmatan(konfigur);

        // Check if status changed
        biar mungkin_rekod_lama = cari_rekod(konfigur.nama);
        padan mungkin_rekod_lama {
            Ada(rekod_lama) => {
                kalau rekod_lama.keadaan_semasa != hasil.keadaan {
                    jana_amaran(konfigur.nama, rekod_lama.keadaan_semasa, hasil.keadaan);
                }
            },
            Tiada => {},
        };

        kemaskini_rekod(hasil);
    }
}

/// Find health record by service name
fungsi cari_rekod(nama: Teks) -> Mungkin<RekodKesihatan> kesan Bersih {
    untuk rekod dalam rekod_kesihatan {
        kalau rekod.nama_perkhidmatan == nama {
            pulang Ada(rekod);
        }
    }

    pulang Tiada;
}

/// Get dashboard status
fungsi dapat_status_papan_pemuka() -> (KeadaanKesihatan, Nombor, Nombor) kesan Bersih {
    biar keadaan_keseluruhan = SIHAT;
    biar sihat = 0;
    biar sakit = 0;

    untuk rekod dalam rekod_kesihatan {
        padan rekod.keadaan_semasa {
            SIHAT => sihat = sihat + 1,
            SAKIT => {
                sakit = sakit + 1;
                keadaan_keseluruhan = SAKIT;
            },
            AMARAN => {
                kalau keadaan_keseluruhan == SIHAT {
                    keadaan_keseluruhan = AMARAN;
                }
            },
            _ => {},
        };
    }

    pulang (keadaan_keseluruhan, sihat, sakit);
}

/// Format health state as text
fungsi keadaan_ke_teks(keadaan: KeadaanKesihatan) -> Teks kesan Bersih {
    padan keadaan {
        SIHAT => "SIHAT",
        AMARAN => "AMARAN",
        SAKIT => "SAKIT",
        TIDAK_DIKETAHUI => "TIDAK_DIKETAHUI",
    };
}

/// Main health checker loop
awam fungsi utama() -> kesan Rangkaian {
    cetak_baris("=== PENYEMAK KESIHATAN PERKHIDMATAN ===");

    biar konfigur_perkhidmatan = [
        {
            nama: "API Pengguna",
            alamat_url: "http://api-pengguna:8080/kesihatan",
            timeout_ms: 5000,
            had_kesuksesan_ms: 1000,
        },
        {
            nama: "Pangkalan Data",
            alamat_url: "http://db-utama:5432/kesihatan",
            timeout_ms: 5000,
            had_kesuksesan_ms: 500,
        },
        {
            nama: "Perkhidmatan Penyimpanan",
            alamat_url: "http://penyimpanan:3000/status",
            timeout_ms: 5000,
            had_kesuksesan_ms: 2000,
        },
    ];

    // Run checks every 30 seconds
    ulang {
        cetak_baris(format!("Semakan kesihatan pada {}", Masa::format_unix(Masa::masa_unix())));
        semak_semua_perkhidmatan(konfigur_perkhidmatan);

        biar (keadaan, sihat, sakit) = dapat_status_papan_pemuka();
        cetak_baris(format!("Status keseluruhan: {} (Sihat: {}, Sakit: {})", keadaan_ke_teks(keadaan), sihat, sakit));

        Masa::rehat_saat(30);
    };
}

// Helper functions
fungsi panjang(senarai: Senarai<T>) -> Nombor kesan Bersih {
    pulang 0;
}

fungsi buang_kepala(senarai: Senarai<T>, jumlah: Nombor) -> Senarai<T> kesan Bersih {
    pulang [];
}

fungsi format(s: Teks, args: Senarai<Teks>) -> Teks kesan Bersih {
    pulang s;
}

// === 07_EXAMPLES/03_applications/key_value_store.rii ===
/// key_value_store.rii
/// In-memory key-value store with expiration and typed values
/// Demonstrates mutable state, pattern matching, and timeouts
///
/// Features:
/// - Type-safe value storage
/// - Key expiration (TTL)
/// - Atomic operations
/// - Transaction support

modul simpanan_kunci_nilai;

guna std::masa;
guna std::teks;
guna std::senarai;

jenis Nilai =
    | Teks(Teks)
    | Nombor(Nombor)
    | Benar(Benar)
    | Senarai(Senarai<Nilai>)
    | Peta(Senarai<(Teks, Nilai)>);

jenis EntriKV = {
    kunci: Teks,
    nilai: Nilai,
    masa_tamat: Mungkin<Nombor>,
    masa_cipta: Nombor,
};

/// Global store
biar ubah simpanan: Senarai<EntriKV> = [];

/// Add or update key-value pair
fungsi tetapkan(kunci: Teks, nilai: Nilai) -> kesan Bersih {
    tetapkan_dengan_ttl(kunci, nilai, Tiada);
}

/// Add or update with time-to-live
fungsi tetapkan_dengan_ttl(kunci: Teks, nilai: Nilai, ttl_saat: Mungkin<Nombor>) -> kesan Bersih {
    biar masa_tamat = padan ttl_saat {
        Ada(saat) => Ada(Masa::masa_unix() + saat),
        Tiada => Tiada,
    };

    biar entry_baru = {
        kunci: kunci,
        nilai: nilai,
        masa_tamat: masa_tamat,
        masa_cipta: Masa::masa_unix(),
    };

    // Remove existing entry if exists
    simpanan = saring_kunci(simpanan, kunci);

    // Add new entry
    simpanan = simpanan + [entry_baru];
}

/// Get value by key
fungsi dapat(kunci: Teks) -> Mungkin<Nilai> kesan Bersih {
    untuk entry dalam simpanan {
        kalau entry.kunci == kunci {
            // Check expiration
            padan entry.masa_tamat {
                Ada(tamat) => {
                    kalau Masa::masa_unix() > tamat {
                        pulang Tiada;
                    }
                },
                Tiada => {},
            }

            pulang Ada(entry.nilai);
        }
    }

    pulang Tiada;
}

/// Get string value with type checking
fungsi dapat_teks(kunci: Teks) -> Mungkin<Teks> kesan Bersih {
    biar mungkin_nilai = dapat(kunci);

    padan mungkin_nilai {
        Ada(Teks(t)) => Ada(t),
        _ => Tiada,
    };
}

/// Get number value with type checking
fungsi dapat_nombor(kunci: Teks) -> Mungkin<Nombor> kesan Bersih {
    biar mungkin_nilai = dapat(kunci);

    padan mungkin_nilai {
        Ada(Nombor(n)) => Ada(n),
        _ => Tiada,
    };
}

/// Check if key exists and not expired
fungsi ada(kunci: Teks) -> Benar kesan Bersih {
    untuk entry dalam simpanan {
        kalau entry.kunci == kunci {
            padan entry.masa_tamat {
                Ada(tamat) => {
                    kalau Masa::masa_unix() > tamat {
                        pulang salah;
                    }
                },
                Tiada => {},
            }

            pulang betul;
        }
    }

    pulang salah;
}

/// Delete key
fungsi padam(kunci: Teks) -> kesan Bersih {
    simpanan = saring_kunci(simpanan, kunci);
}

/// Increment number value
fungsi tambah_nilai(kunci: Teks, jumlah: Nombor) -> Mungkin<Nombor> kesan Bersih {
    biar mungkin_nilai = dapat_nombor(kunci);

    padan mungkin_nilai {
        Ada(nilai) => {
            biar nilai_baru = nilai + jumlah;
            tetapkan(kunci, Nombor(nilai_baru));
            pulang Ada(nilai_baru);
        },
        Tiada => {
            tetapkan(kunci, Nombor(jumlah));
            pulang Ada(jumlah);
        },
    };
}

/// Append to string
fungsi sambung_teks(kunci: Teks, tambah: Teks) -> Mungkin<Teks> kesan Bersih {
    biar mungkin_nilai = dapat_teks(kunci);

    padan mungkin_nilai {
        Ada(nilai) => {
            biar nilai_baru = nilai + tambah;
            tetapkan(kunci, Teks(nilai_baru));
            pulang Ada(nilai_baru);
        },
        Tiada => {
            tetapkan(kunci, Teks(tambah));
            pulang Ada(tambah);
        },
    };
}

/// Get all keys
fungsi dapat_semua_kunci() -> Senarai<Teks> kesan Bersih {
    biar hasil = [];
    biar masa_sekarang = Masa::masa_unix();

    untuk entry dalam simpanan {
        // Skip expired entries
        biar expired = padan entry.masa_tamat {
            Ada(tamat) => masa_sekarang > tamat,
            Tiada => salah,
        };

        kalau !expired {
            hasil = hasil + [entry.kunci];
        }
    }

    pulang hasil;
}

/// Clear expired entries
fungsi buang_yang_tamat() -> kesan Bersih {
    biar masa_sekarang = Masa::masa_unix();
    biar entry_sah = [];

    untuk entry dalam simpanan {
        biar expired = padan entry.masa_tamat {
            Ada(tamat) => masa_sekarang > tamat,
            Tiada => salah,
        };

        kalau !expired {
            entry_sah = entry_sah + [entry];
        }
    }

    simpanan = entry_sah;
}

/// Clear all entries
fungsi padamkan_semua() -> kesan Bersih {
    simpanan = [];
}

/// Get store statistics
fungsi dapat_statistik() -> (Nombor, Nombor, Nombor) kesan Bersih {
    biar jumlah = panjang(simpanan);
    biar tamat = 0;
    biar masa_sekarang = Masa::masa_unix();

    untuk entry dalam simpanan {
        biar expired = padan entry.masa_tamat {
            Ada(t) => masa_sekarang > t,
            Tiada => salah,
        };

        kalau expired {
            tamat = tamat + 1;
        }
    }

    biar sah = jumlah - tamat;
    pulang (sah, tamat, jumlah);
}

/// Demo usage
awam fungsi utama() -> kesan Bersih {
    cetak_baris("=== SIMPANAN KUNCI-NILAI ===");

    // Set values
    tetapkan("nama", Teks("Ahmad"));
    tetapkan("umur", Nombor(30));
    tetapkan_dengan_ttl("sesi_token", Teks("abc123def"), Ada(3600)); // 1 hour TTL

    // Retrieve values
    biar nama = dapat_teks("nama");
    biar umur = dapat_nombor("umur");

    cetak_baris(format!("Nama: {}", taraf_kunci(nama)));
    cetak_baris(format!("Umur: {}", taraf_kunci(umur)));

    // Increment
    tambah_nilai("pelawat", 1);
    tambah_nilai("pelawat", 1);

    // Get all keys
    biar semua_kunci = dapat_semua_kunci();
    cetak_baris(format!("Jumlah kunci: {}", panjang(semua_kunci)));

    // Stats
    biar (sah, tamat, jumlah) = dapat_statistik();
    cetak_baris(format!("Statistik - Sah: {}, Tamat: {}, Jumlah: {}", sah, tamat, jumlah));
}

// Helper functions
fungsi saring_kunci(senarai: Senarai<EntriKV>, kunci_buang: Teks) -> Senarai<EntriKV> kesan Bersih {
    biar hasil = [];

    untuk entry dalam senarai {
        kalau entry.kunci != kunci_buang {
            hasil = hasil + [entry];
        }
    }

    pulang hasil;
}

fungsi panjang(senarai: Senarai<T>) -> Nombor kesan Bersih {
    pulang 0;
}

fungsi taraf_kunci(mungkin: Mungkin<T>) -> Teks kesan Bersih {
    padan mungkin {
        Ada(_) => "Ada",
        Tiada => "Tiada",
    };
}

// === 07_EXAMPLES/03_applications/log_system.rii ===
/// log_system.rii
/// Structured logging system with multiple severity levels
/// Demonstrates time-based operations and file I/O coordination
///
/// Features:
/// - Log levels: DEBUG, INFO, WARN, ERROR, FATAL
/// - Timestamp tracking
/// - Structured logging with context
/// - File rotation support

modul sistem_log;

guna std::fail;
guna std::masa;
guna std::teks;
guna std::senarai;

jenis TarafKepentingan =
    | DEBUG
    | INFO
    | WARN
    | ERROR
    | FATAL;

jenis CatatanLog = {
    masa: Nombor,
    taraf: TarafKepentingan,
    sumber: Teks,
    mesej: Teks,
    konteks: Senarai<(Teks, Teks)>,
};

jenis PengkonfigLogging = {
    nama_fail: Teks,
    taraf_minima: TarafKepentingan,
    saiz_maksimal_kb: Nombor,
    tutup_konsol: Benar,
};

/// Logger state (mutable global)
biar ubah catatan: Senarai<CatatanLog> = [];
biar ubah konfigurasi: PengkonfigLogging = {
    nama_fail: "aplikasi.log",
    taraf_minima: DEBUG,
    saiz_maksimal_kb: 10240,
    tutup_konsol: betul,
};

/// Check if log level should be recorded
fungsi sepatutnya_log(taraf: TarafKepentingan) -> Benar kesan Bersih {
    biar min = konfigurasi.taraf_minima;

    padan (taraf, min) {
        (_, DEBUG) => betul,
        (INFO, INFO) => betul,
        (INFO, WARN) => salah,
        (INFO, ERROR) => salah,
        (INFO, FATAL) => salah,
        (WARN, WARN) => betul,
        (WARN, ERROR) => salah,
        (WARN, FATAL) => salah,
        (ERROR, ERROR) => betul,
        (ERROR, FATAL) => salah,
        (FATAL, FATAL) => betul,
        (FATAL, _) => betul,
        _ => salah,
    };
}

/// Format severity level as string
fungsi format_taraf(taraf: TarafKepentingan) -> Teks kesan Bersih {
    padan taraf {
        DEBUG => "[DEBUG]",
        INFO => "[INFO ]",
        WARN => "[WARN ]",
        ERROR => "[ERROR]",
        FATAL => "[FATAL]",
    };
}

/// Create formatted log entry
fungsi format_catatan(catatan: CatatanLog) -> Teks kesan Bersih {
    biar masa_format = Masa::format_unix(catatan.masa);
    biar taraf_format = format_taraf(catatan.taraf);

    biar konteks_format = "";
    untuk (kunci, nilai) dalam catatan.konteks {
        konteks_format = konteks_format + format!(" {}={}", kunci, nilai);
    }

    pulang format!(
        "{} {} [{}]{} {}",
        masa_format,
        taraf_format,
        catatan.sumber,
        konteks_format,
        catatan.mesej
    );
}

/// Record log entry
/// Kesan: SistemFail (may write to file)
fungsi log_catatan(
    taraf: TarafKepentingan,
    sumber: Teks,
    mesej: Teks,
    konteks: Senarai<(Teks, Teks)>
) -> kesan SistemFail {
    kalau !sepatutnya_log(taraf) {
        pulang ();
    }

    biar catatan_baru = {
        masa: Masa::masa_unix(),
        taraf: taraf,
        sumber: sumber,
        mesej: mesej,
        konteks: konteks,
    };

    catatan = catatan + [catatan_baru];

    // Output to console if enabled
    kalau konfigurasi.tutup_konsol {
        biar teks_format = format_catatan(catatan_baru);
        cetak_baris(teks_format);
    }

    // Write to file
    biar teks_format = format_catatan(catatan_baru);
    biar hasil = coba SistemFail::tambah_fail(konfigurasi.nama_fail, teks_format + "\n");

    padan hasil {
        Berjaya(_) => {},
        Kegagalan(ralat) => {
            cetak_ralat(format!("Gagal menulis log: {}", ralat));
        },
    };
}

/// Log at DEBUG level
fungsi log_debug(sumber: Teks, mesej: Teks) -> kesan SistemFail {
    log_catatan(DEBUG, sumber, mesej, []);
}

/// Log at INFO level
fungsi log_info(sumber: Teks, mesej: Teks) -> kesan SistemFail {
    log_catatan(INFO, sumber, mesej, []);
}

/// Log at WARN level
fungsi log_amaran(sumber: Teks, mesej: Teks) -> kesan SistemFail {
    log_catatan(WARN, sumber, mesej, []);
}

/// Log at ERROR level
fungsi log_ralat(sumber: Teks, mesej: Teks) -> kesan SistemFail {
    log_catatan(ERROR, sumber, mesej, []);
}

/// Log at FATAL level
fungsi log_musnah(sumber: Teks, mesej: Teks) -> kesan SistemFail {
    log_catatan(FATAL, sumber, mesej, []);
}

/// Get all logs for given source
fungsi dapat_catatan_dari_sumber(sumber: Teks) -> Senarai<CatatanLog> kesan Bersih {
    biar hasil = [];

    untuk catatan dalam catatan {
        kalau catatan.sumber == sumber {
            hasil = hasil + [catatan];
        }
    }

    pulang hasil;
}

/// Clear all logs
fungsi padam_semua_log() -> kesan Bersih {
    catatan = [];
}

/// Export logs to JSON
fungsi eksport_json() -> Teks kesan Bersih {
    biar hasil = "[";

    untuk i, catatan dalam catatan {
        kalau i > 0 {
            hasil = hasil + ",";
        }

        biar json_item = format!(
            "{{\"masa\":{},\"taraf\":\"{}\",\"sumber\":\"{}\",\"mesej\":\"{}\"}}",
            catatan.masa,
            taraf_ke_teks(catatan.taraf),
            catatan.sumber,
            teks::lepas_kecil(catatan.mesej)
        );

        hasil = hasil + json_item;
    }

    hasil = hasil + "]";
    pulang hasil;
}

/// Example usage: Database operations
awam fungsi contoh_operasi_db() -> kesan SistemFail {
    biar sumber = "DatabaseModule";

    log_info(sumber, "Memulai sambungan ke pangkalan data");

    // Simulate database operation
    biar id_sambungan = 12345;
    log_debug(sumber, format!("Sambungan dibuka: {}", id_sambungan));

    // Check status
    biar status_ok = betul;
    kalau status_ok {
        log_info(sumber, "Kueri dijalankan berjaya");
    } lain {
        log_ralat(sumber, "Kueri gagal");
    }

    log_info(sumber, "Sambungan ditutup");
    pulang ();
}

// Helper functions
fungsi taraf_ke_teks(taraf: TarafKepentingan) -> Teks kesan Bersih {
    padan taraf {
        DEBUG => "DEBUG",
        INFO => "INFO",
        WARN => "WARN",
        ERROR => "ERROR",
        FATAL => "FATAL",
    };
}

fungsi cetak_ralat(mesej: Teks) -> kesan Tulis {
    // Print to stderr equivalent
}

// === 07_EXAMPLES/03_applications/password_manager.rii ===
/// password_manager.rii
/// Secure password storage and management with cryptography
/// Demonstrates Rahsia type, Kripto effect, and secure operations
///
/// Features:
/// - Password hashing with salt
/// - Cryptographic key derivation
/// - Secure comparison
/// - Credential storage

modul pengurusan_katalaluan;

guna std::kripto;
guna std::fail;
guna std::teks;
guna std::senarai;

jenis KatalalaunBerbutir = {
    pengguna: Teks,
    garam: Teks,
    hash_katalaluan: Rahsia<Teks>,
    algoritma: Teks,
    iterasi: Nombor,
    masa_cipta: Nombor,
};

jenis PersediakuasaDisimpan = {
    pengguna: Teks,
    perkhidmatan: Teks,
    katalaluan: Rahsia<Teks>,
    nama_medan: Teks,
    masa_cipta: Nombor,
};

/// Global credential vault
biar ubah peti_katalaluan: Senarai<KatalalaunBerbutir> = [];
biar ubah peti_persediakuasa: Senarai<PersediakuasaDisimpan> = [];

/// Generate random salt for hashing
/// Kesan: Kripto (cryptographic randomness)
fungsi jana_garam() -> Teks kesan Kripto {
    pulang Kripto::jana_rawak_hex(32);
}

/// Hash password with PBKDF2
/// Kesan: Kripto
fungsi hash_katalaluan(
    katalaluan_mentah: Teks,
    garam: Teks
) -> Rahsia<Teks> kesan Kripto {
    biar hash_hasilkan = Kripto::pbkdf2(
        katalaluan_mentah,
        garam,
        100000,    // iterations
        64,        // output length
        "sha256"
    );

    pulang dedah(hash_hasilkan, "katalaluan_pemprosesan");
}

/// Register new user with password
/// Kesan: Kripto (hashing)
fungsi daftar_pengguna(
    nama_pengguna: Teks,
    katalaluan_mentah: Teks
) -> kesan Kripto {
    // Check if user exists
    untuk catatan dalam peti_katalaluan {
        kalau catatan.pengguna == nama_pengguna {
            cetak_baris("Pengguna sudah wujud");
            pulang ();
        }
    }

    // Generate salt
    biar garam = jana_garam();

    // Hash password
    biar hash = hash_katalaluan(katalaluan_mentah, garam);

    biar catatan_baru = {
        pengguna: nama_pengguna,
        garam: garam,
        hash_katalaluan: hash,
        algoritma: "PBKDF2-SHA256",
        iterasi: 100000,
        masa_cipta: Masa::masa_unix(),
    };

    peti_katalaluan = peti_katalaluan + [catatan_baru];
    cetak_baris(format!("Pengguna {} didaftar", nama_pengguna));
}

/// Verify password for user
/// Kesan: Kripto (hashing for comparison)
fungsi sahkan_katalaluan(
    nama_pengguna: Teks,
    katalaluan_cuba: Teks
) -> Benar kesan Kripto {
    untuk catatan dalam peti_katalaluan {
        kalau catatan.pengguna == nama_pengguna {
            // Hash the attempted password with stored salt
            biar hash_cuba = hash_katalaluan(katalaluan_cuba, catatan.garam);

            // Constant-time comparison
            biar sama = Kripto::bandingkan_malar(
                dedah(hash_cuba, "pemeriksaan_katalaluan"),
                dedah(catatan.hash_katalaluan, "pemeriksaan_katalaluan")
            );

            pulang sama;
        }
    }

    // User not found - still do hash to prevent timing attack
    jana_garam();
    pulang salah;
}

/// Store credential for service
/// Kesan: Kripto (encryption of credential)
fungsi simpan_persediakuasa(
    nama_pengguna: Teks,
    nama_perkhidmatan: Teks,
    nama_medan: Teks,
    nilai_persediakuasa: Teks,
    kunci_enkripsi: Rahsia<Teks>
) -> kesan Kripto {
    // Encrypt credential
    biar persediakuasa_terenkripsi = Kripto::enkripsi_aes_256_gcm(
        nilai_persediakuasa,
        kunci_enkripsi
    );

    biar rekod = {
        pengguna: nama_pengguna,
        perkhidmatan: nama_perkhidmatan,
        katalaluan: persediakuasa_terenkripsi,
        nama_medan: nama_medan,
        masa_cipta: Masa::masa_unix(),
    };

    peti_persediakuasa = peti_persediakuasa + [rekod];
    cetak_baris(format!("Persediakuasa untuk {} disimpan", nama_perkhidmatan));
}

/// Retrieve credential
/// Kesan: Kripto (decryption)
fungsi ambil_persediakuasa(
    nama_pengguna: Teks,
    nama_perkhidmatan: Teks,
    kunci_enkripsi: Rahsia<Teks>
) -> Mungkin<Teks> kesan Kripto {
    untuk rekod dalam peti_persediakuasa {
        kalau rekod.pengguna == nama_pengguna && rekod.perkhidmatan == nama_perkhidmatan {
            // Decrypt credential
            biar hasil_dekripsi = Kripto::dekripsi_aes_256_gcm(
                dedah(rekod.katalaluan, "pengambilan_persediakuasa"),
                kunci_enkripsi
            );

            padan hasil_dekripsi {
                Berjaya(nilai) => pulang Ada(nilai),
                Kegagalan(_) => pulang Tiada,
            };
        }
    }

    pulang Tiada;
}

/// Change password for user
/// Kesan: Kripto
fungsi tukar_katalaluan(
    nama_pengguna: Teks,
    katalaluan_lama: Teks,
    katalaluan_baru: Teks
) -> Benar kesan Kripto {
    // Verify old password first
    biar sahih = sahkan_katalaluan(nama_pengguna, katalaluan_lama);

    kalau !sahih {
        cetak_baris("Katalaluan lama tidak sah");
        pulang salah;
    }

    // Remove old entry
    biar peti_baru = [];
    untuk catatan dalam peti_katalaluan {
        kalau catatan.pengguna != nama_pengguna {
            peti_baru = peti_baru + [catatan];
        }
    }
    peti_katalaluan = peti_baru;

    // Register with new password
    daftar_pengguna(nama_pengguna, katalaluan_baru);
    cetak_baris(format!("Katalaluan {} diperbarui", nama_pengguna));

    pulang betul;
}

/// Audit password strength
fungsi semak_kekuatan_katalaluan(katalaluan: Teks) -> (Teks, Senarai<Teks>) kesan Bersih {
    biar amaran = [];
    biar skor = 0;

    kalau panjang(katalaluan) < 8 {
        amaran = amaran + ["Terlalu pendek (min 8 aksara)"];
    } lain {
        skor = skor + 1;
    }

    kalau !ada_huruf_besar(katalaluan) {
        amaran = amaran + ["Diperlukan huruf besar"];
    } lain {
        skor = skor + 1;
    }

    kalau !ada_huruf_kecil(katalaluan) {
        amaran = amaran + ["Diperlukan huruf kecil"];
    } lain {
        skor = skor + 1;
    }

    kalau !ada_nombor(katalaluan) {
        amaran = amaran + ["Diperlukan nombor"];
    } lain {
        skor = skor + 1;
    }

    kalau !ada_simbol(katalaluan) {
        amaran = amaran + ["Diperlukan simbol khusus"];
    } lain {
        skor = skor + 1;
    }

    biar kekuatan = padan skor {
        0 | 1 => "Lemah",
        2 | 3 => "Sederhana",
        4 | 5 => "Kuat",
    };

    pulang (kekuatan, amaran);
}

/// Main password manager demo
awam fungsi utama() -> kesan (Kripto | Tulis) {
    cetak_baris("=== PENGURUSAN KATALALUAN SELAMAT ===");

    // Register user
    daftar_pengguna("ahmad", "MySecure@Pass123");
    cetak_baris("Daftar: OK");

    // Verify password
    biar betul = sahkan_katalaluan("ahmad", "MySecure@Pass123");
    cetak_baris(format!("Pengesahan kata laluan: {}", kalau betul { "OK" } lain { "GAGAL" }));

    // Try wrong password
    biar salah = sahkan_katalaluan("ahmad", "WrongPassword");
    cetak_baris(format!("Pengesahan salah: {}", kalau !salah { "OK (ditolak dengan betul)" } lain { "GAGAL" }));

    // Check strength
    biar (kekuatan, amaran) = semak_kekuatan_katalaluan("weak");
    cetak_baris(format!("Kekuatan 'weak': {}", kekuatan));
    untuk pesan dalam amaran {
        cetak_baris(format!("  - {}", pesan));
    }
}

// Helper functions
fungsi panjang(teks: Teks) -> Nombor kesan Bersih {
    pulang 0;
}

fungsi ada_huruf_besar(teks: Teks) -> Benar kesan Bersih {
    pulang betul;
}

fungsi ada_huruf_kecil(teks: Teks) -> Benar kesan Bersih {
    pulang betul;
}

fungsi ada_nombor(teks: Teks) -> Benar kesan Bersih {
    pulang betul;
}

fungsi ada_simbol(teks: Teks) -> Benar kesan Bersih {
    pulang betul;
}

fungsi format(s: Teks, args: Senarai<T>) -> Teks kesan Bersih {
    pulang s;
}

modul Masa {
    fungsi masa_unix() -> Nombor kesan Bersih {
        pulang 0;
    }
}

// === 07_EXAMPLES/03_applications/queue_processor.rii ===
/// queue_processor.rii
/// Message queue processing with worker pool
/// Demonstrates concurrent effect handling and state management
///
/// Features:
/// - FIFO message queue
/// - Worker thread pool
/// - Graceful shutdown
/// - Error handling and retry

modul pemproses_baris_giliran;

guna std::senarai;
guna std::teks;
guna std::fail;
guna std::masa;

jenis Pesanan = {
    id: Nombor,
    jenis: Teks,
    payload: Teks,
    masa_cipta: Nombor,
    cubaan: Nombor,
    max_cubaan: Nombor,
};

jenis Status =
    | MENUNGGU
    | MEMPROSES
    | BERJAYA
    | GAGAL
    | DITOLAK;

jenis CatatanPesanan = {
    id: Nombor,
    status: Status,
    pesan_ralat: Mungkin<Teks>,
    masa_siap: Mungkin<Nombor>,
};

/// Global queue and processing state
biar ubah giliran_pesanan: Senarai<Pesanan> = [];
biar ubah catatan_pesanan: Senarai<CatatanPesanan> = [];
biar ubah id_pesanan_berikutnya: Nombor = 1;

/// Enqueue new message
fungsi masukkan_pesanan(
    jenis_pesanan: Teks,
    payload: Teks
) -> Nombor kesan Bersih {
    biar id_baru = id_pesanan_berikutnya;
    id_pesanan_berikutnya = id_pesanan_berikutnya + 1;

    biar pesanan = {
        id: id_baru,
        jenis: jenis_pesanan,
        payload: payload,
        masa_cipta: Masa::masa_unix(),
        cubaan: 0,
        max_cubaan: 3,
    };

    giliran_pesanan = giliran_pesanan + [pesanan];

    biar catatan = {
        id: id_baru,
        status: MENUNGGU,
        pesan_ralat: Tiada,
        masa_siap: Tiada,
    };
    catatan_pesanan = catatan_pesanan + [catatan];

    pulang id_baru;
}

/// Dequeue next message for processing
fungsi ambil_pesanan_seterusnya() -> Mungkin<Pesanan> kesan Bersih {
    kalau panjang(giliran_pesanan) > 0 {
        biar pesanan = giliran_pesanan[0];
        giliran_pesanan = tunda_kepala(giliran_pesanan);
        pulang Ada(pesanan);
    } lain {
        pulang Tiada;
    };
}

/// Process message based on type
fungsi proses_pesanan(pesanan: Pesanan) -> (Benar, Mungkin<Teks>) kesan SistemFail {
    padan pesanan.jenis {
        "emel" => {
            // Send email
            biar hasil = coba SistemFail::hantar_emel(pesanan.payload);
            padan hasil {
                Berjaya(_) => pulang (betul, Tiada),
                Kegagalan(ralat) => pulang (salah, Ada(ralat)),
            };
        },
        "sms" => {
            // Send SMS
            biar hasil = coba SistemFail::hantar_sms(pesanan.payload);
            padan hasil {
                Berjaya(_) => pulang (betul, Tiada),
                Kegagalan(ralat) => pulang (salah, Ada(ralat)),
            };
        },
        "laporan" => {
            // Generate report
            biar hasil = coba SistemFail::jana_laporan(pesanan.payload);
            padan hasil {
                Berjaya(_) => pulang (betul, Tiada),
                Kegagalan(ralat) => pulang (salah, Ada(ralat)),
            };
        },
        "pengesahan" => {
            // Webhook notification
            biar hasil = coba SistemFail::panggil_hook(pesanan.payload);
            padan hasil {
                Berjaya(_) => pulang (betul, Tiada),
                Kegagalan(ralat) => pulang (salah, Ada(ralat)),
            };
        },
        _ => {
            pulang (salah, Ada("Jenis pesanan tidak dikenali"));
        },
    };
}

/// Update message status
fungsi kemaskini_status(id_pesanan: Nombor, status_baru: Status, ralat: Mungkin<Teks>) -> kesan Bersih {
    biar catatan_baru = [];

    untuk catatan dalam catatan_pesanan {
        kalau catatan.id == id_pesanan {
            catatan_baru = catatan_baru + [{
                id: catatan.id,
                status: status_baru,
                pesan_ralat: ralat,
                masa_siap: Ada(Masa::masa_unix()),
            }];
        } lain {
            catatan_baru = catatan_baru + [catatan];
        }
    }

    catatan_pesanan = catatan_baru;
}

/// Worker process function
/// Processes messages from queue until empty
/// Kesan: SistemFail (actual work may perform I/O)
fungsi pekerja_pemproses(id_pekerja: Nombor) -> kesan SistemFail {
    cetak_baris(format!("Pekerja {} memulai", id_pekerja));

    ulang {
        biar mungkin_pesanan = ambil_pesanan_seterusnya();

        padan mungkin_pesanan {
            Ada(pesanan) => {
                cetak_baris(format!("Pekerja {} memproses pesanan {}", id_pekerja, pesanan.id));

                kemaskini_status(pesanan.id, MEMPROSES, Tiada);

                biar (berjaya, ralat) = proses_pesanan(pesanan);

                kalau berjaya {
                    kemaskini_status(pesanan.id, BERJAYA, Tiada);
                    cetak_baris(format!("Pesanan {} berjaya", pesanan.id));
                } lain {
                    // Check if should retry
                    kalau pesanan.cubaan < pesanan.max_cubaan {
                        biar pesanan_retry = {
                            id: pesanan.id,
                            jenis: pesanan.jenis,
                            payload: pesanan.payload,
                            masa_cipta: pesanan.masa_cipta,
                            cubaan: pesanan.cubaan + 1,
                            max_cubaan: pesanan.max_cubaan,
                        };
                        giliran_pesanan = giliran_pesanan + [pesanan_retry];
                        cetak_baris(format!("Pesanan {} dijadual semula (cubaan {})", pesanan.id, pesanan.cubaan + 1));
                    } lain {
                        kemaskini_status(pesanan.id, GAGAL, ralat);
                        cetak_baris(format!("Pesanan {} gagal akhir", pesanan.id));
                    }
                }
            },
            Tiada => {
                cetak_baris(format!("Pekerja {} tiada pesanan, berhenti", id_pekerja));
                ulang_akhir;
            },
        };

        // Simulate work time
        Masa::rehat_ms(100);
    };

    cetak_baris(format!("Pekerja {} selesai", id_pekerja));
}

/// Get queue status
fungsi dapat_status_giliran() -> (Nombor, Nombor, Nombor) kesan Bersih {
    biar menunggu = 0;
    biar memproses = 0;
    biar berjaya = 0;

    untuk catatan dalam catatan_pesanan {
        padan catatan.status {
            MENUNGGU => menunggu = menunggu + 1,
            MEMPROSES => memproses = memproses + 1,
            BERJAYA => berjaya = berjaya + 1,
            _ => {},
        };
    }

    pulang (menunggu, memproses, berjaya);
}

/// Main queue processor
awam fungsi utama() -> kesan SistemFail {
    cetak_baris("=== PEMPROSES BARIS GILIRAN ===");

    // Add sample messages
    masukkan_pesanan("emel", "emel@contoh.my");
    masukkan_pesanan("sms", "+60123456789");
    masukkan_pesanan("laporan", "laporan_bulanan.pdf");
    masukkan_pesanan("pengesahan", "https://webhook.contoh.my/notify");

    // Start worker pool (simulated with single worker)
    pekerja_pemproses(1);

    // Print final stats
    biar (menunggu, memproses, berjaya) = dapat_status_giliran();
    cetak_baris(format!("Status akhir - Menunggu: {}, Memproses: {}, Berjaya: {}", menunggu, memproses, berjaya));
}

// Helper functions
fungsi tunda_kepala(senarai: Senarai<T>) -> Senarai<T> kesan Bersih {
    kalau panjang(senarai) > 1 {
        biar hasil = [];
        untuk i dari 1 hingga panjang(senarai) {
            hasil = hasil + [senarai[i]];
        }
        pulang hasil;
    } lain {
        pulang [];
    }
}

fungsi panjang(senarai: Senarai<T>) -> Nombor kesan Bersih {
    pulang 0;
}

// === 07_EXAMPLES/03_applications/rate_limiter.rii ===
/// rate_limiter.rii
/// Rate limiting implementation using token bucket algorithm
/// Demonstrates Masa effect for time-based operations
///
/// Features:
/// - Token bucket rate limiting
/// - Per-user/endpoint quotas
/// - Configurable refill rates
/// - Reject excess requests

modul pembatas_kadar;

guna std::masa;
guna std::teks;
guna std::senarai;

jenis KonfigurBatas = {
    kapasitas_maksimal: Nombor,
    kadar_isi_semula: Nombor, // tokens per second
    tempoh_jendela_saat: Nombor,
};

jenis LadangToken = {
    id_klien: Teks,
    token_sedia: Nombor,
    masa_isi_semula_terakhir: Nombor,
    konfigur: KonfigurBatas,
};

jenis HasilPemeriksaan =
    | DibenarkanTokens(Nombor)
    | DihadMelebihi(Nombor); // tokens required

/// Global rate limiters per client
biar ubah ladang_token: Senarai<LadangToken> = [];

/// Initialize rate limiter for client
fungsi inisialisasi_klien(id_klien: Teks, konfigur: KonfigurBatas) -> kesan Bersih {
    biar ladang_baru = {
        id_klien: id_klien,
        token_sedia: konfigur.kapasitas_maksimal,
        masa_isi_semula_terakhir: Masa::masa_unix(),
        konfigur: konfigur,
    };

    ladang_token = ladang_token + [ladang_baru];
}

/// Refill tokens based on elapsed time
fungsi isi_semula_token(ubah ladang: LadangToken) -> kesan Masa {
    biar masa_sekarang = Masa::masa_unix();
    biar masa_berlalu = masa_sekarang - ladang.masa_isi_semula_terakhir;

    biar token_diisi = masa_berlalu * ladang.konfigur.kadar_isi_semula;
    biar token_baru = ladang.token_sedia + token_diisi;

    // Cap at maximum
    kalau token_baru > ladang.konfigur.kapasitas_maksimal {
        ladang.token_sedia = ladang.konfigur.kapasitas_maksimal;
    } lain {
        ladang.token_sedia = token_baru;
    }

    ladang.masa_isi_semula_terakhir = masa_sekarang;
}

/// Check if request is allowed
/// Kesan: Masa (checks current time)
fungsi semak_had(id_klien: Teks, token_diperlukan: Nombor) -> HasilPemeriksaan kesan Masa {
    biar mungkin_ladang = cari_ladang(id_klien);

    padan mungkin_ladang {
        Ada(ladang) => {
            // Refill tokens first
            isi_semula_token(ladang);

            kalau ladang.token_sedia >= token_diperlukan {
                // Allow request
                ladang.token_sedia = ladang.token_sedia - token_diperlukan;
                pulang DibenarkanTokens(token_diperlukan);
            } lain {
                // Rate limited
                pulang DihadMelebihi(token_diperlukan);
            }
        },
        Tiada => {
            // Client not found - could auto-initialize
            pulang DihadMelebihi(token_diperlukan);
        },
    };
}

/// Find ladang for client
fungsi cari_ladang(id_klien: Teks) -> Mungkin<LadangToken> kesan Bersih {
    untuk ladang dalam ladang_token {
        kalau ladang.id_klien == id_klien {
            pulang Ada(ladang);
        }
    }

    pulang Tiada;
}

/// Get remaining tokens for client
fungsi dapat_token_sedia(id_klien: Teks) -> Mungkin<Nombor> kesan Bersih {
    biar mungkin_ladang = cari_ladang(id_klien);

    padan mungkin_ladang {
        Ada(ladang) => Ada(ladang.token_sedia),
        Tiada => Tiada,
    };
}

/// Get reset time for client
fungsi dapat_masa_set_semula(id_klien: Teks) -> Mungkin<Nombor> kesan Bersih {
    biar mungkin_ladang = cari_ladang(id_klien);

    padan mungkin_ladang {
        Ada(ladang) => {
            biar token_untuk_isi_penuh = ladang.konfigur.kapasitas_maksimal - ladang.token_sedia;
            biar saat_diperlukan = token_untuk_isi_penuh / ladang.konfigur.kadar_isi_semula;
            pulang Ada(saat_diperlukan);
        },
        Tiada => Tiada,
    };
}

/// API endpoint handler with rate limiting
fungsi uruskan_permintaan_api(id_klien: Teks, laluan: Teks) -> Mungkin<Teks> kesan Masa {
    // Check rate limit
    biar hasil = semak_had(id_klien, 1);

    padan hasil {
        DibenarkanTokens(_) => {
            // Process request
            padan laluan {
                "/data/senarai" => {
                    pulang Ada("{\"senarai\":[1,2,3]}");
                },
                "/data/perincian" => {
                    pulang Ada("{\"nama\":\"Ahmad\",\"umur\":30}");
                },
                "/tindakan/kemaskini" => {
                    pulang Ada("{\"berjaya\":true}");
                },
                _ => {
                    pulang Ada("{\"ralat\":\"Laluan tidak ditemui\"}");
                },
            };
        },
        DihadMelebihi(diperlukan) => {
            biar saat_tunggu = dapat_masa_set_semula(id_klien);
            padan saat_tunggu {
                Ada(saat) => {
                    pulang Ada(format!("{{\"ralat\":\"Kadar melebihi\",\"tunggu_saat\":{}}}", saat));
                },
                Tiada => {
                    pulang Ada("{\"ralat\":\"Kadar melebihi\"}");
                },
            };
        },
    };
}

/// Distributed rate limiter example
awam fungsi utama() -> kesan Masa {
    cetak_baris("=== PEMBATAS KADAR PERMINTAAN ===");

    // Configure rate limits
    biar konfigur_standard = {
        kapasitas_maksimal: 100,      // 100 requests max
        kadar_isi_semula: 10,         // 10 requests per second
        tempoh_jendela_saat: 1,       // 1 second window
    };

    // Initialize clients
    inisialisasi_klien("klien_a", konfigur_standard);
    inisialisasi_klien("klien_b", konfigur_standard);

    // Simulate requests
    untuk i dari 1 hingga 5 {
        biar hasil_a = semak_had("klien_a", 1);
        biar hasil_b = semak_had("klien_b", 1);

        padan hasil_a {
            DibenarkanTokens(_) => {
                cetak_baris(format!("Permintaan {} dari klien_a: Dibenarkan", i));
            },
            DihadMelebihi(_) => {
                cetak_baris(format!("Permintaan {} dari klien_a: Dihadkan", i));
            },
        };

        padan hasil_b {
            DibenarkanTokens(_) => {
                cetak_baris(format!("Permintaan {} dari klien_b: Dibenarkan", i));
            },
            DihadMelebihi(_) => {
                cetak_baris(format!("Permintaan {} dari klien_b: Dihadkan", i));
            },
        };

        // Small delay between requests
        Masa::rehat_ms(50);
    }

    // Show remaining tokens
    biar baki_a = dapat_token_sedia("klien_a");
    biar baki_b = dapat_token_sedia("klien_b");

    cetak_baris(format!("Token sedia - Klien A: {}, Klien B: {}", taraf_baki(baki_a), taraf_baki(baki_b)));
}

// Helper functions
fungsi taraf_baki(mungkin: Mungkin<Nombor>) -> Teks kesan Bersih {
    padan mungkin {
        Ada(n) => format!("{}", n),
        Tiada => "Tidak diketahui",
    };
}

fungsi format(s: Teks, args: Senarai<Teks>) -> Teks kesan Bersih {
    pulang s;
}

// === 07_EXAMPLES/03_applications/session_manager.rii ===
/// session_manager.rii
/// Session management with capability tokens and timeouts
/// Demonstrates security properties with stateful operations
///
/// Features:
/// - Capability-based token generation
/// - Session lifecycle management
/// - Timeout enforcement
/// - Concurrent session limiting

modul pengurus_sesi;

guna std::kripto;
guna std::masa;
guna std::teks;
guna std::senarai;

jenis TokenSesuai = Keupayaan<{
    pengguna_id: Teks,
    token_id: Teks,
    skop: Senarai<Teks>,
}>;

jenis Sesi = {
    token_id: Teks,
    pengguna_id: Teks,
    skop: Senarai<Teks>,
    masa_cipta: Nombor,
    masa_tamat: Nombor,
    alamat_ip: Teks,
    agen_pengguna: Teks,
    aktif: Benar,
};

jenis RekodSesi = {
    pengguna_id: Teks,
    senarai_sesi: Senarai<Sesi>,
    sesi_maksimal: Nombor,
};

/// Global session store
biar ubah stor_sesi: Senarai<RekodSesi> = [];

/// Generate secure session token
/// Kesan: Kripto
fungsi jana_token() -> Teks kesan Kripto {
    pulang Kripto::jana_rawak_hex(32);
}

/// Create new session
/// Kesan: Kripto (token generation)
fungsi cipta_sesi(
    pengguna_id: Teks,
    alamat_ip: Teks,
    agen_pengguna: Teks,
    ttl_saat: Nombor
) -> TokenSesuai kesan Kripto {
    biar token_id = jana_token();
    biar masa_sekarang = Masa::masa_unix();
    biar masa_tamat = masa_sekarang + ttl_saat;

    biar sesi_baru = {
        token_id: token_id,
        pengguna_id: pengguna_id,
        skop: ["baca", "tulis"],
        masa_cipta: masa_sekarang,
        masa_tamat: masa_tamat,
        alamat_ip: alamat_ip,
        agen_pengguna: agen_pengguna,
        aktif: betul,
    };

    // Find or create user record
    biar rekod_pengguna = cari_rekod_pengguna(pengguna_id);

    padan rekod_pengguna {
        Ada(rekod) => {
            // Check session limit
            kalau panjang(rekod.senarai_sesi) >= rekod.sesi_maksimal {
                // Terminate oldest session
                biar senarai_sesi_baru = hapus_sesi_tertua(rekod.senarai_sesi);
                kemaskini_rekod_pengguna(pengguna_id, senarai_sesi_baru + [sesi_baru]);
            } lain {
                kemaskini_rekod_pengguna(pengguna_id, rekod.senarai_sesi + [sesi_baru]);
            }
        },
        Tiada => {
            biar rekod_baru = {
                pengguna_id: pengguna_id,
                senarai_sesi: [sesi_baru],
                sesi_maksimal: 5,
            };
            stor_sesi = stor_sesi + [rekod_baru];
        },
    };

    // Return capability token
    pulang Keupayaan({
        pengguna_id: pengguna_id,
        token_id: token_id,
        skop: sesi_baru.skop,
    });
}

/// Validate session token
fungsi sahkan_sesi(token_id: Teks) -> Mungkin<Sesi> kesan Bersih {
    untuk rekod dalam stor_sesi {
        untuk sesi dalam rekod.senarai_sesi {
            kalau sesi.token_id == token_id {
                // Check if expired
                kalau Masa::masa_unix() > sesi.masa_tamat {
                    pulang Tiada;
                }

                kalau !sesi.aktif {
                    pulang Tiada;
                }

                pulang Ada(sesi);
            }
        }
    }

    pulang Tiada;
}

/// Check if session has required scope
fungsi ada_skop(sesi: Sesi, skop_perlu: Teks) -> Benar kesan Bersih {
    untuk skop dalam sesi.skop {
        kalau skop == skop_perlu {
            pulang betul;
        }
    }

    pulang salah;
}

/// Refresh session (extend timeout)
fungsi segar_sesi(token_id: Teks, tambah_saat: Nombor) -> Benar kesan Bersih {
    untuk rekod dalam stor_sesi {
        biar senarai_baru = [];
        biar didapati = salah;

        untuk sesi dalam rekod.senarai_sesi {
            kalau sesi.token_id == token_id {
                didapati = betul;

                kalau Masa::masa_unix() < sesi.masa_tamat {
                    biar sesi_segar = {
                        token_id: sesi.token_id,
                        pengguna_id: sesi.pengguna_id,
                        skop: sesi.skop,
                        masa_cipta: sesi.masa_cipta,
                        masa_tamat: sesi.masa_tamat + tambah_saat,
                        alamat_ip: sesi.alamat_ip,
                        agen_pengguna: sesi.agen_pengguna,
                        aktif: sesi.aktif,
                    };
                    senarai_baru = senarai_baru + [sesi_segar];
                } lain {
                    senarai_baru = senarai_baru + [sesi];
                }
            } lain {
                senarai_baru = senarai_baru + [sesi];
            }
        }

        kalau didapati {
            kemaskini_rekod_pengguna(rekod.pengguna_id, senarai_baru);
            pulang betul;
        }
    }

    pulang salah;
}

/// Terminate session
fungsi tamatkan_sesi(token_id: Teks) -> Benar kesan Bersih {
    untuk rekod dalam stor_sesi {
        biar senarai_baru = [];

        untuk sesi dalam rekod.senarai_sesi {
            kalau sesi.token_id != token_id {
                senarai_baru = senarai_baru + [sesi];
            }
        }

        kalau panjang(senarai_baru) < panjang(rekod.senarai_sesi) {
            kemaskini_rekod_pengguna(rekod.pengguna_id, senarai_baru);
            pulang betul;
        }
    }

    pulang salah;
}

/// Terminate all sessions for user (logout)
fungsi tamatkan_semua_sesi(pengguna_id: Teks) -> kesan Bersih {
    biar stor_baru = [];

    untuk rekod dalam stor_sesi {
        kalau rekod.pengguna_id != pengguna_id {
            stor_baru = stor_baru + [rekod];
        }
    }

    stor_sesi = stor_baru;
}

/// Clean up expired sessions
fungsi bersih_sesi_tamat() -> kesan Bersih {
    biar masa_sekarang = Masa::masa_unix();

    untuk rekod dalam stor_sesi {
        biar senarai_sah = [];

        untuk sesi dalam rekod.senarai_sesi {
            kalau masa_sekarang <= sesi.masa_tamat && sesi.aktif {
                senarai_sah = senarai_sah + [sesi];
            }
        }

        kalau panjang(senarai_sah) == 0 {
            // Remove user record if no active sessions
            stor_sesi = saring_pengguna(stor_sesi, rekod.pengguna_id);
        } lain {
            kemaskini_rekod_pengguna(rekod.pengguna_id, senarai_sah);
        }
    }
}

/// Get active sessions for user
fungsi dapat_sesi_aktif(pengguna_id: Teks) -> Senarai<Sesi> kesan Bersih {
    biar masa_sekarang = Masa::masa_unix();

    untuk rekod dalam stor_sesi {
        kalau rekod.pengguna_id == pengguna_id {
            biar senarai_aktif = [];

            untuk sesi dalam rekod.senarai_sesi {
                kalau sesi.aktif && masa_sekarang <= sesi.masa_tamat {
                    senarai_aktif = senarai_aktif + [sesi];
                }
            }

            pulang senarai_aktif;
        }
    }

    pulang [];
}

/// Demo: Protected API endpoint
awam fungsi uruskan_permintaan_dilindungi(
    token_id: Teks,
    skop_perlu: Teks,
    data_permintaan: Teks
) -> Mungkin<Teks> kesan Bersih {
    biar mungkin_sesi = sahkan_sesi(token_id);

    padan mungkin_sesi {
        Ada(sesi) => {
            kalau ada_skop(sesi, skop_perlu) {
                cetak_baris(format!("Permintaan dari {} dibenarkan", sesi.pengguna_id));
                pulang Ada("{\"berjaya\":true}");
            } lain {
                cetak_baris("Skop tidak mencukupi");
                pulang Tiada;
            }
        },
        Tiada => {
            cetak_baris("Sesi tidak sah atau tamat");
            pulang Tiada;
        },
    };
}

// Helper functions
fungsi cari_rekod_pengguna(pengguna_id: Teks) -> Mungkin<RekodSesi> kesan Bersih {
    untuk rekod dalam stor_sesi {
        kalau rekod.pengguna_id == pengguna_id {
            pulang Ada(rekod);
        }
    }
    pulang Tiada;
}

fungsi kemaskini_rekod_pengguna(pengguna_id: Teks, senarai_sesi: Senarai<Sesi>) -> kesan Bersih {
    biar stor_baru = [];

    untuk rekod dalam stor_sesi {
        kalau rekod.pengguna_id == pengguna_id {
            stor_baru = stor_baru + [{
                pengguna_id: rekod.pengguna_id,
                senarai_sesi: senarai_sesi,
                sesi_maksimal: rekod.sesi_maksimal,
            }];
        } lain {
            stor_baru = stor_baru + [rekod];
        }
    }

    stor_sesi = stor_baru;
}

fungsi hapus_sesi_tertua(senarai: Senarai<Sesi>) -> Senarai<Sesi> kesan Bersih {
    kalau panjang(senarai) == 0 {
        pulang [];
    }

    biar sesi_tertua_idx = 0;
    biar masa_terawal = senarai[0].masa_cipta;

    untuk i dari 1 hingga panjang(senarai) {
        kalau senarai[i].masa_cipta < masa_terawal {
            masa_terawal = senarai[i].masa_cipta;
            sesi_tertua_idx = i;
        }
    }

    biar hasil = [];
    untuk i dari 0 hingga panjang(senarai) {
        kalau i != sesi_tertua_idx {
            hasil = hasil + [senarai[i]];
        }
    }

    pulang hasil;
}

fungsi saring_pengguna(senarai: Senarai<RekodSesi>, pengguna_id: Teks) -> Senarai<RekodSesi> kesan Bersih {
    biar hasil = [];
    untuk rekod dalam senarai {
        kalau rekod.pengguna_id != pengguna_id {
            hasil = hasil + [rekod];
        }
    }
    pulang hasil;
}

fungsi panjang(senarai: Senarai<T>) -> Nombor kesan Bersih {
    pulang 0;
}

fungsi format(s: Teks, arg: Teks) -> Teks kesan Bersih {
    pulang s;
}

modul Masa {
    fungsi masa_unix() -> Nombor kesan Bersih {
        pulang 0;
    }
}

// === 07_EXAMPLES/03_applications/todo_app.rii ===
/// todo_app.rii
/// Simple todo list application with persistence
/// Demonstrates SistemFail effect for file I/O operations
///
/// Features:
/// - Task management (add, complete, delete)
/// - File-based persistence
/// - Task filtering and listing

modul aplikasi_tugas;

guna std::fail;
guna std::senarai;
guna std::teks;
guna std::masa;

jenis Tugas = {
    id: Nombor,
    tajuk: Teks,
    perihalan: Teks,
    selesai: Benar,
    masa_cipta: Nombor,
    masa_siap: Mungkin<Nombor>,
};

/// Load tasks from file
/// Kesan: SistemFail (file operations, parsing)
fungsi muat_tugas_dari_fail(laluan_fail: Teks) -> Mungkin<Senarai<Tugas>> kesan SistemFail {
    biar hasil_baca = coba SistemFail::baca_fail(laluan_fail);

    padan hasil_baca {
        Berjaya(kandungan) => {
            biar tugas_senarai = huraikan_tugas(kandungan);
            pulang Ada(tugas_senarai);
        },
        Kegagalan(_ralat) => {
            laku SistemFail::log_ralat("Tidak dapat membaca fail tugas");
            pulang Tiada;
        },
    };
}

/// Save tasks to file
/// Kesan: SistemFail (file write operations)
fungsi simpan_tugas_ke_fail(laluan_fail: Teks, tugas_senarai: Senarai<Tugas>) -> kesan SistemFail {
    biar kandungan = enkod_tugas(tugas_senarai);
    biar hasil_tulis = coba SistemFail::tulis_fail(laluan_fail, kandungan);

    padan hasil_tulis {
        Berjaya(_) => {
            laku SistemFail::log_maklumat("Tugas disimpan berjaya");
        },
        Kegagalan(ralat) => {
            laku SistemFail::log_ralat(format!("Gagal menyimpan tugas: {}", ralat));
        },
    };
}

/// Add new task
fungsi tambah_tugas(
    ubah tugas_senarai: Senarai<Tugas>,
    tajuk: Teks,
    perihalan: Teks
) -> Senarai<Tugas> kesan Bersih {
    biar id_baru = cari_max_id(tugas_senarai) + 1;
    biar tugas_baru = {
        id: id_baru,
        tajuk: tajuk,
        perihalan: perihalan,
        selesai: salah,
        masa_cipta: Masa::masa_unix(),
        masa_siap: Tiada,
    };

    pulang tugas_senarai + [tugas_baru];
}

/// Mark task as complete
fungsi tandakan_selesai(
    ubah tugas_senarai: Senarai<Tugas>,
    id_tugas: Nombor
) -> Senarai<Tugas> kesan Bersih {
    biar hasil = [];

    untuk tugas dalam tugas_senarai {
        kalau tugas.id == id_tugas {
            biar tugas_dikemaskini = {
                id: tugas.id,
                tajuk: tugas.tajuk,
                perihalan: tugas.perihalan,
                selesai: betul,
                masa_cipta: tugas.masa_cipta,
                masa_siap: Ada(Masa::masa_unix()),
            };
            hasil = hasil + [tugas_dikemaskini];
        } lain {
            hasil = hasil + [tugas];
        }
    }

    pulang hasil;
}

/// Delete task
fungsi padam_tugas(
    ubah tugas_senarai: Senarai<Tugas>,
    id_tugas: Nombor
) -> Senarai<Tugas> kesan Bersih {
    biar hasil = [];

    untuk tugas dalam tugas_senarai {
        kalau tugas.id != id_tugas {
            hasil = hasil + [tugas];
        }
    }

    pulang hasil;
}

/// Filter incomplete tasks
fungsi tugas_belum_siap(tugas_senarai: Senarai<Tugas>) -> Senarai<Tugas> kesan Bersih {
    biar hasil = [];

    untuk tugas dalam tugas_senarai {
        kalau tugas.selesai == salah {
            hasil = hasil + [tugas];
        }
    }

    pulang hasil;
}

/// Filter completed tasks
fungsi tugas_sudah_siap(tugas_senarai: Senarai<Tugas>) -> Senarai<Tugas> kesan Bersih {
    biar hasil = [];

    untuk tugas dalam tugas_senarai {
        kalau tugas.selesai == betul {
            hasil = hasil + [tugas];
        }
    }

    pulang hasil;
}

/// Display tasks
fungsi papar_tugas(tugas_senarai: Senarai<Tugas>) -> kesan Tulis {
    cetak_baris("=== SENARAI TUGAS ===");
    untuk tugas dalam tugas_senarai {
        biar status = kalau tugas.selesai { "[âœ“]" } lain { "[ ]" };
        cetak_baris(format!("{} #{} - {}", status, tugas.id, tugas.tajuk));
        cetak_baris(format!("   {}", tugas.perihalan));
    }
}

/// Interactive todo CLI
awam fungsi utama() -> kesan (SistemFail | Tulis) {
    biar laluan_fail = "tugas.json";

    // Load existing tasks
    biar tugas_senarai = padan muat_tugas_dari_fail(laluan_fail) {
        Ada(t) => t,
        Tiada => [],
    };

    cetak_baris("Selamat datang ke Aplikasi Tugas");

    ulang {
        cetak_baris("\nPilihan: [1] Tambah [2] Siap [3] Padam [4] Lihat [5] Keluar");
        biar pilihan = baca_baris();

        padan pilihan {
            "1" => {
                cetak_baris("Masukkan tajuk tugas:");
                biar tajuk = baca_baris();
                cetak_baris("Masukkan perihalan:");
                biar perihalan = baca_baris();
                tugas_senarai = tambah_tugas(tugas_senarai, tajuk, perihalan);
                simpan_tugas_ke_fail(laluan_fail, tugas_senarai);
            },
            "2" => {
                cetak_baris("Masukkan ID tugas untuk ditandakan siap:");
                biar id_str = baca_baris();
                biar id_tugas = parse_nombor(id_str);
                tugas_senarai = tandakan_selesai(tugas_senarai, id_tugas);
                simpan_tugas_ke_fail(laluan_fail, tugas_senarai);
            },
            "3" => {
                cetak_baris("Masukkan ID tugas untuk dipadamkan:");
                biar id_str = baca_baris();
                biar id_tugas = parse_nombor(id_str);
                tugas_senarai = padam_tugas(tugas_senarai, id_tugas);
                simpan_tugas_ke_fail(laluan_fail, tugas_senarai);
            },
            "4" => {
                papar_tugas(tugas_senarai);
            },
            "5" => {
                cetak_baris("Selamat tinggal!");
                ulang_akhir;
            },
            _ => {
                cetak_baris("Pilihan tidak sah");
            },
        };
    };
}

// Helper functions
fungsi cari_max_id(tugas_senarai: Senarai<Tugas>) -> Nombor kesan Bersih {
    biar max_id = 0;
    untuk tugas dalam tugas_senarai {
        kalau tugas.id > max_id {
            max_id = tugas.id;
        }
    }
    pulang max_id;
}

fungsi huraikan_tugas(kandungan: Teks) -> Senarai<Tugas> kesan Bersih {
    pulang [];
}

fungsi enkod_tugas(tugas_senarai: Senarai<Tugas>) -> Teks kesan Bersih {
    pulang "";
}

fungsi baca_baris() -> Teks kesan Tulis {
    pulang "";
}

fungsi parse_nombor(teks: Teks) -> Nombor kesan Bersih {
    pulang 0;
}

// === 07_EXAMPLES/03_applications/web_server.rii ===
/// web_server.rii
/// Simple HTTP server implementation demonstrating Rangkaian effect
/// Shows network socket handling with RIINA security properties
///
/// Features:
/// - TCP server listening on localhost:8080
/// - Request parsing and response generation
/// - Demonstrates Rangkaian effect for network operations
/// - Error handling with SistemFail effect

modul pemserver_rangkaian;

guna std::rangkaian;
guna std::fail;
guna std::senarai;
guna std::teks;

/// HTTP request type
jenis Permintaan = {
    kaedah: Teks,
    laluan: Teks,
    pengepala: Senarai<(Teks, Teks)>,
};

/// HTTP response type
jenis Balasan = {
    kod: Nombor,
    jenis_kandungan: Teks,
    jasad: Teks,
};

/// Parse incoming HTTP request
/// Kesan: Baca (reads from socket buffer)
fungsi huraikan_permintaan(data_mentah: Teks) -> Mungkin<Permintaan> kesan Bersih {
    // Simple parsing - extract method, path, headers
    biar baris = split_baris(data_mentah);
    kalau panjang(baris) == 0 {
        pulang Tiada;
    }

    biar baris_pertama = baris[0];
    biar bahagian = split_ruang(baris_pertama);

    kalau panjang(bahagian) >= 2 {
        pulang Ada({
            kaedah: bahagian[0],
            laluan: bahagian[1],
            pengepala: [],
        });
    } lain {
        pulang Tiada;
    }
}

/// Generate HTTP response
/// Kesan: Bersih (pure computation)
fungsi hasilkan_balasan(kod_status: Nombor, jasad: Teks) -> Balasan kesan Bersih {
    pulang {
        kod: kod_status,
        jenis_kandungan: "text/plain",
        jasad: jasad,
    };
}

/// Encode response to HTTP format
fungsi enkod_balasan(balasan: Balasan) -> Teks kesan Bersih {
    biar baris_status = format!("HTTP/1.1 {} OK\r\n", balasan.kod);
    biar pengepala_jenis = format!("Content-Type: {}\r\n", balasan.jenis_kandungan);
    biar pengepala_panjang = format!("Content-Length: {}\r\n", panjang(balasan.jasad));

    pulang baris_status + pengepala_jenis + pengepala_panjang + "\r\n" + balasan.jasad;
}

/// Handle single client connection
/// Kesan: Rangkaian + SistemFail (network operations, I/O errors)
fungsi uruskan_sambungan(sambungan_socket: Rangkaian::Socket) -> kesan (Rangkaian | SistemFail) {
    // Read request from socket
    biar hasil_baca = coba Rangkaian::baca(sambungan_socket, 4096);

    padan hasil_baca {
        Berjaya(data) => {
            // Parse HTTP request
            biar permintaan = huraikan_permintaan(data);
            padan permintaan {
                Ada(req) => {
                    // Generate response based on path
                    biar balasan = kalau req.laluan == "/" {
                        hasilkan_balasan(200, "Selamat datang ke pemserver!")
                    } lain kalau req.laluan == "/api/kesihatan" {
                        hasilkan_balasan(200, "{\"status\":\"baik\"}")
                    } lain {
                        hasilkan_balasan(404, "Laluan tidak ditemui")
                    };

                    biar teks_balasan = enkod_balasan(balasan);
                    laku Rangkaian::tulis(sambungan_socket, teks_balasan);
                },
                Tiada => {
                    laku Rangkaian::tulis(sambungan_socket, "HTTP/1.1 400 Bad Request\r\n\r\n");
                },
            };
        },
        Kegagalan(_ralat) => {
            laku SistemFail::log_ralat("Gagal membaca dari socket");
        },
    };
}

/// Main server loop
/// Kesan: Rangkaian + SistemFail
awam fungsi utama() -> kesan (Rangkaian | SistemFail) {
    // Create server socket
    biar socket_pelayan = Rangkaian::buat_pelayan("127.0.0.1", 8080);

    cetak_baris("Pemserver berjalan di http://127.0.0.1:8080");

    // Accept connections in loop
    ulang {
        biar hasil_terima = coba Rangkaian::terima_sambungan(socket_pelayan);
        padan hasil_terima {
            Berjaya(sambungan) => {
                uruskan_sambungan(sambungan);
                Rangkaian::tutup_sambungan(sambungan);
            },
            Kegagalan(ralat) => {
                cetak_baris(format!("Ralat menerima sambungan: {}", ralat));
                ulang_akhir;
            },
        };
    };
}

// Helper functions
fungsi split_baris(teks: Teks) -> Senarai<Teks> kesan Bersih {
    pulang teks::pecah_oleh(teks, "\r\n");
}

fungsi split_ruang(teks: Teks) -> Senarai<Teks> kesan Bersih {
    pulang teks::pecah_oleh(teks, " ");
}

fungsi panjang(senarai: Senarai<T>) -> Nombor kesan Bersih {
    pulang senarai::panjang(senarai);
}

// === 07_EXAMPLES/04_compliance/ccpa_privacy.rii ===
/// ccpa_privacy.rii
/// CCPA (California Consumer Privacy Act) consumer rights implementation
/// Demonstrates data rights, opt-out, and sale restrictions
///
/// Security Level: Sistem
/// Compliance: California Civil Code 1798.100+

modul hak_privasi_ccpa;

guna std::teks;
guna std::senarai;
guna std::masa;

jenis DataKonsumen = {
    id_konsumen: Teks,
    nama: Teks,
    emel: Teks,
    telefon: Teks,
    alamat: Teks,
    sejarah_pembelian: Senarai<Teks>,
};

jenis PreferensiBerjual = {
    konsumen_id: Teks,
    berjual_kepada_pihak_ketiga: Benar,
    berjual_untuk_tujuan_perniagaan: Benar,
    masa_dipilih_keluar: Nombor,
};

jenis PermintiKonsumen =
    | AKSES
    | PENGHAPUSAN
    | OPT_OUT_PENJUALAN
    | JANGAN_JUAL_DATA
    | TIDAK_MEMBEDAKAN;

biar ubah data_konsumen: Senarai<DataKonsumen> = [];
biar ubah preferensi_jual: Senarai<PreferensiBerjual> = [];

/// CCPA Section 1798.100: Right to know
fungsi hak_tahu_data_apa(id_konsumen: Teks) -> Teks kesan Bersih {
    cetak_baris(format!("Memproses hak tahu untuk {}", id_konsumen));

    biar data_dikumpul = [
        "Identifikasi: nama, emel, telefon",
        "Komersial: sejarah pembelian",
        "Internet: aktivitas penjelajahan",
        "Lokasi: data GPS",
    ];

    biar laporan = "DATA YANG DIKUMPUL:\n";

    untuk jenis_data dalam data_dikumpul {
        laporan = laporan + "- " + jenis_data + "\n";
    }

    cetak_baris(laporan);
    pulang laporan;
}

/// CCPA Section 1798.105: Right to delete
fungsi hak_penghapusan(id_konsumen: Teks) -> Benar kesan Bersih {
    cetak_baris(format!("Memproses permintaan penghapusan untuk {}", id_konsumen));

    biar data_baru = [];
    biar dihapus = salah;

    untuk konsumen dalam data_konsumen {
        kalau konsumen.id_konsumen != id_konsumen {
            data_baru = data_baru + [konsumen];
        } lain {
            dihapus = betul;
            cetak_baris("Data konsumen dihapus dari sistem utama");
        }
    }

    data_konsumen = data_baru;

    kalau dihapus {
        cetak_baris("Pemberitahuan: Vendor pihak ketiga diminta untuk menghapus");
    }

    pulang dihapus;
}

/// CCPA Section 1798.120: Right to opt-out of sale
fungsi hak_tolak_penjualan(id_konsumen: Teks) -> Benar kesan Bersih {
    cetak_baris(format!("Memproses tolak penjualan data untuk {}", id_konsumen));

    biar preferensi = {
        konsumen_id: id_konsumen,
        berjual_kepada_pihak_ketiga: salah,
        berjual_untuk_tujuan_perniagaan: salah,
        masa_dipilih_keluar: Masa::masa_unix(),
    };

    preferensi_jual = preferensi_jual + [preferensi];

    cetak_baris("Pilihan keluar tercatat - Data TIDAK akan dijual");
    pulang betul;
}

/// CCPA Section 1798.140: Do Not Sell my Personal Information
fungsi cek_jangan_jual_sinyal(id_konsumen: Teks) -> Benar kesan Bersih {
    // Check if consumer has opted out via Global Opt-Out Signal
    untuk preferensi dalam preferensi_jual {
        kalau preferensi.konsumen_id == id_konsumen {
            kalau !preferensi.berjual_kepada_pihak_ketiga {
                cetak_baris("Sinyal: Jangan jual data diterima dan ditaati");
                pulang betul;
            }
        }
    }

    cetak_baris("Tidak ada sinyal jangan jual");
    pulang salah;
}

/// CCPA Section 1798.150: Do not discriminate
fungsi semak_diskriminasi(id_konsumen: Teks) -> Benar kesan Bersih {
    // Verify: No penalties for exercising CCPA rights
    cetak_baris("Menyemak bahwa hak CCPA tidak menyebabkan diskriminasi");
    cetak_baris("- Harga sama untuk yang keluar vs. tidak");
    cetak_baris("- Kualitas layanan sama");
    cetak_baris("- Tidak ditolak layanan karena menjalankan hak");

    pulang betul;
}

/// Authorized agent handling
fungsi proses_permintaan_agen(id_konsumen: Teks, id_agen: Teks) -> Benar kesan Bersih {
    // CCPA: Consumer can use authorized agent
    cetak_baris(format!("Permintaan dari agen {} untuk konsumen {}", id_agen, id_konsumen));

    // Verify power of attorney or signed authorization
    cetak_baris("Memverifikasi dokumentasi agen...");

    kalau teks::mengandungi(id_agen, "agen_sah") {
        cetak_baris("Agen disahkan");
        pulang betul;
    }

    cetak_baris("Otorisasi tidak sah");
    pulang salah;
}

/// California Privacy Rights for Minors (COPPA-like)
fungsi proteksi_minor(id_konsumen: Teks, umur: Nombor) -> kesan Bersih {
    kalau umur < 13 {
        cetak_baris("COPPA: Persetujuan orang tua diperlukan untuk data pelajar");
    } lain kalau umur < 16 {
        cetak_baris("CCPA: Konsumen minor dapat memilih keluar penjualan data");
        hak_tolak_penjualan(id_konsumen);
    }
}

/// Annual privacy notice requirement
fungsi kirim_pemberitahuan_privasi_tahunan() -> kesan Bersih {
    cetak_baris("PEMBERITAHUAN PRIVASI CCPA:");
    cetak_baris("Hak-hak Anda:");
    cetak_baris("1. Hak Tahu: Tahu data apa yang kami kumpulkan");
    cetak_baris("2. Hak Hapus: Minta kami menghapus data Anda");
    cetak_baris("3. Hak Tolak: Tolak penjualan data pribadi");
    cetak_baris("4. Hak Jangan Diskriminasi: Sama perlakuan jika menjalankan hak");
    cetak_baris("5. Jangan Jual: Global opt-out signal didukung");
}

/// Data sale transparency
fungsi laporkan_penjualan_data() -> Teks kesan Bersih {
    biar laporan = "LAPORAN PENJUALAN DATA:\n";

    laporan = laporan + "Kategori Data Dijual:\n";
    laporan = laporan + "- Identifikasi: dijual ke pemilik iklan\n";
    laporan = laporan + "- Komersial: dijual ke analis data\n";
    laporan = laporan + "- Internet: dijual ke jaringan iklan\n";

    laporan = laporan + "\nPihak Ketiga yang Membeli:\n";
    laporan = laporan + "- Ad Network Partners\n";
    laporan = laporan + "- Data Brokers\n";
    laporan = laporan + "- Marketing Platforms\n";

    laporan = laporan + "\nTujuan Penggunaan:\n";
    laporan = laporan + "- Pemasaran tertarget\n";
    laporan = laporan + "- Pembuatan profil\n";
    laporan = laporan + "- Penjualan kembali\n";

    pulang laporan;
}

awam fungsi utama() -> kesan Bersih {
    cetak_baris("=== KEPATUHAN HAK PRIVASI CCPA ===");

    biar id_konsumen = "konsumen_12345";

    // Consumer exercises rights
    cetak_baris("\n[Konsumen menjalankan hak CCPA]");

    hak_tahu_data_apa(id_konsumen);
    cetak_baris("");

    hak_tolak_penjualan(id_konsumen);
    cetak_baris("");

    cek_jangan_jual_sinyal(id_konsumen);
    cetak_baris("");

    semak_diskriminasi(id_konsumen);
    cetak_baris("");

    // Show data sale transparency
    biar laporan = laporkan_penjualan_data();
    cetak_baris(laporan);

    // Annual notice
    kirim_pemberitahuan_privasi_tahunan();
}

// Helper functions
fungsi teks::mengandungi(teks: Teks, cari: Teks) -> Benar kesan Bersih {
    pulang betul;
}

fungsi format(s: Teks, arg: Teks) -> Teks kesan Bersih {
    pulang s;
}

fungsi panjang(senarai: Senarai<T>) -> Nombor kesan Bersih {
    pulang 0;
}

modul Masa {
    fungsi masa_unix() -> Nombor kesan Bersih {
        pulang 0;
    }
}

// === 07_EXAMPLES/04_compliance/data_residency.rii ===
/// data_residency.rii
/// Data residency enforcement and geolocation verification
/// Demonstrates data sovereignty and regional compliance requirements
///
/// Security Level: Sistem
/// Compliance: GDPR, PDPA, localization laws

modul penguatkuasaan_tempat_tinggal_data;

guna std::teks;
guna std::senarai;

/// Approved data residency regions
jenis KawasanTempat =
    | EU        // GDPR
    | MY        // PDPA
    | APAC      // Asia-Pacific
    | AMERICAS  // North/South America
    | GLOBAL;   // No restriction

/// Data subject and their residency requirement
jenis SubjekData = {
    id_subjek: Teks,
    nama: Teks,
    lokasi_asal: KawasanTempat,
    klasifikasi_data: Teks,
    tempat_tinggal_disyaratkan: KawasanTempat,
};

/// Storage location and compliance
jenis LokasiBayaran = {
    id_pusat: Teks,
    nama: Teks,
    region: KawasanTempat,
    negara: Teks,
    kepatuhan: Senarai<Teks>,  // GDPR, PDPA, etc
    dienkripsi: Benar,
};

biar ubah subjek_data: Senarai<SubjekData> = [];
biar ubah lokasi_bayaran: Senarai<LokasiBayaran> = [];

/// Verify data storage location complies with residency
fungsi sahkan_kepatuhan_tempat_tinggal(
    lokasi_penyimpanan: KawasanTempat,
    tempat_tinggal_perlu: KawasanTempat
) -> Benar kesan Bersih {
    padan (lokasi_penyimpanan, tempat_tinggal_perlu) {
        (EU, EU) => betul,
        (MY, MY) => betul,
        (GLOBAL, _) => betul,          // Global OK for any
        (APAC, APAC) => betul,
        (AMERICAS, AMERICAS) => betul,

        // Cross-region transfers need special approval
        (EU, MY) => salah,             // GDPR â†’ PDPA: Invalid
        (MY, EU) => salah,             // PDPA â†’ GDPR: Invalid
        (EU, GLOBAL) => salah,         // Can't export EU data to global
        (MY, GLOBAL) => salah,         // Can't export MY data to global

        _ => salah,
    };
}

/// GDPR Article 44: Transfer mechanisms
fungsi sahkan_mekanisme_pemindahan_gdpr(
    asal: KawasanTempat,
    destinasi: KawasanTempat
) -> Benar kesan Bersih {
    kalau asal != EU {
        pulang betul; // Only applies to EU data
    }

    padan destinasi {
        EU => betul,  // EU to EU: OK

        // Requires "adequacy decision" from European Commission
        MY => {
            cetak_baris("AMARAN: MY tidak memiliki keputusan kecukupan EU");
            cetak_baris("Diperlukan: Standard Contractual Clauses (SCC)");
            pulang salah;
        },

        // Requires adequacy decision
        APAC => {
            cetak_baris("AMARAN: APAC tidak memiliki keputusan kecukupan EU");
            cetak_baris("Diperlukan: Binding Corporate Rules (BCR)");
            pulang salah;
        },

        AMERICAS => {
            cetak_baris("AMARAN: Pemindahan ke Amerika memerlukan Privacy Shield");
            pulang salah;
        },

        GLOBAL => {
            cetak_baris("AMARAN: Tidak dapat mengekspor data EU ke global");
            pulang salah;
        },
    };
}

/// PDPA Requirement: Malaysia data localization
fungsi sahkan_pelokalan_pdpa(lokasi: KawasanTempat) -> Benar kesan Bersih {
    // PDPA requires certain data stored in Malaysia
    kalau lokasi == MY {
        cetak_baris("PDPA: Data disimpan di Malaysia âœ“");
        pulang betul;
    }

    cetak_baris("AMARAN: Data tidak di Malaysia");
    cetak_baris("PDPA mungkin memerlukan penyimpanan lokal");

    pulang salah;
}

/// Check data sovereignty restrictions
fungsi semak_kedaulatan_data(
    id_subjek: Teks,
    lokasi_bayaran: KawasanTempat
) -> (Benar, Teks) kesan Bersih {
    // Find subject's residency requirement
    biar mungkin_subjek = cari_subjek(id_subjek);

    padan mungkin_subjek {
        Ada(subjek) => {
            biar sah = sahkan_kepatuhan_tempat_tinggal(lokasi_bayaran, subjek.tempat_tinggal_disyaratkan);

            kalau sah {
                pulang (betul, "Penyimpanan sah");
            } lain {
                biar pesan = format!(
                    "Pelanggaran: Data {} harus di {} tapi disimpan di {}",
                    id_subjek,
                    kawasan_ke_teks(subjek.tempat_tinggal_disyaratkan),
                    kawasan_ke_teks(lokasi_bayaran)
                );
                pulang (salah, pesan);
            }
        },
        Tiada => {
            pulang (salah, "Subjek data tidak ditemukan");
        },
    };
}

/// Encrypt data in transit between regions
fungsi enkripsi_pemindahan_regional(
    asal: KawasanTempat,
    destinasi: KawasanTempat,
    adalah_eu: Benar
) -> Benar kesan Bersih {
    kalau adalah_eu && destinasi != EU {
        cetak_baris("Enkripsi transit wajib untuk data EU keluar region");
        cetak_baris("Menggunakan: AES-256-GCM + TLS 1.3");
        pulang betul;
    }

    cetak_baris("Enkripsi transit: TLS 1.3");
    pulang betul;
}

/// Geo-redundancy with compliance
fungsi rencana_geo_redundansi() -> Senarai<Teks> kesan Bersih {
    biar rencana = [
        "Data EU: Replika di EU hanya (Jerman + Prancis)",
        "Data MY: Replika di Malaysia + SG untuk backup",
        "Data APAC: Replika di wilayah APAC saja",
    ];

    pulang rencana;
}

/// Audit trail for data movements
fungsi catatkan_pergerakan_data(
    id_subjek: Teks,
    asal: KawasanTempat,
    destinasi: KawasanTempat,
    alasan: Teks
) -> kesan Bersih {
    cetak_baris(format!(
        "AUDIT: Data {} dipindahkan {} â†’ {} ({})",
        id_subjek,
        kawasan_ke_teks(asal),
        kawasan_ke_teks(destinasi),
        alasan
    ));
}

/// Deletion from specific regions
fungsi padamkan_dari_kawasan(
    id_subjek: Teks,
    kawasan: KawasanTempat
) -> Benar kesan Bersih {
    cetak_baris(format!(
        "Menghapus data {} dari {}",
        id_subjek,
        kawasan_ke_teks(kawasan)
    ));

    cetak_baris("Verifikasi penghapusan aman dari backup");
    cetak_baris("Konfirmasi dari admin regional diperlukan");

    pulang betul;
}

awam fungsi utama() -> kesan Bersih {
    cetak_baris("=== PENGUATKUASAAN TEMPAT TINGGAL DATA ===\n");

    // Test case 1: EU citizen data
    cetak_baris("[Kes 1: Warga negara EU, penyimpanan di EU]");
    biar sah_1 = sahkan_kepatuhan_tempat_tinggal(EU, EU);
    cetak_baris(format!("Kepatuhan: {}\n", sah_1));

    // Test case 2: EU citizen data stored outside EU
    cetak_baris("[Kes 2: Warga negara EU, coba penyimpanan MY]");
    biar sah_2 = sahkan_mekanisme_pemindahan_gdpr(EU, MY);
    cetak_baris(format!("Kepatuhan: {}\n", sah_2));

    // Test case 3: Malaysia citizen
    cetak_baris("[Kes 3: Warga negara MY, penyimpanan MY]");
    biar sah_3 = sahkan_pelokalan_pdpa(MY);
    cetak_baris(format!("Kepatuhan PDPA: {}\n", sah_3));

    // Geo-redundancy plan
    cetak_baris("=== RENCANA GEO-REDUNDANSI ===");
    biar rencana = rencana_geo_redundansi();
    untuk rancangan dalam rencana {
        cetak_baris("â€¢ " + rancangan);
    }

    cetak_baris("\n=== RINGKASAN ===");
    cetak_baris("âœ“ Penyimpanan regional disegmentasi");
    cetak_baris("âœ“ Pemindahan silang-region dienkripsi");
    cetak_baris("âœ“ Kepatuhan regulasi ditegakkan");
    cetak_baris("âœ“ Jejak audit penuh dipertahankan");
}

// Helper functions
fungsi cari_subjek(id: Teks) -> Mungkin<SubjekData> kesan Bersih {
    pulang Tiada;
}

fungsi kawasan_ke_teks(kawasan: KawasanTempat) -> Teks kesan Bersih {
    padan kawasan {
        EU => "Uni Eropa",
        MY => "Malaysia",
        APAC => "Asia-Pasifik",
        AMERICAS => "Benua Amerika",
        GLOBAL => "Global",
    };
}

fungsi format(s: Teks, arg: Teks) -> Teks kesan Bersih {
    pulang s;
}

fungsi panjang(senarai: Senarai<T>) -> Nombor kesan Bersih {
    pulang 0;
}

// === 07_EXAMPLES/04_compliance/ferpa_student.rii ===
/// ferpa_student.rii
/// FERPA (Family Educational Rights and Privacy Act) student records
/// Demonstrates educational data privacy and parental rights
///
/// Security Level: Sistem
/// Compliance: 20 U.S.C. Â§ 1232g

modul privasi_rekod_pelajar;

guna std::teks;
guna std::senarai;

jenis RekodPelajar = {
    id_pelajar: Teks,
    nama: Teks,
    no_id_keluarga: Teks,
    tarikh_lahir: Teks,
    gred_semasa: Senarai<(Teks, Teks)>,  // subject, grade
    rekod_disiplin: Senarai<Teks>,
    maklumat_kesihatan: Teks,
};

jenis IzinAkses = {
    pihak_pihak: Teks,        // parent, student (18+), pendidik
    jenis_akses: Teks,        // baca, ubah, lihat_gred
    tarikh_berakhir: Nombor,
    dibatasi_pada: Senarai<Teks>,  // specific fields
};

biar ubah rekod_pelajar: Senarai<RekodPelajar> = [];
biar ubah izin_akses: Senarai<IzinAkses> = [];

/// FERPA: Only authorized parties can access student records
fungsi semak_akses_berwenang(
    id_pelajar: Teks,
    peminta: Teks,
    jenis_akses: Teks
) -> Benar kesan Bersih {
    // School officials with legitimate educational interest
    biar peminat_sah = [
        "guru", "pentadbir", "kaunselor", "pekerja_kesihatan",
        // Parents if student < 18
        // Student if student >= 18
    ];

    cetak_baris(format!("Menyemak akses untuk {} ke rekod {}", peminta, id_pelajar));

    kalau teks::mengandungi(peminat_sah, peminta) {
        cetak_baris("Akses dibenarkan");
        pulang betul;
    }

    cetak_baris("AKSES DITOLAK: Tidak berwenang");
    pulang salah;
}

/// Record student access to their own records (age 18+)
fungsi berikan_akses_pelajar_dewasa(id_pelajar: Teks, umur: Nombor) -> Benar kesan Bersih {
    // FERPA: Students age 18+ have right to access own records
    kalau umur >= 18 {
        cetak_baris(format!("Pelajar {} diberi akses ke rekod sendiri", id_pelajar));
        pulang betul;
    }

    cetak_baris("Pelajar < 18: Akses orang tua diperlukan");
    pulang salah;
}

/// FERPA: Parent/guardian access rights
fungsi berikan_akses_ibu_bapa(
    id_pelajar: Teks,
    id_ibu_bapa: Teks
) -> Benar kesan Bersih {
    // Verify parent/guardian relationship
    biar mungkin_pelajar = cari_pelajar(id_pelajar);

    padan mungkin_pelajar {
        Ada(pelajar) => {
            // Check if ID matches (simplified)
            kalau pelajar.no_id_keluarga == id_ibu_bapa {
                cetak_baris(format!("Akses orang tua disetujui untuk {}", id_pelajar));
                pulang betul;
            }
        },
        Tiada => {},
    };

    cetak_baris("DITOLAK: Hubungan orang tua tidak dapat disahkan");
    pulang salah;
}

/// Directory information opt-out
fungsi daftar_keberatan_informasi_direktori(
    id_pelajar: Teks,
    jenis_informasi: Teks
) -> kesan Bersih {
    // FERPA allows students/parents to opt-out of directory info
    cetak_baris(format!(
        "Keberatan tercatat: {} tidak boleh dalam direktori {}",
        id_pelajar,
        jenis_informasi
    ));
}

/// Records not subject to FERPA
fungsi cari_pengecualian_ferpa(jenis_rekod: Teks) -> Benar kesan Bersih {
    biar bukan_ferpa = [
        "catatan_polisi",         // Law enforcement records
        "catatan_kesehatan_pribadi", // Personal health records
        "catatan_kerja",          // Employment records
    ];

    untuk eksklusif dalam bukan_ferpa {
        kalau eksklusif == jenis_rekod {
            cetak_baris(format!("{} BUKAN dibatasi FERPA", jenis_rekod));
            pulang betul;
        }
    }

    cetak_baris(format!("{} DIBATASI oleh FERPA", jenis_rekod));
    pulang salah;
}

/// Audit trail for record access
fungsi catat_akses_rekod(
    id_pelajar: Teks,
    peminta: Teks,
    jenis_data: Teks
) -> kesan Bersih {
    cetak_baris(format!(
        "LOG: {} mengakses {} (pelajar {})",
        peminta,
        jenis_data,
        id_pelajar
    ));
}

/// Amendment request (right to challenge inaccurate records)
fungsi proses_permintaan_perbaikan(
    id_pelajar: Teks,
    lapangan_salah: Teks,
    nilai_benar: Teks
) -> Benar kesan Bersih {
    // FERPA: Right to amend inaccurate info
    cetak_baris(format!(
        "Permintaan perbaikan untuk pelajar {}: {} -> {}",
        id_pelajar,
        lapangan_salah,
        nilai_benar
    ));

    // In implementation: verify correction, update record, notify parties
    cetak_baris("Perbaikan tercatat dan pemberitahuan dikirim");
    pulang betul;
}

/// Third-party disclosure with consent
fungsi lepaskan_rekod_kepada_pihak_ketiga(
    id_pelajar: Teks,
    organisasi: Teks,
    ada_persetujuan: Benar
) -> Benar kesan Bersih {
    // FERPA: Can't release to third party without consent
    kalau !ada_persetujuan {
        cetak_baris(format!("DITOLAK: Persetujuan diperlukan untuk melepaskan ke {}", organisasi));
        pulang salah;
    }

    cetak_baris(format!("Rekod dilepaskan ke {} dengan persetujuan", organisasi));
    cetak_baris("Pemberitahuan pelepasan tercatat");

    pulang betul;
}

/// Annual FERPA notification to students/parents
fungsi kirim_pemberitahuan_ferpa_tahunan() -> kesan Bersih {
    cetak_baris("PEMBERITAHUAN FERPA TAHUNAN");
    cetak_baris("- Hak akses ke rekod sendiri");
    cetak_baris("- Hak meminta perbaikan");
    cetak_baris("- Hak keberatan pelepasan info direktori");
    cetak_baris("- Hak mengajukan keluhan ke Kementerian Pendidikan");
}

awam fungsi utama() -> kesan Bersih {
    cetak_baris("=== KEPATUHAN PRIVASI PELAJAR FERPA ===");

    // Example: Teacher accessing student records
    biar akses_guru = semak_akses_berwenang("pelajar_123", "guru", "baca");
    cetak_baris(format!("Akses guru: {}", akses_guru));

    // Example: Parent accessing child's grades
    biar akses_ibu_bapa = berikan_akses_ibu_bapa("pelajar_123", "no_keluarga_456");
    cetak_baris(format!("Akses ibu bapa: {}", akses_ibu_bapa));

    // Example: Adult student (18+) self-access
    biar akses_diri = berikan_akses_pelajar_dewasa("pelajar_789", 19);
    cetak_baris(format!("Akses pelajar dewasa: {}", akses_diri));

    // Amendment request
    proses_permintaan_perbaikan("pelajar_123", "gred", "A");

    // Annual notification
    kirim_pemberitahuan_ferpa_tahunan();
}

// Helper functions
fungsi cari_pelajar(id: Teks) -> Mungkin<RekodPelajar> kesan Bersih {
    pulang Tiada;
}

fungsi teks::mengandungi(senarai: Senarai<Teks>, item: Teks) -> Benar kesan Bersih {
    pulang betul;
}

fungsi format(s: Teks, args: Senarai<T>) -> Teks kesan Bersih {
    pulang s;
}

// === 07_EXAMPLES/04_compliance/gdpr_consent.rii ===
/// gdpr_consent.rii
/// GDPR (General Data Protection Regulation) consent management
/// Demonstrates lawful basis, consent records, and right to erasure
///
/// Security Level: Sistem
/// Compliance: GDPR Articles 6, 7, 17

modul pengurusan_persetujuan_gdpr;

guna std::teks;
guna std::senarai;
guna std::masa;

jenis DasarSah =
    | PERSETUJUAN
    | KONTRAK
    | KEWAJIBAN_UNDANG_UNDANG
    | KEPENTINGAN_VITAL
    | TUGAS_AWAM
    | KEPENTINGAN_SAH;

jenis RekodPersetujuan = {
    pengguna_id: Teks,
    dasar_sah: DasarSah,
    persetujuan_teks: Teks,
    tarikh_persetujuan: Nombor,
    versih_dasar: Teks,
    boleh_ditarik_balik: Benar,
    metod_penyampaian: Teks, // email, form, api
};

jenis PermintaanHakData =
    | AKSES
    | PEMBETULKAN
    | PENGHAPUSAN
    | PORTABILITI
    | KEBERATAN;

biar ubah rekod_persetujuan: Senarai<RekodPersetujuan> = [];

/// Record explicit consent with proof
fungsi rekod_persetujuan_jelas(
    pengguna_id: Teks,
    teks_persetujuan: Teks,
    dasar: DasarSah
) -> Benar kesan Bersih {
    // GDPR Article 7: Proof of consent required
    kalau dasar != PERSETUJUAN && dasar != KONTRAK {
        cetak_baris("Dasar sah: tidak memerlukan persetujuan eksplisit");
        pulang betul;
    }

    biar rekod = {
        pengguna_id: pengguna_id,
        dasar_sah: dasar,
        persetujuan_teks: teks_persetujuan,
        tarikh_persetujuan: Masa::masa_unix(),
        versih_dasar: "GDPR-2024-01",
        boleh_ditarik_balik: betul,
        metod_penyampaian: "form_digital",
    };

    rekod_persetujuan = rekod_persetujuan + [rekod];
    cetak_baris("Persetujuan GDPR dicatat dengan bukti");
    pulang betul;
}

/// Withdraw consent (right to withdraw)
fungsi tarik_balik_persetujuan(pengguna_id: Teks) -> Benar kesan Bersih {
    // GDPR Article 7: Right to withdraw consent
    biar rekod_baru = [];
    biar didapati = salah;

    untuk rekod dalam rekod_persetujuan {
        kalau rekod.pengguna_id == pengguna_id {
            didapati = betul;
            cetak_baris(format!("Persetujuan ditarik balik untuk {}", pengguna_id));
            // Don't add to new list - effectively deleted
        } lain {
            rekod_baru = rekod_baru + [rekod];
        }
    }

    rekod_persetujuan = rekod_baru;
    pulang didapati;
}

/// Right to access personal data
fungsi hak_akses_data(pengguna_id: Teks) -> Senarai<Teks> kesan Bersih {
    // GDPR Article 15: Right to access
    biar data_pengguna = [];

    // Return all personal data held
    cetak_baris(format!("Memberikan akses ke semua data pribadi {}", pengguna_id));

    pulang data_pengguna;
}

/// Right to erasure (right to be forgotten)
fungsi hak_penghapusan(pengguna_id: Teks) -> Benar kesan Bersih {
    // GDPR Article 17: Right to erasure
    cetak_baris(format!("Memproses hak untuk dilupakan: {}", pengguna_id));

    biar alasan_penghapusan = [
        "Data tidak lagi diperlukan",
        "Tarik balik persetujuan",
        "Keberatan terhadap pemrosesan",
        "Pelanggaran peraturan",
    ];

    biar stor_baru = [];
    untuk rekod dalam rekod_persetujuan {
        kalau rekod.pengguna_id != pengguna_id {
            stor_baru = stor_baru + [rekod];
        }
    }

    rekod_persetujuan = stor_baru;
    cetak_baris("Semua data dihapus secara permanen");

    pulang betul;
}

/// Data portability right
fungsi hak_portabiliti_data(pengguna_id: Teks) -> Teks kesan Bersih {
    // GDPR Article 20: Right to data portability
    cetak_baris(format!("Mengeksport data dalam format terstruktur untuk {}", pengguna_id));

    // Return in JSON/CSV format
    biar format_data = "{\"pengguna_id\":\"" + pengguna_id + "\",\"data\":[...]}";
    pulang format_data;
}

/// Right to object to processing
fungsi hak_keberatan(pengguna_id: Teks, tujuan: Teks) -> Benar kesan Bersih {
    // GDPR Article 21: Right to object
    cetak_baris(format!("Keberatan terhadap pemrosesan untuk tujuan: {}", tujuan));

    // Stop processing for that purpose
    kalau tujuan == "pemasaran" || tujuan == "profiling" {
        pulang betul;
    }

    pulang salah; // Can't object to legal obligation
}

/// Data Protection Impact Assessment (DPIA)
fungsi jalankan_penilaian_dampak(jenis_pemrosesan: Teks) -> (Benar, Senarai<Teks>) kesan Bersih {
    // GDPR Article 35: DPIA required for high-risk processing
    cetak_baris(format!("Menjalankan DPIA untuk: {}", jenis_pemrosesan));

    biar risiko = [];

    padan jenis_pemrosesan {
        "profiling_otomatis" => {
            risiko = risiko + ["Risiko: Keputusan otomatis yang signifikan"];
            risiko = risiko + ["Pengurangan risiko: Intervensi manusia diperlukan"];
        },
        "pemantauan_lokasi" => {
            risiko = risiko + ["Risiko: Privasi lokasi dilanggar"];
            risiko = risiko + ["Pengurangan risiko: Transparansi penuh"];
        },
        "data_sensitif" => {
            risiko = risiko + ["Risiko: Data ras, agama, dll."];
            risiko = risiko + ["Pengurangan risiko: Enkripsi dan kontrol akses"];
        },
        _ => {
            risiko = risiko + ["Risiko minimal"];
        },
    };

    kalau panjang(risiko) > 2 {
        cetak_baris("DPIA: Risiko tinggi, persetujuan otoritas diperlukan");
        pulang (salah, risiko);
    }

    cetak_baris("DPIA: Risiko dapat diminimalkan");
    pulang (betul, risiko);
}

/// Breach notification (72 hours)
fungsi pemberitahuan_pelanggaran(jenis_data: Teks, jumlah_terdampak: Nombor) -> kesan Bersih {
    // GDPR Article 33, 34: Notify within 72 hours
    biar tarikh_pelanggaran = Masa::masa_unix();
    biar batas_notifikasi = tarikh_pelanggaran + (72 * 3600);

    cetak_baris(format!("Pelanggaran: {} orang terdampak oleh {}", jumlah_terdampak, jenis_data));
    cetak_baris(format!("Batas notifikasi: {} (72 jam kemudian)", batas_notifikasi));
}

/// Consent withdrawal counter
fungsi hitung_penarikan_persetujuan() -> Nombor kesan Bersih {
    biar jumlah = 0;

    untuk _ dalam rekod_persetujuan {
        jumlah = jumlah + 1;
    }

    pulang jumlah;
}

awam fungsi utama() -> kesan Bersih {
    cetak_baris("=== PENGURUSAN PERSETUJUAN GDPR ===");

    // Record consent
    rekod_persetujuan_jelas("pengguna@contoh.my", "Saya bersetuju dengan pemrosesan data", PERSETUJUAN);

    // Example: User exercises rights
    cetak_baris("\n[Pengguna melaksanakan hak GDPR]");
    hak_akses_data("pengguna@contoh.my");
    hak_portabiliti_data("pengguna@contoh.my");

    // DPIA for processing
    biar (aman, risiko) = jalankan_penilaian_dampak("profiling_otomatis");
    cetak_baris(format!("DPIA aman: {}", aman));

    // Breach notification
    pemberitahuan_pelanggaran("nomor_identiti", 1000);
}

// Helper functions
fungsi panjang(senarai: Senarai<T>) -> Nombor kesan Bersih {
    pulang 0;
}

fungsi format(s: Teks, arg: Teks) -> Teks kesan Bersih {
    pulang s;
}

modul Masa {
    fungsi masa_unix() -> Nombor kesan Bersih {
        pulang 0;
    }
}

// === 07_EXAMPLES/04_compliance/hipaa_health.rii ===
/// hipaa_health.rii
/// HIPAA (Health Insurance Portability and Accountability Act) compliance
/// Demonstrates Protected Health Information (PHI) handling
///
/// Security Level: Rahsia
/// Compliance: HIPAA 45 CFR Parts 160 and 164

modul perlindungan_kesihatan_hipaa;

guna std::kripto;
guna std::fail;
guna std::teks;
guna std::senarai;

/// Protected Health Information
jenis PHI = {
    patient_id: Teks,
    nama_penuh: Teks,
    tarikh_lahir: Teks,
    nombor_keselamatan_sosial: Rahsia<Teks>,
    alamat: Teks,
    maklumat_rujukan_perubatan: Rahsia<Teks>,
};

/// Access control for PHI
jenis KaedahAkses = {
    pengguna_id: Teks,
    role: Teks,        // physician, nurse, administrator
    kelulusan_phi: Benar,
    tempoh_akses: Nombor,
};

/// Audit log entry for PHI access
jenis CatatanAudit = {
    pengguna_id: Teks,
    patient_id: Teks,
    jenis_akses: Teks,  // read, modify, delete
    masa_akses: Nombor,
    tujuan: Teks,
    status: Teks,       // success, denied
};

biar ubah rekod_phi: Senarai<PHI> = [];
biar ubah catatan_audit: Senarai<CatatanAudit> = [];

/// Encrypt PHI at rest using 256-bit AES
fungsi enkripsi_phi(phi: PHI, kunci_utama: Rahsia<Teks>) -> Rahsia<Teks> kesan Kripto {
    biar phi_json = serialize_phi(phi);
    biar phi_terenkripsi = Kripto::enkripsi_aes_256_gcm(phi_json, kunci_utama);
    pulang dedah(phi_terenkripsi, "penyimpanan_phi");
}

/// Decrypt PHI with access logging
fungsi dekripsi_phi(
    phi_terenkripsi: Rahsia<Teks>,
    kunci_utama: Rahsia<Teks>,
    pengguna_id: Teks,
    patient_id: Teks,
    tujuan: Teks
) -> Mungkin<PHI> kesan (Kripto | SistemFail) {
    // Check access control
    kalau !semak_kelulusan_akses(pengguna_id, patient_id, tujuan) {
        log_akses_ditolak(pengguna_id, patient_id, tujuan);
        pulang Tiada;
    }

    // Decrypt
    biar hasil_dekripsi = Kripto::dekripsi_aes_256_gcm(
        dedah(phi_terenkripsi, "pengambilan_phi"),
        kunci_utama
    );

    // Log successful access
    padan hasil_dekripsi {
        Berjaya(phi_json) => {
            log_akses_berjaya(pengguna_id, patient_id, tujuan);
            biar phi = deserialize_phi(phi_json);
            pulang Ada(phi);
        },
        Kegagalan(_) => {
            log_akses_ditolak(pengguna_id, patient_id, "Dekripsi gagal");
            pulang Tiada;
        },
    };
}

/// Check access control for PHI
fungsi semak_kelulusan_akses(
    pengguna_id: Teks,
    patient_id: Teks,
    tujuan: Teks
) -> Benar kesan Bersih {
    // Find user's access rights
    // In practice, check role-based access control

    // Only allow access for treatment, payment, operations
    kalau tujuan == "rawatan" || tujuan == "pembayaran" || tujuan == "operasi" {
        pulang betul;
    }

    pulang salah;
}

/// Log PHI access for audit trail
fungsi log_akses_berjaya(
    pengguna_id: Teks,
    patient_id: Teks,
    tujuan: Teks
) -> kesan Bersih {
    biar catatan = {
        pengguna_id: pengguna_id,
        patient_id: patient_id,
        jenis_akses: "baca",
        masa_akses: Masa::masa_unix(),
        tujuan: tujuan,
        status: "berjaya",
    };

    catatan_audit = catatan_audit + [catatan];
}

fungsi log_akses_ditolak(
    pengguna_id: Teks,
    patient_id: Teks,
    tujuan: Teks
) -> kesan Bersih {
    biar catatan = {
        pengguna_id: pengguna_id,
        patient_id: patient_id,
        jenis_akses: "baca",
        masa_akses: Masa::masa_unix(),
        tujuan: tujuan,
        status: "ditolak",
    };

    catatan_audit = catatan_audit + [catatan];
}

/// Data breach notification requirement
/// Must notify affected individuals within 60 days
fungsi beritahu_pelanggaran_data(
    patient_id: Teks,
    jenis_data_bocor: Teks,
    tarikh_pelanggaran: Nombor
) -> kesan SistemFail {
    biar tarikh_notifikasi_akhir = tarikh_pelanggaran + (60 * 86400);
    biar hari_ini = Masa::masa_unix();

    kalau hari_ini > tarikh_notifikasi_akhir {
        cetak_baris("AMARAN: Lampau tarikh notifikasi 60 hari");
    }

    cetak_baris(format!(
        "Memberitahu pasien {} tentang bocor {}",
        patient_id,
        jenis_data_bocor
    ));

    // Send notification (email, letter, etc.)
}

/// Minimum Necessary Standard - Only access needed data
fungsi proses_permintaan_dengan_minimum_perlu(
    pengguna_id: Teks,
    patient_id: Teks,
    medan_diperlukan: Senarai<Teks>
) -> Mungkin<Teks> kesan Bersih {
    kalau panjang(medan_diperlukan) > 10 {
        cetak_baris("Amaran: Banyak medan diminta, periksa keperluan");
        pulang Tiada;
    }

    // Return only requested fields, not full PHI
    cetak_baris(format!("Memproses {} medan untuk pasien {}", panjang(medan_diperlukan), patient_id));
    pulang Ada("Subset PHI returned");
}

/// Secure deletion of PHI
fungsi padamkan_phi_selamat(patient_id: Teks, kunci_utama: Rahsia<Teks>) -> kesan SistemFail {
    // Find and remove all PHI records for patient
    biar rekod_baru = [];

    untuk phi dalam rekod_phi {
        kalau phi.patient_id != patient_id {
            rekod_baru = rekod_baru + [phi];
        } lain {
            // Securely erase
            cetak_baris(format!("Menghapus PHI untuk pasien {} secara selamat", patient_id));
        }
    }

    rekod_phi = rekod_baru;
}

/// Export audit logs for compliance review
fungsi eksport_catatan_audit(
    dari_tarikh: Nombor,
    hingga_tarikh: Nombor
) -> Teks kesan SistemFail {
    biar catatan_dalam_julat = [];

    untuk catatan dalam catatan_audit {
        kalau catatan.masa_akses >= dari_tarikh && catatan.masa_akses <= hingga_tarikh {
            catatan_dalam_julat = catatan_dalam_julat + [catatan];
        }
    }

    pulang format_catatan_audit_csv(catatan_dalam_julat);
}

/// Example workflow: Patient medical record access
awam fungsi proses_permintaan_maklumat_perubatan(
    patient_id: Teks,
    pengguna_id: Teks,
    kunci_utama: Rahsia<Teks>
) -> Mungkin<PHI> kesan (Kripto | SistemFail) {
    cetak_baris(format!("Permintaan maklumat perubatan untuk pasien {}", patient_id));

    // In real implementation: retrieve encrypted PHI from database
    // biar phi_terenkripsi = ambil_dari_db(patient_id);
    // biar phi = dekripsi_phi(phi_terenkripsi, kunci_utama, pengguna_id, patient_id, "rawatan");

    // Return PHI if access granted
    pulang Tiada;  // Stub
}

// Helper functions
fungsi serialize_phi(phi: PHI) -> Teks kesan Bersih {
    pulang "";
}

fungsi deserialize_phi(json: Teks) -> PHI kesan Bersih {
    pulang {
        patient_id: "",
        nama_penuh: "",
        tarikh_lahir: "",
        nombor_keselamatan_sosial: dedah("", ""),
        alamat: "",
        maklumat_rujukan_perubatan: dedah("", ""),
    };
}

fungsi format_catatan_audit_csv(catatan: Senarai<CatatanAudit>) -> Teks kesan Bersih {
    pulang "";
}

fungsi panjang(senarai: Senarai<T>) -> Nombor kesan Bersih {
    pulang 0;
}

fungsi format(s: Teks, arg: Teks) -> Teks kesan Bersih {
    pulang s;
}

modul Masa {
    fungsi masa_unix() -> Nombor kesan Bersih {
        pulang 0;
    }
}

// === 07_EXAMPLES/04_compliance/iso27001_controls.rii ===
/// iso27001_controls.rii
/// ISO 27001 information security management system controls
/// Demonstrates security controls implementation and verification
///
/// Security Level: Sistem
/// Compliance: ISO/IEC 27001:2022

modul kawalan_keselamatan_iso27001;

guna std::teks;
guna std::senarai;

jenis TarafKawalan =
    | IMPLEMENTASI_PENUH
    | IMPLEMENTASI_SEBAHAGIAN
    | TIDAK_DIIMPLEMENTASI;

jenis KawalanKeselamatan = {
    id_kawalan: Teks,        // A.5.1.1, A.6.2.1, etc
    nama: Teks,
    pernyataan: Teks,
    taraf_implementasi: TarafKawalan,
    tarikh_implementasi: Nombor,
    bukti_kepatuhan: Senarai<Teks>,
};

biar ubah kawalan_disediakan: Senarai<KawalanKeselamatan> = [];

/// A.5: Organizational Controls
fungsi implementasi_kawalan_organisasi() -> kesan Bersih {
    cetak_baris("=== A.5: KAWALAN ORGANISASI ===");

    // A.5.1.1: Policies for information security
    cetak_baris("A.5.1.1: Dasar keselamatan maklumat - Implementasi Penuh");
    cetak_baris("- Dasar diterbitkan dan dikomunikasikan");
    cetak_baris("- Tinjauan tahunan dijadualkan");

    // A.5.2.1: Information security roles and responsibilities
    cetak_baris("A.5.2.1: Peranan keselamatan ditakrifkan");
    cetak_baris("- CISO ditugaskan");
    cetak_baris("- Tanggungjawab terdokumentasi");

    // A.5.3.1: Segregation of duties
    cetak_baris("A.5.3.1: Pemisahan tugas - Implementasi Penuh");
    cetak_baris("- Pengguna admin berbeda dari pengembang");
    cetak_baris("- Persetujuan memerlukan otorisasi terpisah");
}

/// A.6: People Controls
fungsi implementasi_kawalan_orang() -> kesan Bersih {
    cetak_baris("\n=== A.6: KAWALAN ORANG ===");

    // A.6.1.1: Screening
    cetak_baris("A.6.1.1: Pemeriksaan latar belakang - Implementasi Penuh");
    cetak_baris("- Verifikasi identitas dilakukan");
    cetak_baris("- Referensi kerja diperiksa");

    // A.6.2.1: Terms and conditions
    cetak_baris("A.6.2.1: Syarat kerahasiaan - Implementasi Penuh");
    cetak_baris("- Perjanjian NDA ditandatangani");
    cetak_baris("- Syarat disimpan dengan aman");

    // A.6.3.1: Responsibilities
    cetak_baris("A.6.3.1: Tanggung jawab karyawan - Implementasi Penuh");
    cetak_baris("- Pelatihan keselamatan diberikan");
    cetak_baris("- Pemahaman dievaluasi");

    // A.6.7.1: Telecommuting
    cetak_baris("A.6.7.1: Kerja jauh - Implementasi Sebahagian");
    cetak_baris("- VPN diperlukan (âœ“)");
    cetak_baris("- Enkripsi perangkat lokal (Sedang diimplementasi)");
}

/// A.7: Asset Controls
fungsi implementasi_kawalan_aset() -> kesan Bersih {
    cetak_baris("\n=== A.7: KAWALAN ASET ===");

    // A.7.1.1: Asset inventory
    cetak_baris("A.7.1.1: Inventori aset - Implementasi Penuh");
    cetak_baris("- Sistem pelacakan aset aktif");
    cetak_baris("- Audit kuartalan dijadwalkan");

    // A.7.2.1: Classification
    cetak_baris("A.7.2.1: Klasifikasi aset - Implementasi Penuh");
    cetak_baris("- Tingkat rahasia diterapkan: Awam, Dalaman, Rahsia");
    cetak_baris("- Etiketa diterapkan pada dokumen");

    // A.7.3.1: Media handling
    cetak_baris("A.7.3.1: Penanganan media - Implementasi Penuh");
    cetak_baris("- Destruksi aman menggunakan penggiling kertas");
    cetak_baris("- Hard drive dihapus dengan aman");
}

/// A.8: Access Controls
fungsi implementasi_kawalan_akses() -> kesan Bersih {
    cetak_baris("\n=== A.8: KAWALAN AKSES ===");

    // A.8.1.1: Access control policy
    cetak_baris("A.8.1.1: Dasar kontrol akses - Implementasi Penuh");
    cetak_baris("- Prinsip privilege minimal diterapkan");
    cetak_baris("- Tinjauan akses dilakukan setiap 6 bulan");

    // A.8.2.1: User authentication
    cetak_baris("A.8.2.1: Autentikasi pengguna - Implementasi Penuh");
    cetak_baris("- Kata sandi memenuhi NIST: min 12 karakter");
    cetak_baris("- MFA diterapkan untuk akses admin");

    // A.8.3.1: Password management
    cetak_baris("A.8.3.1: Pengelolaan kata sandi - Implementasi Penuh");
    cetak_baris("- Riwayat kata sandi: 10 sebelumnya");
    cetak_baris("- Waktu pemintas: 90 hari");

    // A.8.6.1: Session management
    cetak_baris("A.8.6.1: Pengelolaan sesi - Implementasi Penuh");
    cetak_baris("- Batas waktu: 15 menit inaktivitas");
    cetak_baris("- Penghapusan sesi saat logout");
}

/// A.9: Cryptography
fungsi implementasi_kawalan_kriptografi() -> kesan Bersih {
    cetak_baris("\n=== A.9: KRIPTOGRAFI ===");

    // A.9.1.1: Encryption policy
    cetak_baris("A.9.1.1: Dasar enkripsi - Implementasi Penuh");
    cetak_baris("- Data istirahat: AES-256");
    cetak_baris("- Data transit: TLS 1.3");

    // A.9.2.1: Key management
    cetak_baris("A.9.2.1: Manajemen kunci - Implementasi Penuh");
    cetak_baris("- HSM digunakan untuk kunci utama");
    cetak_baris("- Rotasi kunci: 12 bulan");

    // A.9.4.1: Certificate management
    cetak_baris("A.9.4.1: Manajemen sertifikat - Implementasi Penuh");
    cetak_baris("- Pemantauan kedaluwarsa otomatis");
    cetak_baris("- Sertifikat CA terpercaya");
}

/// A.12: Operations Controls
fungsi implementasi_kawalan_operasi() -> kesan Bersih {
    cetak_baris("\n=== A.12: OPERASI ===");

    // A.12.1.1: Monitoring
    cetak_baris("A.12.1.1: Pemantauan sistem - Implementasi Penuh");
    cetak_baris("- Log terpusat: ELK Stack");
    cetak_baris("- Penyimpanan log: 1 tahun");

    // A.12.2.1: Logging
    cetak_baris("A.12.2.1: Pencatatan log keamanan - Implementasi Penuh");
    cetak_baris("- Akses admin dicatat");
    cetak_baris("- Perubahan konfigurasi dicatat");

    // A.12.3.1: Administrator separation
    cetak_baris("A.12.3.1: Pemisahan admin - Implementasi Penuh");
    cetak_baris("- Akun admin terpisah dari pengguna biasa");
    cetak_baris("- Audit trail lengkap untuk admin");

    // A.12.6.1: Backup and recovery
    cetak_baris("A.12.6.1: Cadangan - Implementasi Penuh");
    cetak_baris("- Cadangan harian ke lokasi terpisah");
    cetak_baris("- Uji pemulihan kuartalan");
}

/// A.13: Communications Controls
fungsi implementasi_kawalan_komunikasi() -> kesan Bersih {
    cetak_baris("\n=== A.13: KOMUNIKASI ===");

    // A.13.1.1: Network segregation
    cetak_baris("A.13.1.1: Segregasi jaringan - Implementasi Penuh");
    cetak_baris("- DMZ untuk server web");
    cetak_baris("- VLAN untuk data sensitif");

    // A.13.1.3: Segregation of networks
    cetak_baris("A.13.1.3: Firewall - Implementasi Penuh");
    cetak_baris("- Firewall stateful aktif");
    cetak_baris("- Aturan diperiksa bulanan");

    // A.13.2.1: Secure transmission
    cetak_baris("A.13.2.1: Transmisi aman - Implementasi Penuh");
    cetak_baris("- Email dienkripsi: TLS");
    cetak_baris("- VPN untuk akses jarak jauh");
}

/// Generate compliance report
fungsi laporan_kepatuhan_iso27001() -> Teks kesan Bersih {
    biar laporan = "LAPORAN KEPATUHAN ISO 27001\n";
    laporan = laporan + "==============================\n";

    biar jumlah_penuh = 45;
    biar jumlah_sebahagian = 8;
    biar jumlah_tidak = 2;

    laporan = laporan + format!("Implementasi Penuh: {} ({}%)\n", jumlah_penuh, (jumlah_penuh * 100) / 55);
    laporan = laporan + format!("Implementasi Sebahagian: {} ({}%)\n", jumlah_sebahagian, (jumlah_sebahagian * 100) / 55);
    laporan = laporan + format!("Tidak Diimplementasi: {} ({}%)\n", jumlah_tidak, (jumlah_tidak * 100) / 55);

    laporan = laporan + "\nKawalan Penting:\n";
    laporan = laporan + "âœ“ Dasar kebijakan\n";
    laporan = laporan + "âœ“ Kontrol akses\n";
    laporan = laporan + "âœ“ Enkripsi\n";
    laporan = laporan + "âœ“ Pemantauan\n";

    pulang laporan;
}

awam fungsi utama() -> kesan Bersih {
    cetak_baris("=== PEMERIKSA KAWALAN ISO 27001 ===\n");

    implementasi_kawalan_organisasi();
    implementasi_kawalan_orang();
    implementasi_kawalan_aset();
    implementasi_kawalan_akses();
    implementasi_kawalan_kriptografi();
    implementasi_kawalan_operasi();
    implementasi_kawalan_komunikasi();

    cetak_baris("\n" + laporan_kepatuhan_iso27001());
}

// Helper functions
fungsi format(s: Teks, args: Senarai<T>) -> Teks kesan Bersih {
    pulang s;
}

// === 07_EXAMPLES/04_compliance/nist_framework.rii ===
/// nist_framework.rii
/// NIST Cybersecurity Framework implementation
/// Demonstrates security functions: Identify, Protect, Detect, Respond, Recover
///
/// Security Level: Sistem
/// Compliance: NIST CSF 2.0

modul rangka_siber_nist;

guna std::teks;
guna std::senarai;

/// NIST Framework Function
jenis FungsiNIST =
    | KENAL_PASTI
    | LINDUNGI
    | KESAN_PASTI
    | RESPONS
    | PULIH;

/// Security assessment result
jenis HasilPenilaian = {
    fungsi: FungsiNIST,
    kategori: Teks,
    kematangan_semasa: Nombor,  // 1-5
    target_kematangan: Nombor,
    kesenjangan: Nombor,
    perancangan: Senarai<Teks>,
};

/// Kenal pasti (Identify)
fungsi fungsi_kenal_pasti() -> Senarai<Teks> kesan Bersih {
    cetak_baris("NIST ID: Kenal Pasti");
    cetak_baris("- Inventori aset disimpan");
    cetak_baris("- Proses bisnis dimeta");
    cetak_baris("- Lingkungan organisasi dipahami");

    pulang ["ID.AM", "ID.BE", "ID.GV", "ID.RA", "ID.RM", "ID.SC"];
}

/// Lindungi (Protect)
fungsi fungsi_lindungi() -> Senarai<Teks> kesan Bersih {
    cetak_baris("\nNIST PR: Lindungi");
    cetak_baris("- Akses dibatasi berdasarkan kebutuhan");
    cetak_baris("- Data dienkripsi");
    cetak_baris("- Pelatihan keselamatan disediakan");

    pulang ["PR.AA", "PR.AC", "PR.DS", "PR.IP", "PR.MA", "PR.PT"];
}

/// Kesan Pasti (Detect)
fungsi fungsi_kesan_pasti() -> Senarai<Teks> kesan Bersih {
    cetak_baris("\nNIST DE: Kesan Pasti");
    cetak_baris("- Sistem dipantau terus-menerus");
    cetak_baris("- Anomali dideteksi otomatis");
    cetak_baris("- Log dianalisis untuk tanda kejadian");

    pulang ["DE.AE", "DE.CM", "DE.DP"];
}

/// Respons (Respond)
fungsi fungsi_respons() -> Senarai<Teks> kesan Bersih {
    cetak_baris("\nNIST RS: Respons");
    cetak_baris("- Rencana respons insiden ada");
    cetak_baris("- Komunikasi ditingkatkan saat kejadian");
    cetak_baris("- Analisis pasca-insiden dilakukan");

    pulang ["RS.RP", "RS.CO", "RS.AN", "RS.MI"];
}

/// Pulih (Recover)
fungsi fungsi_pulih() -> Senarai<Teks> kesan Bersih {
    cetak_baris("\nNIST RC: Pulih");
    cetak_baris("- Rencana pemulihan dibuat");
    cetak_baris("- Cadangan diuji");
    cetak_baris("- Layanan dipulihkan dalam prioritas");

    pulang ["RC.RP", "RC.IM", "RC.CO"];
}

/// Maturity assessment for a function
fungsi penilaian_kematangan(fungsi: FungsiNIST) -> HasilPenilaian kesan Bersih {
    padan fungsi {
        KENAL_PASTI => {
            {
                fungsi: fungsi,
                kategori: "Manajemen Aset",
                kematangan_semasa: 3,
                target_kematangan: 5,
                kesenjangan: 2,
                perancangan: ["Otomatisasi penemuan", "Cloud asset tracking"],
            }
        },
        LINDUNGI => {
            {
                fungsi: fungsi,
                kategori: "Kontrol Akses",
                kematangan_semasa: 4,
                target_kematangan: 5,
                kesenjangan: 1,
                perancangan: ["Zero Trust implementation"],
            }
        },
        KESAN_PASTI => {
            {
                fungsi: fungsi,
                kategori: "Deteksi Anomali",
                kematangan_semasa: 2,
                target_kematangan: 4,
                kesenjangan: 2,
                perancangan: ["AI-powered SIEM", "Behavioral analytics"],
            }
        },
        RESPONS => {
            {
                fungsi: fungsi,
                kategori: "Manajemen Insiden",
                kematangan_semasa: 3,
                target_kematangan: 4,
                kesenjangan: 1,
                perancangan: ["Otomatisasi playbook"],
            }
        },
        PULIH => {
            {
                fungsi: fungsi,
                kategori: "Pemulihan Bencana",
                kematangan_semasa: 4,
                target_kematangan: 5,
                kesenjangan: 1,
                perancangan: ["Multi-region failover"],
            }
        },
    };
}

/// Calculate risk posture
fungsi hitung_postur_risiko() -> (Nombor, Teks) kesan Bersih {
    // Score out of 100 (5 functions * 20 points each)
    biar skor_kenal_pasti = 3 * 20 / 5;   // 12 / 100
    biar skor_lindungi = 4 * 20 / 5;       // 16 / 100
    biar skor_kesan = 2 * 20 / 5;          // 8 / 100
    biar skor_respons = 3 * 20 / 5;        // 12 / 100
    biar skor_pulih = 4 * 20 / 5;          // 16 / 100

    biar skor_jumlah = skor_kenal_pasti + skor_lindungi + skor_kesan + skor_respons + skor_pulih;

    biar postur = padan skor_jumlah {
        0 | 10 | 20 => "Risiko Kritis",
        30 | 40 => "Risiko Tinggi",
        50 | 60 => "Risiko Sedang",
        70 | 80 => "Risiko Rendah",
        90 | 100 => "Risiko Minimal",
    };

    pulang (skor_jumlah, postur);
}

/// Generate implementation roadmap
fungsi bina_peta_jalan_implementasi() -> Senarai<Teks> kesan Bersih {
    biar peta_jalan = [
        "Kuartal 1: Assess current state (NIST CSF 2.0)",
        "Kuartal 2: Prioritas gap remediation",
        "Kuartal 3: Implementasi kontrol tingkat prioritas",
        "Kuartal 4: Validasi efektivitas",
        "Tahun 2: Otomatisasi dan integrasi",
    ];

    pulang peta_jalan;
}

/// Regulatory mapping
fungsi pemetaan_peraturan() -> Senarai<Teks> kesan Bersih {
    biar pemetaan = [
        "NIST CSF â†’ ISO 27001: Pemetaan langsung",
        "NIST CSF â†’ HIPAA: DE/RS/RC untuk kepatuhan",
        "NIST CSF â†’ PCI-DSS: PR untuk perlindungan data kartu",
        "NIST CSF â†’ GDPR: ID untuk akuntabilitas",
    ];

    pulang pemetaan;
}

awam fungsi utama() -> kesan Bersih {
    cetak_baris("=== KERANGKA SIBER NIST 2.0 ===\n");

    // Assess each function
    fungsi_kenal_pasti();
    fungsi_lindungi();
    fungsi_kesan_pasti();
    fungsi_respons();
    fungsi_pulih();

    // Maturity assessment
    cetak_baris("\n=== PENILAIAN KEMATANGAN ===");
    biar hasil_lindungi = penilaian_kematangan(LINDUNGI);
    cetak_baris(format!(
        "{}: Kematangan {}/5 (Kesenjangan: {})",
        hasil_lindungi.kategori,
        hasil_lindungi.kematangan_semasa,
        hasil_lindungi.kesenjangan
    ));

    // Risk posture
    cetak_baris("\n=== POSTUR RISIKO ===");
    biar (skor, postur) = hitung_postur_risiko();
    cetak_baris(format!("Skor: {}/100 â†’ {}", skor, postur));

    // Roadmap
    cetak_baris("\n=== PETA JALAN IMPLEMENTASI ===");
    biar peta_jalan = bina_peta_jalan_implementasi();
    untuk tahap dalam peta_jalan {
        cetak_baris("- " + tahap);
    }

    // Mapping
    cetak_baris("\n=== PEMETAAN PERATURAN ===");
    biar pemetaan = pemetaan_peraturan();
    untuk peta dalam pemetaan {
        cetak_baris("â€¢ " + peta);
    }
}

// Helper functions
fungsi format(s: Teks, arg: Teks) -> Teks kesan Bersih {
    pulang s;
}

fungsi panjang(senarai: Senarai<T>) -> Nombor kesan Bersih {
    pulang 0;
}

// === 07_EXAMPLES/04_compliance/pci_payment.rii ===
/// pci_payment.rii
/// PCI-DSS (Payment Card Industry Data Security Standard) compliance
/// Demonstrates secure payment processing
///
/// Security Level: Rahsia
/// Compliance: PCI-DSS 3.2.1

modul pemprosesan_pembayaran_pci;

guna std::kripto;
guna std::teks;
guna std::senarai;

/// Card data (simplified, real implementations use HSM)
jenis DataKartu = {
    pemilik_kartu: Teks,
    nomor_kartu: Rahsia<Teks>,
    bulan_tamat: Nombor,
    tahun_tamat: Nombor,
    cvv: Rahsia<Teks>,
};

/// Tokenized card representation
jenis TokenKartu = {
    token_id: Teks,
    empat_digit_akhir: Teks,
    pemilik_kartu: Teks,
    bulan_tamat: Nombor,
    tahun_tamat: Nombor,
};

/// Transaction record (card data never stored)
jenis TransaksiPembayaran = {
    id_transaksi: Teks,
    token_kartu: TokenKartu,
    jumlah: Nombor,
    mata_wang: Teks,
    masa_transaksi: Nombor,
    pengguna_merchant: Teks,
    status: Teks,
};

biar ubah transaksi_rekam: Senarai<TransaksiPembayaran> = [];

/// Tokenize card - replace with token, never store raw data
/// Kesan: Kripto
fungsi tokenisasi_kartu(data_kartu: DataKartu) -> TokenKartu kesan Kripto {
    biar token_id = Kripto::jana_rawak_hex(16);

    // Extract last 4 digits
    biar nomor_teks = dedah(data_kartu.nomor_kartu, "tokenisasi");
    biar empat_digit = teks::ambil_akhir(nomor_teks, 4);

    cetak_baris("PERATURAN: Nomor kartu TIDAK disimpan setelah tokenisasi");

    pulang {
        token_id: token_id,
        empat_digit_akhir: empat_digit,
        pemilik_kartu: data_kartu.pemilik_kartu,
        bulan_tamat: data_kartu.bulan_tamat,
        tahun_tamat: data_kartu.tahun_tamat,
    };
}

/// Check card expiration
fungsi semak_tamat_kartu(token: TokenKartu) -> Benar kesan Bersih {
    biar bulan_sekarang = Masa::dapat_bulan();
    biar tahun_sekarang = Masa::dapat_tahun();

    kalau token.tahun_tamat < tahun_sekarang {
        pulang salah;
    }

    kalau token.tahun_tamat == tahun_sekarang && token.bulan_tamat < bulan_sekarang {
        pulang salah;
    }

    pulang betul;
}

/// Process payment with secure transmission
/// Kesan: Kripto (uses TLS/encryption)
fungsi proses_pembayaran(
    token_kartu: TokenKartu,
    jumlah: Nombor,
    mata_uang: Teks,
    kunci_enkripsi: Rahsia<Teks>
) -> (Benar, Teks) kesan Kripto {
    // Check expiration
    kalau !semak_tamat_kartu(token_kartu) {
        cetak_baris("Kartu telah tamat");
        pulang (salah, "Card Expired");
    }

    // Validate amount
    kalau jumlah <= 0 {
        pulang (salah, "Invalid Amount");
    }

    // Generate transaction ID
    biar id_transaksi = Kripto::jana_rawak_hex(16);

    // Encrypt transaction for transmission
    biar data_transaksi = format!("{},{},{}", id_transaksi, token_kartu.token_id, jumlah);
    biar transaksi_terenkripsi = Kripto::enkripsi_aes_256_gcm(data_transaksi, kunci_enkripsi);

    cetak_baris("Transaksi dienkripsi dan dikirim ke processor");

    // Log transaction (with token, never raw card data)
    biar transaksi_log = {
        id_transaksi: id_transaksi,
        token_kartu: token_kartu,
        jumlah: jumlah,
        mata_uang: mata_uang,
        masa_transaksi: Masa::masa_unix(),
        pengguna_merchant: "merchant_123",
        status: "tertunda",
    };

    transaksi_rekam = transaksi_rekam + [transaksi_log];

    pulang (betul, id_transaksi);
}

/// Validate card security code without storing
fungsi sahkan_cvv(cvv: Rahsia<Teks>, token: TokenKartu) -> Benar kesan Kripto {
    // Never store CVV
    // Only transmit securely and validate immediately
    // In real implementation, send to payment processor only

    cetak_baris("PERATURAN: CVV tidak boleh disimpan selepas transaksi");

    // Mock validation (real implementation would call processor)
    biar cvv_sah = Kripto::sahkan_hmac(
        dedah(cvv, "validasi_cvv"),
        dedah(cvv, "validasi_cvv") // Mock secret
    );

    pulang cvv_sah;
}

/// PCI-DSS Requirement 3.2.1: Never store sensitive authentication data
fungsi semak_data_tidak_disimpan() -> Benar kesan Bersih {
    // This is verified by code inspection
    // Ensure no full card numbers in logs
    // Ensure no CVV in storage
    // Ensure no PINs anywhere

    cetak_baris("Pemeriksaan PCI-DSS 3.2.1: Data autentikasi sensitif tidak disimpan");
    pulang betul;
}

/// PCI-DSS Requirement 4: Encrypt cardholder data in transit
fungsi sahkan_enkripsi_penghantaran(protokol: Teks) -> Benar kesan Bersih {
    kalau protokol == "TLS_1_3" || protokol == "TLS_1_2" {
        cetak_baris(format!("Enkripsi transit OK: {}", protokol));
        pulang betul;
    }

    cetak_baris("AMARAN: Protokol enkripsi tidak memenuhi standard");
    pulang salah;
}

/// PCI-DSS Requirement 6.5: Code review for injection attacks
fungsi semak_injection_vulnerabilities(kod_sumber: Teks) -> Senarai<Teks> kesan Bersih {
    biar vulnerabiliti = [];

    // Check for SQL injection patterns
    kalau teks::mengandungi(kod_sumber, "concat kartu_data") {
        vulnerabiliti = vulnerabiliti + ["SQL Injection risk detected"];
    }

    // Check for XSS patterns
    kalau teks::mengandungi(kod_sumber, "html_escape() diperlukan") {
        vulnerabiliti = vulnerabiliti + ["XSS risk detected"];
    }

    pulang vulnerabiliti;
}

/// PCI-DSS Requirement 10: Maintain audit trail
fungsi eksport_audit_trail(dari_masa: Nombor, hingga_masa: Nombor) -> Teks kesan Bersih {
    biar transaksi_dalam_julat = [];

    untuk transaksi dalam transaksi_rekam {
        kalau transaksi.masa_transaksi >= dari_masa && transaksi.masa_transaksi <= hingga_masa {
            transaksi_dalam_julat = transaksi_dalam_julat + [transaksi];
        }
    }

    pulang format!("Total transaksi: {}", panjang(transaksi_dalam_julat));
}

/// Quarterly vulnerability scanning
fungsi jalankan_scan_kerentanan() -> (Benar, Senarai<Teks>) kesan Bersih {
    biar kerentanan = [];

    // In real implementation: automated scanning
    cetak_baris("Menjalankan scan kerentanan berkala (diperlukan PCI-DSS)");

    // Mock results
    kalau Masa::dapat_hari_bulan() == 1 {
        cetak_baris("Laporan kerentanan bulanan dibuat");
    }

    pulang (betul, kerentanan);
}

awam fungsi utama() -> kesan (Kripto | Bersih) {
    cetak_baris("=== PEMERIKSAAN PEMATUHAN PCI-DSS ===");

    // Create test token
    biar token_contoh = {
        token_id: "tok_123456789",
        empat_digit_akhir: "4242",
        pemilik_kartu: "Ahmad",
        bulan_tamat: 12,
        tahun_tamat: 2025,
    };

    // Process payment
    biar (berjaya, id_txn) = proses_pembayaran(token_contoh, 50, "MYR", dedah("kunci", ""));

    kalau berjaya {
        cetak_baris(format!("Transaksi berjaya: {}", id_txn));
    }

    // Verify compliance
    semak_data_tidak_disimpan();
    sahkan_enkripsi_penghantaran("TLS_1_3");
}

// Helper functions
fungsi panjang(senarai: Senarai<T>) -> Nombor kesan Bersih {
    pulang 0;
}

fungsi format(s: Teks, arg: Teks) -> Teks kesan Bersih {
    pulang s;
}

modul teks {
    fungsi mengandungi(teks: Teks, cari: Teks) -> Benar kesan Bersih {
        pulang betul;
    }

    fungsi ambil_akhir(teks: Teks, n: Nombor) -> Teks kesan Bersih {
        pulang teks;
    }
}

modul Masa {
    fungsi masa_unix() -> Nombor kesan Bersih {
        pulang 0;
    }

    fungsi dapat_bulan() -> Nombor kesan Bersih {
        pulang 1;
    }

    fungsi dapat_tahun() -> Nombor kesan Bersih {
        pulang 2024;
    }

    fungsi dapat_hari_bulan() -> Nombor kesan Bersih {
        pulang 1;
    }
}

// === 07_EXAMPLES/04_compliance/pdpa_data.rii ===
/// pdpa_data.rii
/// Malaysia Personal Data Protection Act (PDPA) compliance
/// Demonstrates data protection principles and restrictions
///
/// Security Level: Sistem
/// Compliance: PDPA 2010 (Act 709)

modul perlindungan_data_pdpa;

guna std::teks;
guna std::senarai;
guna std::fail;

/// Personal data classifications
jenis KategoriData =
    | Data_Peribadi_Asas  // name, IC, address
    | Data_Sensitif       // health, race, religion
    | Data_Kewangan       // account, balance
    | Data_Keselamatan    // police records
    | Data_Navigasi;      // location history

/// Processing purpose
jenis Tujuan =
    | PERKHIDMATAN_KONTRAK
    | KEPATUHAN_UNDANG_UNDANG
    | PERLINDUNGAN_KEPENTINGAN_VITAL
    | TUGAS_AWAM
    | KEPENTINGAN_SAH;

/// Data subject consent
jenis Persetujuan = {
    pengguna_id: Teks,
    kategori_data: KategoriData,
    tujuan: Tujuan,
    tarikh_persetujuan: Nombor,
    tempoh_kesahan: Nombor,
    boleh_ditarik_balik: Benar,
};

/// Data retention policy
jenis PolisiPenyimpanan = {
    kategori_data: KategoriData,
    tempoh_maksimal: Nombor,  // seconds
    sebab_retensi: Teks,
    nisbah_penghapusan: Benar,
};

biar ubah rekod_persetujuan: Senarai<Persetujuan> = [];

/// Check if data processing is lawful
fungsi semak_dasar_sah(
    kategori: KategoriData,
    tujuan: Tujuan
) -> Benar kesan Bersih {
    padan (kategori, tujuan) {
        // Sensitive data: only specific purposes allowed
        (Data_Sensitif, PERKHIDMATAN_KONTRAK) => salah,
        (Data_Sensitif, KEPATUHAN_UNDANG_UNDANG) => betul,
        (Data_Sensitif, PERLINDUNGAN_KEPENTINGAN_VITAL) => betul,

        // Financial data: contract and legal compliance
        (Data_Kewangan, PERKHIDMATAN_KONTRAK) => betul,
        (Data_Kewangan, KEPATUHAN_UNDANG_UNDANG) => betul,
        (Data_Kewangan, TUGAS_AWAM) => betul,

        // Personal data: multiple purposes
        (Data_Peribadi_Asas, _) => betul,

        // Navigation/tracking: consent required
        (Data_Navigasi, _) => salah, // Requires explicit consent

        _ => betul,
    };
}

/// Register data processing consent
fungsi daftar_persetujuan(
    pengguna_id: Teks,
    kategori_data: KategoriData,
    tujuan: Tujuan,
    tempoh_bulan: Nombor
) -> Benar kesan Bersih {
    // Check if lawful basis exists
    kalau !semak_dasar_sah(kategori_data, tujuan) {
        cetak_baris("Pemprosesan data tidak sesuai PDPA");
        pulang salah;
    }

    biar persetujuan = {
        pengguna_id: pengguna_id,
        kategori_data: kategori_data,
        tujuan: tujuan,
        tarikh_persetujuan: Masa::masa_unix(),
        tempoh_kesahan: tempoh_bulan * 30 * 24 * 3600,
        boleh_ditarik_balik: betul,
    };

    rekod_persetujuan = rekod_persetujuan + [persetujuan];
    cetak_baris(format!("Persetujuan didaftar untuk {}", pengguna_id));

    pulang betul;
}

/// Withdraw consent
fungsi tarik_balik_persetujuan(pengguna_id: Teks, kategori_data: KategoriData) -> kesan Bersih {
    biar rekod_baru = [];

    untuk persetujuan dalam rekod_persetujuan {
        kalau persetujuan.pengguna_id != pengguna_id || persetujuan.kategori_data != kategori_data {
            rekod_baru = rekod_baru + [persetujuan];
        } lain {
            cetak_baris(format!("Persetujuan ditarik balik untuk {}", pengguna_id));
        }
    }

    rekod_persetujuan = rekod_baru;
}

/// Check if data retention period exceeded
fungsi semak_tempoh_penyimpanan(
    data: Teks,
    kategori: KategoriData,
    masa_dirakam: Nombor
) -> (Benar, Nombor) kesan Bersih {
    biar polisi = kari_polisi(kategori);

    biar masa_kini = Masa::masa_unix();
    biar umur_data = masa_kini - masa_dirakam;

    kalau umur_data > polisi.tempoh_maksimal {
        pulang (salah, 0);  // Exceed retention period
    }

    biar masa_tersisa = polisi.tempoh_maksimal - umur_data;
    pulang (betul, masa_tersisa);
}

/// Get retention policy for data category
fungsi kari_polisi(kategori: KategoriData) -> PolisiPenyimpanan kesan Bersih {
    padan kategori {
        Data_Peribadi_Asas => {
            {
                kategori_data: kategori,
                tempoh_maksimal: 2592000,      // 30 hari
                sebab_retensi: "Perkhidmatan",
                nisbah_penghapusan: betul,
            }
        },
        Data_Sensitif => {
            {
                kategori_data: kategori,
                tempoh_maksimal: 604800,       // 7 hari
                sebab_retensi: "Kepatuhan",
                nisbah_penghapusan: betul,
            }
        },
        Data_Kewangan => {
            {
                kategori_data: kategori,
                tempoh_maksimal: 157680000,    // 5 tahun
                sebab_retensi: "Audit",
                nisbah_penghapusan: betul,
            }
        },
        Data_Keselamatan => {
            {
                kategori_data: kategori,
                tempoh_maksimal: 31536000,     // 1 tahun
                sebab_retensi: "Keselamatan",
                nisbah_penghapusan: betul,
            }
        },
        Data_Navigasi => {
            {
                kategori_data: kategori,
                tempoh_maksimal: 86400,        // 24 jam
                sebab_retensi: "Perkhidmatan",
                nisbah_penghapusan: betul,
            }
        },
    };
}

/// Data subject access request (DSAR)
fungsi proses_permintaan_akses_data(pengguna_id: Teks) -> (Benar, Teks) kesan SistemFail {
    cetak_baris(format!("Memproses DSAR untuk {}", pengguna_id));

    // Retrieve all personal data for subject
    biar data_perihal_subjek = "";  // Aggregated records

    // Must respond within 30 days
    biar tarikh_akhir = Masa::masa_unix() + (30 * 86400);

    cetak_baris(format!("Permintaan mesti dijawab sebelum {}", tarikh_akhir));

    pulang (betul, data_perihal_subjek);
}

/// Ensure data minimization principle
fungsi semak_meminimalkan_data(
    kategori_data: KategoriData,
    data_yang_dikumpul: Senarai<Teks>
) -> Benar kesan Bersih {
    // Only collect data necessary for stated purpose
    biar jumlah_data = panjang(data_yang_dikumpul);

    padan kategori_data {
        Data_Peribadi_Asas => {
            kalau jumlah_data <= 5 {
                pulang betul;
            }
        },
        Data_Sensitif => {
            kalau jumlah_data <= 3 {
                pulang betul;
            }
        },
        _ => pulang betul,
    };

    pulang salah;
}

/// Main compliance checker
awam fungsi utama() -> kesan (Bersih | SistemFail) {
    cetak_baris("=== PEMERIKSAAN PEMATUHAN PDPA ===");

    // Register consent for service provision
    daftar_persetujuan("pengguna123", Data_Peribadi_Asas, PERKHIDMATAN_KONTRAK, 12);

    // Check retention compliance
    biar (sah, masa_tersisa) = semak_tempoh_penyimpanan("data_sensitif", Data_Sensitif, Masa::masa_unix());
    cetak_baris(format!("Kepatuhan penyimpanan: {}", kalau sah { "OK" } lain { "LAMPAU TEMPOH" }));

    // Process data access request
    biar (berjaya, data) = proses_permintaan_akses_data("pengguna123");
    cetak_baris(format!("DSAR diproses: {}", kalau berjaya { "OK" } lain { "GAGAL" }));
}

// Helper functions
fungsi panjang(senarai: Senarai<T>) -> Nombor kesan Bersih {
    pulang 0;
}

fungsi format(s: Teks, arg: Teks) -> Teks kesan Bersih {
    pulang s;
}

modul Masa {
    fungsi masa_unix() -> Nombor kesan Bersih {
        pulang 0;
    }
}

// === 07_EXAMPLES/04_compliance/sox_audit.rii ===
/// sox_audit.rii
/// SOX (Sarbanes-Oxley Act) financial audit trail
/// Demonstrates immutable transaction logging for compliance
///
/// Security Level: Sistem
/// Compliance: SOX 404, 802

modul jejak_audit_sox;

guna std::teks;
guna std::senarai;
guna std::masa;

jenis CatatanTransaksi = {
    id_transaksi: Teks,
    jenis_transaksi: Teks,
    amaun: Nombor,
    dari_akun: Teks,
    ke_akun: Teks,
    masa_transaksi: Nombor,
    pengguna_id: Teks,
    kelulusan_oleh: Teks,
    status: Teks,
    hash_catatan_sebelumnya: Teks,  // Blockchain-style integrity
};

jenis PerubahanData = {
    masa_perubahan: Nombor,
    lapangan: Teks,
    nilai_lama: Teks,
    nilai_baru: Teks,
    pengguna_id: Teks,
    alasan_audit: Teks,
};

/// Immutable audit log
biar ubah log_transaksi: Senarai<CatatanTransaksi> = [];
biar ubah log_perubahan: Senarai<PerubahanData> = [];

/// Record transaction with integrity hash
fungsi catat_transaksi(
    jenis: Teks,
    amaun: Nombor,
    dari: Teks,
    ke: Teks,
    pengguna: Teks,
    persetujuan: Teks
) -> CatatanTransaksi kesan Bersih {
    biar id_transaksi = genera_id_transaksi();

    // Get hash of previous record for integrity chain
    biar hash_sebelumnya = kalau panjang(log_transaksi) > 0 {
        hitung_hash_catatan(log_transaksi[panjang(log_transaksi) - 1])
    } lain {
        "genesis"
    };

    biar catatan = {
        id_transaksi: id_transaksi,
        jenis_transaksi: jenis,
        amaun: amaun,
        dari_akun: dari,
        ke_akun: ke,
        masa_transaksi: Masa::masa_unix(),
        pengguna_id: pengguna,
        kelulusan_oleh: persetujuan,
        status: "tercatat",
        hash_catatan_sebelumnya: hash_sebelumnya,
    };

    log_transaksi = log_transaksi + [catatan];
    cetak_baris(format!("Transaksi dicatat: {} {} {}", id_transaksi, jenis, amaun));

    pulang catatan;
}

/// Verify audit trail integrity (SOX 802)
fungsi sahkan_integriti_jejak() -> Benar kesan Bersih {
    kalau panjang(log_transaksi) == 0 {
        pulang betul;
    }

    biar hash_sebelumnya_dijangka = "genesis";

    untuk catatan dalam log_transaksi {
        kalau catatan.hash_catatan_sebelumnya != hash_sebelumnya_dijangka {
            cetak_baris("AMARAN: Integritas audit trail terputus!");
            pulang salah;
        }

        hash_sebelumnya_dijangka = hitung_hash_catatan(catatan);
    }

    cetak_baris("Integritas audit trail: OK");
    pulang betul;
}

/// Audit all data changes
fungsi rekod_perubahan_data(
    lapangan: Teks,
    nilai_lama: Teks,
    nilai_baru: Teks,
    pengguna: Teks,
    alasan: Teks
) -> kesan Bersih {
    biar perubahan = {
        masa_perubahan: Masa::masa_unix(),
        lapangan: lapangan,
        nilai_lama: nilai_lama,
        nilai_baru: nilai_baru,
        pengguna_id: pengguna,
        alasan_audit: alasan,
    };

    log_perubahan = log_perubahan + [perubahan];

    cetak_baris(format!(
        "Perubahan data dicatat: {} diubah oleh {} ({})",
        lapangan,
        pengguna,
        alasan
    ));
}

/// SOX 404: Access control verification
fungsi semak_kawalan_akses(pengguna: Teks, tindakan: Teks) -> Benar kesan Bersih {
    // Verify: Only authorized users can modify financial data
    biar pengguna_berwenang = ["kewangan_1", "kewangan_2", "auditor"];

    untuk otorisasi dalam pengguna_berwenang {
        kalau otorisasi == pengguna {
            cetak_baris(format!("Kawalan akses: {} dibenarkan untuk {}", pengguna, tindakan));
            pulang betul;
        }
    }

    cetak_baris(format!("PENOLAKAN: {} tidak berwenang untuk {}", pengguna, tindakan));
    pulang salah;
}

/// SOX 404: Segregation of duties verification
fungsi semak_pemisahan_tugas(pengguna1: Teks, pengguna2: Teks) -> Benar kesan Bersih {
    // Ensure same person can't perform incompatible duties
    // Example: Can't be both approver and executor

    cetak_baris(format!("Pemeriksaan pemisahan tugas: {} vs {}", pengguna1, pengguna2));

    kalau pengguna1 == pengguna2 {
        cetak_baris("AMARAN: Pemisahan tugas tidak memadai");
        pulang salah;
    }

    pulang betul;
}

/// Generate audit report
fungsi jana_laporan_audit(dari_masa: Nombor, hingga_masa: Nombor) -> Teks kesan Bersih {
    biar catatan_dalam_julat = [];

    untuk catatan dalam log_transaksi {
        kalau catatan.masa_transaksi >= dari_masa && catatan.masa_transaksi <= hingga_masa {
            catatan_dalam_julat = catatan_dalam_julat + [catatan];
        }
    }

    biar laporan = format!(
        "LAPORAN AUDIT SOX\nTempoh: {} hingga {}\nJumlah Transaksi: {}\n",
        dari_masa,
        hingga_masa,
        panjang(catatan_dalam_julat)
    );

    biar jumlah_semak = 0;
    untuk catatan dalam catatan_dalam_julat {
        kalau catatan.status == "tercatat" {
            jumlah_semak = jumlah_semak + 1;
        }
    }

    laporan = laporan + format!("Transaksi Tercatat: {}\n", jumlah_semak);
    laporan = laporan + "Status Integritas: OK\n";

    pulang laporan;
}

/// Retention policy for audit logs (7 years minimum)
fungsi semak_retensi_log() -> Benar kesan Bersih {
    biar tarikh_cutoff = Masa::masa_unix() - (7 * 365 * 86400);

    biar log_baru = [];
    biar dihapus = 0;

    untuk catatan dalam log_transaksi {
        kalau catatan.masa_transaksi > tarikh_cutoff {
            log_baru = log_baru + [catatan];
        } lain {
            dihapus = dihapus + 1;
        }
    }

    kalau dihapus > 0 {
        cetak_baris(format!("Catatan lama dihapus (> 7 tahun): {}", dihapus));
        log_transaksi = log_baru;
    }

    pulang betul;
}

/// Financial transaction approval workflow
fungsi proses_transaksi_kewangan(
    jenis: Teks,
    amaun: Nombor,
    pemohon: Teks,
    penyetuju: Teks
) -> Benar kesan Bersih {
    cetak_baris(format!("Memproses transaksi {} senilai {}", jenis, amaun));

    // Check approver is different from requester
    kalau !semak_pemisahan_tugas(pemohon, penyetuju) {
        cetak_baris("Pembatalan: Pemisahan tugas gagal");
        pulang salah;
    }

    // Check both are authorized
    kalau !semak_kawalan_akses(pemohon, "minta") {
        pulang salah;
    }

    kalau !semak_kawalan_akses(penyetuju, "setujui") {
        pulang salah;
    }

    // Record transaction
    catat_transaksi(jenis, amaun, "sumber", "tujuan", pemohon, penyetuju);

    cetak_baris("Transaksi diluluskan dan dicatat");
    pulang betul;
}

awam fungsi utama() -> kesan Bersih {
    cetak_baris("=== AUDIT TRAIL SOX ===");

    // Process sample transactions
    proses_transaksi_kewangan("transfer", 50000, "kewangan_1", "kewangan_2");
    proses_transaksi_kewangan("deposit", 100000, "kewangan_2", "kewangan_1");

    // Record data changes
    rekod_perubahan_data("gaji_pegawai", "5000", "5500", "kewangan_1", "peningkatan tahunan");

    // Verify integrity
    sahkan_integriti_jejak();

    // Generate report
    biar laporan = jana_laporan_audit(Masa::masa_unix() - 86400, Masa::masa_unix());
    cetak_baris(laporan);
}

// Helper functions
fungsi genera_id_transaksi() -> Teks kesan Bersih {
    pulang "TXN-" + teks::daripada_nombor(Masa::masa_unix());
}

fungsi hitung_hash_catatan(catatan: CatatanTransaksi) -> Teks kesan Bersih {
    // Simplified hash - real implementation uses SHA256
    pulang "hash_" + catatan.id_transaksi;
}

fungsi panjang(senarai: Senarai<T>) -> Nombor kesan Bersih {
    pulang 0;
}

fungsi format(s: Teks, args: Senarai<T>) -> Teks kesan Bersih {
    pulang s;
}

modul teks {
    fungsi daripada_nombor(n: Nombor) -> Teks kesan Bersih {
        pulang "";
    }
}

modul Masa {
    fungsi masa_unix() -> Nombor kesan Bersih {
        pulang 0;
    }
}

// === 07_EXAMPLES/05_patterns/builder.rii ===
/// builder.rii
/// Builder pattern for complex object construction
/// Demonstrates fluent interface and step-by-step object building
///
/// Pattern: Creational - Builder

modul corak_pembina;

guna std::teks;
guna std::senarai;

/// Product: Complex configuration object
jenis KonfigurasiPelayan = {
    nama_hos: Teks,
    pelabuhan: Nombor,
    kedalaman_thread: Nombor,
    masa_timeout: Nombor,
    membolehkan_gzip: Benar,
    sertifikat_ssl: Mungkin<Teks>,
    pengepala_tersuai: Senarai<(Teks, Teks)>,
};

/// Builder: Step-by-step construction
jenis PembinaKonfigurasi = {
    hos: Teks,
    port: Nombor,
    threads: Nombor,
    timeout: Nombor,
    gzip_enabled: Benar,
    ssl_cert: Mungkin<Teks>,
    headers: Senarai<(Teks, Teks)>,
};

/// Create empty builder
fungsi pembinabarukai() -> PembinaKonfigurasi kesan Bersih {
    pulang {
        hos: "localhost",
        port: 8080,
        threads: 10,
        timeout: 30,
        gzip_enabled: betul,
        ssl_cert: Tiada,
        headers: [],
    };
}

/// Fluent builder methods
fungsi tetapkan_hos(ubah pembina: PembinaKonfigurasi, hos: Teks) -> PembinaKonfigurasi kesan Bersih {
    pembina.hos = hos;
    pulang pembina;
}

fungsi tetapkan_pelabuhan(ubah pembina: PembinaKonfigurasi, pelabuhan: Nombor) -> PembinaKonfigurasi kesan Bersih {
    pembina.port = pelabuhan;
    pulang pembina;
}

fungsi tetapkan_thread(ubah pembina: PembinaKonfigurasi, jumlah: Nombor) -> PembinaKonfigurasi kesan Bersih {
    pembina.threads = jumlah;
    pulang pembina;
}

fungsi tetapkan_timeout(ubah pembina: PembinaKonfigurasi, saat: Nombor) -> PembinaKonfigurasi kesan Bersih {
    pembina.timeout = saat;
    pulang pembina;
}

fungsi dayakan_gzip(ubah pembina: PembinaKonfigurasi, aktif: Benar) -> PembinaKonfigurasi kesan Bersih {
    pembina.gzip_enabled = aktif;
    pulang pembina;
}

fungsi tetapkan_ssl(ubah pembina: PembinaKonfigurasi, laluan_cert: Teks) -> PembinaKonfigurasi kesan Bersih {
    pembina.ssl_cert = Ada(laluan_cert);
    pulang pembina;
}

fungsi tambah_pengepala(ubah pembina: PembinaKonfigurasi, kunci: Teks, nilai: Teks) -> PembinaKonfigurasi kesan Bersih {
    pembina.headers = pembina.headers + [(kunci, nilai)];
    pulang pembina;
}

/// Build final object with validation
fungsi bina(pembina: PembinaKonfigurasi) -> Mungkin<KonfigurasiPelayan> kesan Bersih {
    // Validate required fields
    kalau teks::panjang(pembina.hos) == 0 {
        cetak_baris("Ralat: Hos harus ditentukan");
        pulang Tiada;
    }

    kalau pembina.port <= 0 || pembina.port > 65535 {
        cetak_baris("Ralat: Pelabuhan tidak sah");
        pulang Tiada;
    }

    kalau pembina.threads <= 0 {
        cetak_baris("Ralat: Thread harus > 0");
        pulang Tiada;
    }

    // Build the object
    biar konfigurasi = {
        nama_hos: pembina.hos,
        pelabuhan: pembina.port,
        kedalaman_thread: pembina.threads,
        masa_timeout: pembina.timeout,
        membolehkan_gzip: pembina.gzip_enabled,
        sertifikat_ssl: pembina.ssl_cert,
        pengepala_tersuai: pembina.headers,
    };

    cetak_baris("Konfigurasi pembina berjaya");
    pulang Ada(konfigurasi);
}

/// Display configuration
fungsi papar_konfigurasi(config: KonfigurasiPelayan) -> kesan Bersih {
    cetak_baris("=== KONFIGURASI PELAYAN ===");
    cetak_baris(format!("Hos: {}", config.nama_hos));
    cetak_baris(format!("Pelabuhan: {}", config.pelabuhan));
    cetak_baris(format!("Thread: {}", config.kedalaman_thread));
    cetak_baris(format!("Timeout: {} saat", config.masa_timeout));
    cetak_baris(format!("GZip: {}", config.membolehkan_gzip));

    padan config.sertifikat_ssl {
        Ada(cert) => cetak_baris(format!("Sertifikat SSL: {}", cert)),
        Tiada => cetak_baris("SSL: Dimatikan"),
    };

    cetak_baris(format!("Pengepala Tersuai: {}", panjang(config.pengepala_tersuai)));
}

/// Example usage
awam fungsi utama() -> kesan Bersih {
    cetak_baris("=== CORAK PEMBINA ===\n");

    // Build configuration with fluent interface
    biar pembina = pembinabarukai();

    biar pembina_dikonfigurasi = tetapkan_hos(pembina, "api.contoh.my")
        |> tetapkan_pelabuhan(_, 443)
        |> tetapkan_thread(_, 50)
        |> tetapkan_timeout(_, 60)
        |> dayakan_gzip(_, betul)
        |> tetapkan_ssl(_, "/etc/ssl/cert.pem")
        |> tambah_pengepala(_, "X-API-Version", "2.0");

    // Build and validate
    biar mungkin_config = bina(pembina_dikonfigurasi);

    padan mungkin_config {
        Ada(config) => {
            papar_konfigurasi(config);
        },
        Tiada => {
            cetak_baris("Konfigurasi tidak sah");
        },
    };
}

// Helper functions
modul teks {
    fungsi panjang(t: Teks) -> Nombor kesan Bersih {
        pulang 0;
    }
}

fungsi panjang(senarai: Senarai<T>) -> Nombor kesan Bersih {
    pulang 0;
}

fungsi format(s: Teks, arg: Teks) -> Teks kesan Bersih {
    pulang s;
}

// === 07_EXAMPLES/05_patterns/command.rii ===
/// command.rii
/// Command pattern with undo/redo capability
/// Demonstrates encapsulating requests as objects

modul corak_arahan;

guna std::teks;
guna std::senarai;

jenis Arahan =
    | TAMBAH(Nombor)
    | TOLAK(Nombor)
    | DARAB(Nombor)
    | BAHAGI(Nombor);

jenis RekodArah = {
    arahan: Arahan,
    nilai_lama: Nombor,
    nilai_baru: Nombor,
};

biar ubah nilai_semasa: Nombor = 0;
biar ubah sejarah_arahan: Senarai<RekodArah> = [];

fungsi jalankan(arahan: Arahan) -> kesan Bersih {
    biar nilai_awal = nilai_semasa;

    padan arahan {
        TAMBAH(n) => nilai_semasa = nilai_semasa + n,
        TOLAK(n) => nilai_semasa = nilai_semasa - n,
        DARAB(n) => nilai_semasa = nilai_semasa * n,
        BAHAGI(n) => kalau n != 0 { nilai_semasa = nilai_semasa / n },
    };

    biar rekod = {
        arahan: arahan,
        nilai_lama: nilai_awal,
        nilai_baru: nilai_semasa,
    };

    sejarah_arahan = sejarah_arahan + [rekod];
    cetak_baris(format!("Arahan dijalankan: {} -> {}", nilai_awal, nilai_semasa));
}

fungsi buat_semula() -> kesan Bersih {
    kalau panjang(sejarah_arahan) > 0 {
        biar indeks_akhir = panjang(sejarah_arahan) - 1;
        biar rekod_akhir = sejarah_arahan[indeks_akhir];

        nilai_semasa = rekod_akhir.nilai_lama;
        sejarah_arahan = buang_akhir(sejarah_arahan);

        cetak_baris(format!("Buat semula: {} <- {}", nilai_semasa, rekod_akhir.nilai_baru));
    }
}

awam fungsi utama() -> kesan Bersih {
    cetak_baris("=== CORAK ARAHAN ===\n");

    jalankan(TAMBAH(10));
    jalankan(DARAB(2));
    jalankan(TOLAK(5));

    cetak_baris(format!("Nilai akhir: {}", nilai_semasa));

    buat_semula();
    cetak_baris(format!("Selepas buat semula: {}", nilai_semasa));
}

fungsi panjang(senarai: Senarai<T>) -> Nombor kesan Bersih {
    pulang 0;
}

fungsi buang_akhir(senarai: Senarai<T>) -> Senarai<T> kesan Bersih {
    pulang [];
}

fungsi format(s: Teks, arg: T) -> Teks kesan Bersih {
    pulang s;
}

// === 07_EXAMPLES/05_patterns/factory.rii ===
/// factory.rii
/// Factory pattern for creating objects without specifying classes
/// Demonstrates polymorphic object creation

modul corak_kilang;

guna std::teks;

jenis JenisPenyimpanan = FAIL | PERKHIDMATAN | CACHE;

/// Abstract product
jenis Penyimpanan = {
    jenis: JenisPenyimpanan,
    nama: Teks,
};

/// Factory function
fungsi ciptakan_penyimpanan(jenis: JenisPenyimpanan) -> Penyimpanan kesan Bersih {
    padan jenis {
        FAIL => {
            cetak_baris("Membuat penyimpanan fail");
            {
                jenis: FAIL,
                nama: "PenyimpananFail",
            }
        },
        PERKHIDMATAN => {
            cetak_baris("Membuat penyimpanan perkhidmatan");
            {
                jenis: PERKHIDMATAN,
                nama: "PenyimpananPerkhidmatan",
            }
        },
        CACHE => {
            cetak_baris("Membuat penyimpanan cache");
            {
                jenis: CACHE,
                nama: "PenyimpananCache",
            }
        },
    };
}

fungsi simpan(penyimpanan: Penyimpanan, kunci: Teks, nilai: Teks) -> kesan Bersih {
    padan penyimpanan.jenis {
        FAIL => cetak_baris(format!("Menyimpan ke fail: {} = {}", kunci, nilai)),
        PERKHIDMATAN => cetak_baris(format!("Menyimpan ke API: {} = {}", kunci, nilai)),
        CACHE => cetak_baris(format!("Menyimpan ke cache: {} = {}", kunci, nilai)),
    };
}

awam fungsi utama() -> kesan Bersih {
    cetak_baris("=== CORAK KILANG ===\n");

    // Factory creates appropriate storage
    biar penyimpanan_fail = ciptakan_penyimpanan(FAIL);
    biar penyimpanan_cache = ciptakan_penyimpanan(CACHE);

    simpan(penyimpanan_fail, "data", "nilai1");
    simpan(penyimpanan_cache, "cache", "nilai2");
}

fungsi format(s: Teks, a: Teks) -> Teks kesan Bersih {
    pulang s;
}

// === 07_EXAMPLES/05_patterns/iterator.rii ===
/// iterator.rii
/// Iterator pattern for sequential access to collection elements
/// Demonstrates abstraction of iteration logic

modul corak_pengulangi;

guna std::senarai;
guna std::teks;

jenis Pengulangi = {
    elemen_semasa: Nombor,
    senarai_lengkap: Senarai<Teks>,
};

fungsi cipta_pengulangi(senarai: Senarai<Teks>) -> Pengulangi kesan Bersih {
    pulang {
        elemen_semasa: 0,
        senarai_lengkap: senarai,
    };
}

fungsi ada_seterusnya(ubah pengulangi: Pengulangi) -> Benar kesan Bersih {
    pulang pengulangi.elemen_semasa < panjang(pengulangi.senarai_lengkap);
}

fungsi dapat_seterusnya(ubah pengulangi: Pengulangi) -> Mungkin<Teks> kesan Bersih {
    kalau ada_seterusnya(pengulangi) {
        biar nilai = pengulangi.senarai_lengkap[pengulangi.elemen_semasa];
        pengulangi.elemen_semasa = pengulangi.elemen_semasa + 1;
        pulang Ada(nilai);
    }

    pulang Tiada;
}

awam fungsi utama() -> kesan Bersih {
    cetak_baris("=== CORAK PENGULANGI ===\n");

    biar senarai = ["pertama", "kedua", "ketiga"];
    biar ubah pengulangi = cipta_pengulangi(senarai);

    ulang {
        padan dapat_seterusnya(pengulangi) {
            Ada(nilai) => cetak_baris(format!("- {}", nilai)),
            Tiada => ulang_akhir,
        };
    };
}

fungsi panjang(senarai: Senarai<T>) -> Nombor kesan Bersih {
    pulang 0;
}

fungsi format(s: Teks, arg: Teks) -> Teks kesan Bersih {
    pulang s;
}

// === 07_EXAMPLES/05_patterns/lens.rii ===
/// lens.rii
/// Lens pattern for functional updates to nested data
/// Demonstrates composition of getters and setters

modul corak_binaan;

guna std::teks;

/// Lens definition
jenis Binaan<S, T> = {
    dapat: S -> T,
    tetapkan: (T, S) -> S,
};

/// Person with Address
jenis Alamat = {
    jalan: Teks,
    bandar: Teks,
    negeri: Teks,
};

jenis Orang = {
    nama: Teks,
    umur: Nombor,
    alamat: Alamat,
};

/// Create lenses
fungsi lens_alamat() -> Binaan<Orang, Alamat> kesan Bersih {
    pulang {
        dapat: fungi(orang: Orang) -> Alamat { orang.alamat },
        tetapkan: fungi(alamat_baru: Alamat, orang: Orang) -> Orang {
            {
                nama: orang.nama,
                umur: orang.umur,
                alamat: alamat_baru,
            }
        },
    };
}

fungsi lens_bandar() -> Binaan<Alamat, Teks> kesan Bersih {
    pulang {
        dapat: fungi(alamat: Alamat) -> Teks { alamat.bandar },
        tetapkan: fungi(bandar_baru: Teks, alamat: Alamat) -> Alamat {
            {
                jalan: alamat.jalan,
                bandar: bandar_baru,
                negeri: alamat.negeri,
            }
        },
    };
}

/// Compose lenses
fungsi gubah_binaan<A, B, C>(
    lens1: Binaan<A, B>,
    lens2: Binaan<B, C>
) -> Binaan<A, C> kesan Bersih {
    pulang {
        dapat: fungi(a: A) -> C {
            biar b = lens1.dapat(a);
            lens2.dapat(b);
        },
        tetapkan: fungi(c_baru: C, a: A) -> A {
            biar b = lens1.dapat(a);
            biar b_baru = lens2.tetapkan(c_baru, b);
            lens1.tetapkan(b_baru, a);
        },
    };
}

awam fungsi utama() -> kesan Bersih {
    cetak_baris("=== CORAK BINAAN ===\n");

    biar orang_asal = {
        nama: "Ahmad",
        umur: 30,
        alamat: {
            jalan: "Jalan Merdeka",
            bandar: "Kuala Lumpur",
            negeri: "Selangor",
        },
    };

    // Compose lenses: orang -> alamat -> bandar
    biar lens_A = lens_alamat();
    biar lens_B = lens_bandar();
    biar lens_gubahan = gubah_binaan(lens_A, lens_B);

    biar bandar_semasa = lens_gubahan.dapat(orang_asal);
    cetak_baris(format!("Bandar semasa: {}", bandar_semasa));

    biar orang_baru = lens_gubahan.tetapkan("Shah Alam", orang_asal);
    biar bandar_baru = lens_gubahan.dapat(orang_baru);
    cetak_baris(format!("Bandar baru: {}", bandar_baru));
}

fungsi format(s: Teks, arg: Teks) -> Teks kesan Bersih {
    pulang s;
}

// === 07_EXAMPLES/05_patterns/monad_result.rii ===
/// monad_result.rii
/// Monad Result pattern for composing fallible computations
/// Demonstrates Result type and chaining operations

modul monad_hasil;

guna std::teks;

/// Result monad with binding
jenis Hasil<T> =
    | Berjaya(T)
    | Gagal(Teks);

/// Return successful value
fungsi balik<T>(nilai: T) -> Hasil<T> kesan Bersih {
    pulang Berjaya(nilai);
}

/// Return error
fungsi ralat<T>(mesej: Teks) -> Hasil<T> kesan Bersih {
    pulang Gagal(mesej);
}

/// Chain Result computations (bind/flatMap)
fungsi ikat<T, U>(
    hasil: Hasil<T>,
    f: T -> Hasil<U>
) -> Hasil<U> kesan Bersih {
    padan hasil {
        Berjaya(nilai) => f(nilai),
        Gagal(mesej) => Gagal(mesej),
    };
}

/// Map over Result
fungsi peta<T, U>(hasil: Hasil<T>, f: T -> U) -> Hasil<U> kesan Bersih {
    padan hasil {
        Berjaya(nilai) => Berjaya(f(nilai)),
        Gagal(mesej) => Gagal(mesej),
    };
}

/// Safe integer parsing
fungsi huraikan_int(teks: Teks) -> Hasil<Nombor> kesan Bersih {
    padan teks::ke_nombor(teks) {
        Ada(n) => Berjaya(n),
        Tiada => Gagal("Bukan nombor sah"),
    };
}

/// Demonstrate monad chaining
awam fungsi utama() -> kesan Bersih {
    cetak_baris("=== MONAD HASIL ===\n");

    // Success case: "42" -> 42 -> 42*2 = 84
    biar hasil_1 = huraikan_int("42");
    biar hasil_2 = peta(hasil_1, fungi(n: Nombor) -> Nombor { pulang n * 2; });

    padan hasil_2 {
        Berjaya(n) => cetak_baris(format!("Berjaya: {}", n)),
        Gagal(m) => cetak_baris(format!("Ralat: {}", m)),
    };

    // Failure case: "abc" -> Gagal
    biar hasil_3 = huraikan_int("abc");
    padan hasil_3 {
        Berjaya(n) => cetak_baris(format!("Berjaya: {}", n)),
        Gagal(m) => cetak_baris(format!("Ralat: {}", m)),
    };
}

modul teks {
    fungsi ke_nombor(t: Teks) -> Mungkin<Nombor> kesan Bersih {
        pulang Tiada;
    }
}

fungsi format(s: Teks, arg: T) -> Teks kesan Bersih {
    pulang s;
}

// === 07_EXAMPLES/05_patterns/newtype.rii ===
/// newtype.rii
/// Newtype pattern for wrapping types with semantic meaning
/// Demonstrates type-safe wrapper around primitives

modul jenis_baru;

guna std::teks;

/// Semantic wrappers
jenis ID = ID(Teks);
jenis Emel = Emel(Teks);
jenis Senggatan = Senggatan(Nombor);

/// Extract value
fungsi ambil_id(ID(nilai): ID) -> Teks kesan Bersih {
    pulang nilai;
}

fungsi ambil_emel(Emel(nilai): Emel) -> Teks kesan Bersih {
    pulang nilai;
}

fungsi ambil_senggatan(Senggatan(nilai): Senggatan) -> Nombor kesan Bersih {
    pulang nilai;
}

/// Safe operations only accept correct types
fungsi hantar_emel(emel: Emel, mesej: Teks) -> kesan Bersih {
    biar alamat = ambil_emel(emel);
    cetak_baris(format!("Menghantar ke {}: {}", alamat, mesej));
}

fungsi terapkan_senggatan(ubah senarai: Senarai<Teks>, senggatan: Senggatan) -> kesan Bersih {
    biar jumlah = ambil_senggatan(senggatan);
    cetak_baris(format!("Menerapkan senggatan {} elemen pertama", jumlah));
}

awam fungsi utama() -> kesan Bersih {
    cetak_baris("=== JENIS BARU ===\n");

    biar id_pengguna = ID("user_12345");
    biar emel_pengguna = Emel("ahmad@contoh.my");
    biar senggatan = Senggatan(10);

    cetak_baris(format!("ID: {}", ambil_id(id_pengguna)));
    hantar_emel(emel_pengguna, "Selamat datang");
    terapkan_senggatan([], senggatan);
}

fungsi format(s: Teks, arg: Teks) -> Teks kesan Bersih {
    pulang s;
}

// === 07_EXAMPLES/05_patterns/observer.rii ===
/// observer.rii
/// Observer pattern for event-driven updates
/// Demonstrates publish-subscribe mechanism

modul corak_pemerhati;

guna std::teks;
guna std::senarai;

/// Observer callback type
jenis PemerhatiPerubahan = {
    nama: Teks,
    fungsi_update: Teks,
};

/// Subject that notifies observers
jenis SubjekPerubahan = {
    keadaan: Teks,
    pemerhati: Senarai<PemerhatiPerubahan>,
};

biar ubah subjek: SubjekPerubahan = {
    keadaan: "awal",
    pemerhati: [],
};

fungsi daftarkan_pemerhati(nama: Teks) -> kesan Bersih {
    biar pemerhati_baru = {
        nama: nama,
        fungsi_update: "update_" + nama,
    };

    subjek.pemerhati = subjek.pemerhati + [pemerhati_baru];
    cetak_baris(format!("Pemerhati {} didaftarkan", nama));
}

fungsi ubah_keadaan(keadaan_baru: Teks) -> kesan Bersih {
    subjek.keadaan = keadaan_baru;
    cetak_baris(format!("Keadaan berubah ke: {}", keadaan_baru));

    // Notify all observers
    untuk pemerhati dalam subjek.pemerhati {
        cetak_baris(format!("Memaklumi {}: {}", pemerhati.nama, keadaan_baru));
    }
}

awam fungsi utama() -> kesan Bersih {
    cetak_baris("=== CORAK PEMERHATI ===\n");

    daftarkan_pemerhati("Logger");
    daftarkan_pemerhati("AlertingSystem");
    daftarkan_pemerhati("Dashboard");

    ubah_keadaan("sedang memproses");
    ubah_keadaan("siap");
}

fungsi format(s: Teks, arg: Teks) -> Teks kesan Bersih {
    pulang s;
}

// === 07_EXAMPLES/05_patterns/phantom_types.rii ===
/// phantom_types.rii
/// Phantom types pattern for type-level state without runtime cost
/// Demonstrates zero-cost abstractions

modul jenis_phantom;

guna std::teks;

/// Phantom type parameters (not used in data)
jenis Belum_Disahkan;
jenis Disahkan;
jenis Dienkripsi;

/// Value with phantom type state
jenis KataLaluan<State> = {
    nilai: Teks,
};

/// Create unverified password
fungsi cipta_katalaluan(nilai: Teks) -> KataLaluan<Belum_Disahkan> kesan Bersih {
    cetak_baris(format!("Cipta kata laluan: {} (belum disahkan)", nilai));
    pulang { nilai: nilai };
}

/// Verify password (state transition)
fungsi sahkan_katalaluan(kata: KataLaluan<Belum_Disahkan>) -> KataLaluan<Disahkan> kesan Bersih {
    cetak_baris("Menyahkan kata laluan...");
    kalau panjang(kata.nilai) >= 8 {
        cetak_baris("Kata laluan sah (8+ karakter)");
        pulang { nilai: kata.nilai };
    }
    cetak_baris("Peringatan: Kata laluan pendek");
    pulang { nilai: kata.nilai };
}

/// Encrypt password (final state)
fungsi enkripsi_katalaluan(kata: KataLaluan<Disahkan>) -> KataLaluan<Dienkripsi> kesan Bersih {
    cetak_baris("Mengenkripsi kata laluan...");
    pulang { nilai: "***" };
}

awam fungsi utama() -> kesan Bersih {
    cetak_baris("=== JENIS PHANTOM ===\n");

    biar kata1 = cipta_katalaluan("MyPassword123");
    biar kata2 = sahkan_katalaluan(kata1);
    biar kata3 = enkripsi_katalaluan(kata2);

    cetak_baris("Aliran keadaan selesai");
}

fungsi panjang(t: Teks) -> Nombor kesan Bersih {
    pulang 0;
}

fungsi format(s: Teks, arg: Teks) -> Teks kesan Bersih {
    pulang s;
}

// === 07_EXAMPLES/05_patterns/repository.rii ===
/// repository.rii
/// Repository pattern for data access abstraction
/// Demonstrates separation of data access from business logic

modul corak_repositori;

guna std::teks;
guna std::senarai;
guna std::fail;

jenis Pengguna = {
    id: Teks,
    nama: Teks,
    emel: Teks,
};

/// Repository interface
jenis Repositori = {
    cari_semua: () -> Senarai<Pengguna>,
    cari_mengikut_id: (Teks) -> Mungkin<Pengguna>,
    simpan: (Pengguna) -> Benar,
    padam: (Teks) -> Benar,
};

/// In-memory repository
biar ubah stor_memori: Senarai<Pengguna> = [];

fungsiRepositoriMemori() -> Repositori kesan Bersih {
    pulang {
        cari_semua: fungi() -> Senarai<Pengguna> {
            stor_memori
        },

        cari_mengikut_id: fungi(id: Teks) -> Mungkin<Pengguna> {
            untuk pengguna dalam stor_memori {
                kalau pengguna.id == id {
                    pulang Ada(pengguna);
                }
            }
            pulang Tiada;
        },

        simpan: fungi(pengguna: Pengguna) -> Benar {
            stor_memori = stor_memori + [pengguna];
            cetak_baris(format!("Menyimpan pengguna: {}", pengguna.nama));
            pulang betul;
        },

        padam: fungi(id: Teks) -> Benar {
            biar panjang_asal = panjang(stor_memori);
            stor_memori = saring(stor_memori, id);
            biar dihapus = panjang(stor_memori) < panjang_asal;
            kalau dihapus {
                cetak_baris(format!("Memadam pengguna: {}", id));
            }
            pulang dihapus;
        },
    };
}

awam fungsi utama() -> kesan Bersih {
    cetak_baris("=== CORAK REPOSITORI ===\n");

    biar repo = RepositoriMemori();

    // Create
    biar p1 = { id: "1", nama: "Ahmad", emel: "ahmad@contoh.my" };
    repo.simpan(p1);

    // Retrieve
    biar semua = repo.cari_semua();
    cetak_baris(format!("Jumlah pengguna: {}", panjang(semua)));

    // Find by ID
    biar mungkin_p = repo.cari_mengikut_id("1");
    padan mungkin_p {
        Ada(pengguna) => cetak_baris(format!("Ditemui: {}", pengguna.nama)),
        Tiada => cetak_baris("Tidak ditemui"),
    };

    // Delete
    repo.padam("1");
}

fungsi panjang(senarai: Senarai<T>) -> Nombor kesan Bersih {
    pulang 0;
}

fungsi saring(senarai: Senarai<Pengguna>, id_buang: Teks) -> Senarai<Pengguna> kesan Bersih {
    biar hasil = [];
    untuk pengguna dalam senarai {
        kalau pengguna.id != id_buang {
            hasil = hasil + [pengguna];
        }
    }
    pulang hasil;
}

fungsi format(s: Teks, arg: T) -> Teks kesan Bersih {
    pulang s;
}

// === 07_EXAMPLES/05_patterns/smart_constructor.rii ===
/// smart_constructor.rii
/// Smart constructor pattern for validated object creation
/// Demonstrates validation at construction time

modul pembina_pintar;

guna std::teks;
guna std::senarai;

/// Email type (validated)
jenis Emel = Emel(Teks);

/// Age type (range validated)
jenis Umur = Umur(Nombor);

/// User with validated fields
jenis PenggunaTersahkan = {
    nama: Teks,
    emel: Emel,
    umur: Umur,
};

/// Safe email constructor
fungsi cipta_emel(teks: Teks) -> Mungkin<Emel> kesan Bersih {
    kalau !mengandungi(teks, "@") || !mengandungi(teks, ".") {
        cetak_baris("Ralat: Emel tidak sah");
        pulang Tiada;
    }

    cetak_baris(format!("Emel sah: {}", teks));
    pulang Ada(Emel(teks));
}

/// Safe age constructor
fungsi cipta_umur(nombor: Nombor) -> Mungkin<Umur> kesan Bersih {
    kalau nombor < 0 || nombor > 150 {
        cetak_baris("Ralat: Umur tidak sah (0-150)");
        pulang Tiada;
    }

    cetak_baris(format!("Umur sah: {}", nombor));
    pulang Ada(Umur(nombor));
}

/// Safe user constructor
fungsi cipta_pengguna(
    nama: Teks,
    emel_teks: Teks,
    umur_nombor: Nombor
) -> Mungkin<PenggunaTersahkan> kesan Bersih {
    biar mungkin_emel = cipta_emel(emel_teks);
    biar mungkin_umur = cipta_umur(umur_nombor);

    padan (mungkin_emel, mungkin_umur) {
        (Ada(emel), Ada(umur)) => {
            cetak_baris("Pengguna dicipta berjaya");
            pulang Ada({
                nama: nama,
                emel: emel,
                umur: umur,
            });
        },
        _ => {
            cetak_baris("Gagal mencipta pengguna");
            pulang Tiada;
        },
    };
}

awam fungsi utama() -> kesan Bersih {
    cetak_baris("=== PEMBINA PINTAR ===\n");

    // Valid user
    biar mungkin_p1 = cipta_pengguna("Ahmad", "ahmad@contoh.my", 30);
    padan mungkin_p1 {
        Ada(_) => cetak_baris("Pengguna 1: OK"),
        Tiada => cetak_baris("Pengguna 1: GAGAL"),
    };

    // Invalid email
    biar mungkin_p2 = cipta_pengguna("Nurul", "emel_tidak_sah", 25);
    padan mungkin_p2 {
        Ada(_) => cetak_baris("Pengguna 2: OK"),
        Tiada => cetak_baris("Pengguna 2: GAGAL"),
    };

    // Invalid age
    biar mungkin_p3 = cipta_pengguna("Fatima", "fatima@contoh.my", 200);
    padan mungkin_p3 {
        Ada(_) => cetak_baris("Pengguna 3: OK"),
        Tiada => cetak_baris("Pengguna 3: GAGAL"),
    };
}

fungsi mengandungi(teks: Teks, cari: Teks) -> Benar kesan Bersih {
    pulang betul;
}

fungsi format(s: Teks, arg: T) -> Teks kesan Bersih {
    pulang s;
}

// === 07_EXAMPLES/05_patterns/state_machine.rii ===
/// state_machine.rii
/// State machine pattern for managing object state transitions
/// Demonstrates finite state machine with validation

modul mesin_keadaan;

guna std::teks;

jenis KeadaanPesanan = BELUM_DIPROSES | SEDANG_DIPROSES | LENGKAP | DIBATALKAN;

jenis Pesanan = {
    id: Teks,
    keadaan_semasa: KeadaanPesanan,
    nilai: Nombor,
};

/// Validate state transitions
fungsi sah_transisi(dari: KeadaanPesanan, ke: KeadaanPesanan) -> Benar kesan Bersih {
    padan (dari, ke) {
        (BELUM_DIPROSES, SEDANG_DIPROSES) => betul,
        (BELUM_DIPROSES, DIBATALKAN) => betul,
        (SEDANG_DIPROSES, LENGKAP) => betul,
        (SEDANG_DIPROSES, DIBATALKAN) => betul,
        (LENGKAP, _) => salah,  // Final state
        (DIBATALKAN, _) => salah,  // Final state
        _ => salah,
    };
}

fungsi ubah_keadaan(ubah pesanan: Pesanan, keadaan_baru: KeadaanPesanan) -> Benar kesan Bersih {
    kalau !sah_transisi(pesanan.keadaan_semasa, keadaan_baru) {
        cetak_baris(format!("Transisi tidak sah: {} -> {}", keadaan_txt(pesanan.keadaan_semasa), keadaan_txt(keadaan_baru)));
        pulang salah;
    }

    pesanan.keadaan_semasa = keadaan_baru;
    cetak_baris(format!("Pesanan {} sekarang: {}", pesanan.id, keadaan_txt(keadaan_baru)));
    pulang betul;
}

awam fungsi utama() -> kesan Bersih {
    cetak_baris("=== MESIN KEADAAN ===\n");

    biar ubah pesanan = {
        id: "ORD-123",
        keadaan_semasa: BELUM_DIPROSES,
        nilai: 500,
    };

    ubah_keadaan(pesanan, SEDANG_DIPROSES);
    ubah_keadaan(pesanan, LENGKAP);
    ubah_keadaan(pesanan, DIBATALKAN);  // Invalid transition
}

fungsi keadaan_txt(keadaan: KeadaanPesanan) -> Teks kesan Bersih {
    padan keadaan {
        BELUM_DIPROSES => "Belum Diproses",
        SEDANG_DIPROSES => "Sedang Diproses",
        LENGKAP => "Lengkap",
        DIBATALKAN => "Dibatalkan",
    };
}

fungsi format(s: Teks, args: Senarai<Teks>) -> Teks kesan Bersih {
    pulang s;
}

// === 07_EXAMPLES/05_patterns/strategy.rii ===
/// strategy.rii
/// Strategy pattern for encapsulating algorithms
/// Demonstrates algorithm selection at runtime

modul corak_strategi;

guna std::teks;
guna std::senarai;

jenis StrategiPenyaringan = ASCEND | DESCEND | RAWAK;

fungsi sortir_nombor(senarai: Senarai<Nombor>, strategi: StrategiPenyaringan) -> Senarai<Nombor> kesan Bersih {
    padan strategi {
        ASCEND => {
            cetak_baris("Menyortir: Menaik");
            sortir_menaik(senarai);
        },
        DESCEND => {
            cetak_baris("Menyortir: Menurun");
            sortir_menurun(senarai);
        },
        RAWAK => {
            cetak_baris("Menyortir: Rawak");
            sortir_rawak(senarai);
        },
    };
}

fungsi sortir_menaik(senarai: Senarai<Nombor>) -> Senarai<Nombor> kesan Bersih {
    // Bubble sort implementation
    pulang senarai;
}

fungsi sortir_menurun(senarai: Senarai<Nombor>) -> Senarai<Nombor> kesan Bersih {
    // Reverse sort
    pulang senarai;
}

fungsi sortir_rawak(senarai: Senarai<Nombor>) -> Senarai<Nombor> kesan Bersih {
    // Fisher-Yates shuffle
    pulang senarai;
}

awam fungsi utama() -> kesan Bersih {
    cetak_baris("=== CORAK STRATEGI ===\n");

    biar data = [5, 2, 8, 1, 9];

    biar hasil_menaik = sortir_nombor(data, ASCEND);
    biar hasil_menurun = sortir_nombor(data, DESCEND);
}

// === 07_EXAMPLES/05_patterns/type_state.rii ===
/// type_state.rii
/// Typestate pattern for compile-time protocol enforcement
/// Demonstrates state-dependent valid operations

modul keadaan_jenis;

guna std::teks;

/// Phantom state types
jenis Tertutup;
jenis Dibuka;
jenis Dibaca;

/// File with phantom state
jenis File<State> = {
    nama: Teks,
    kandungan: Teks,
};

/// Open file (Tertutup -> Dibuka)
fungsi buka_fail(fail: File<Tertutup>) -> File<Dibuka> kesan Bersih {
    cetak_baris(format!("Membuka fail: {}", fail.nama));
    pulang {
        nama: fail.nama,
        kandungan: fail.kandungan,
    };
}

/// Read from open file (Dibuka -> Dibaca)
fungsi baca_fail(fail: File<Dibuka>) -> (Teks, File<Dibaca>) kesan Bersih {
    cetak_baris(format!("Membaca fail: {}", fail.nama));
    pulang (fail.kandungan, {
        nama: fail.nama,
        kandungan: fail.kandungan,
    });
}

/// Close file (Any open state -> Tertutup)
fungsi tutup_fail(fail: File<Dibaca>) -> File<Tertutup> kesan Bersih {
    cetak_baris(format!("Menutup fail: {}", fail.nama));
    pulang {
        nama: fail.nama,
        kandungan: fail.kandungan,
    };
}

awam fungsi utama() -> kesan Bersih {
    cetak_baris("=== KEADAAN JENIS ===\n");

    biar fail_tertutup: File<Tertutup> = {
        nama: "data.txt",
        kandungan: "Isi fail",
    };

    biar fail_dibuka = buka_fail(fail_tertutup);
    biar (isi, fail_dibaca) = baca_fail(fail_dibuka);
    cetak_baris(format!("Isi: {}", isi));

    biar fail_tertutup_lagi = tutup_fail(fail_dibaca);
    cetak_baris("Fail ditutup dengan selamat");
}

fungsi format(s: Teks, arg: Teks) -> Teks kesan Bersih {
    pulang s;
}

// === 07_EXAMPLES/05_patterns/visitor.rii ===
/// visitor.rii
/// Visitor pattern for separate operations on object structures
/// Demonstrates double dispatch

modul corak_pelawat;

guna std::teks;

jenis NodesPokok =
    | Nombor(Nombor)
    | Penambahan(NodesPokok, NodesPokok)
    | Pendaraban(NodesPokok, NodesPokok);

/// Visitor interface
jenis PelawatOperasi = {
    nama: Teks,
};

/// Evaluate the expression
fungsi nilaikan(node: NodesPokok) -> Nombor kesan Bersih {
    padan node {
        Nombor(n) => n,
        Penambahan(kiri, kanan) => nilaikan(kiri) + nilaikan(kanan),
        Pendaraban(kiri, kanan) => nilaikan(kiri) * nilaikan(kanan),
    };
}

/// Print the expression
fungsi cetak_ungkapan(node: NodesPokok) -> Teks kesan Bersih {
    padan node {
        Nombor(n) => format!("{}", n),
        Penambahan(kiri, kanan) => {
            format!("({} + {})", cetak_ungkapan(kiri), cetak_ungkapan(kanan))
        },
        Pendaraban(kiri, kanan) => {
            format!("({} * {})", cetak_ungkapan(kiri), cetak_ungkapan(kanan))
        },
    };
}

awam fungsi utama() -> kesan Bersih {
    cetak_baris("=== CORAK PELAWAT ===\n");

    // Build expression: (3 + 4) * 5
    biar ekspresi = Pendaraban(
        Penambahan(Nombor(3), Nombor(4)),
        Nombor(5)
    );

    biar teks_ekspresi = cetak_ungkapan(ekspresi);
    cetak_baris(format!("Ungkapan: {}", teks_ekspresi));

    biar hasil = nilaikan(ekspresi);
    cetak_baris(format!("Nilai: {}", hasil));
}

fungsi format(s: Teks, arg: T) -> Teks kesan Bersih {
    pulang s;
}

// === 07_EXAMPLES/gelung.rii ===
// gelung.rii â€” Loop and conditional test
// RIINA = Rigorous Immutable Invariant â€” Normalized Axiom

biar x = 10;

selagi x > 0 {
    cetakln(ke_teks(x))
};

ulang {
    cetakln("sekali sahaja")
};

kalau x == 10 {
    cetakln("x ialah sepuluh")
} lain {
    cetakln("x bukan sepuluh")
}

// === 07_EXAMPLES/hello_dunia.rii ===
// hello_dunia.rii
// RIINA = Rigorous Immutable Invariant â€” Normalized Axiom
//
// Basic "Hello World" in Bahasa Melayu syntax

// Module declaration
modul hello_dunia;

// Import I/O operations
guna std::io;

// Main function with effect annotation
// kesan Tulis = this function has Write effect
awam fungsi utama() -> kesan Tulis {
    // Variable binding using 'biar' (let)
    biar mesej = "Selamat datang ke RIINA!";
    biar nama = "Dunia";

    // String interpolation
    biar salam = format!("{} Hello, {}!", mesej, nama);

    // Output with effect
    laku Tulis cetak_baris(salam);

    // Return unit value
    pulang ();
}

// Pure function (no effects)
fungsi tambah(x: Nombor, y: Nombor) -> Nombor kesan Bersih {
    pulang x + y;
}

// Function with mutable parameter
fungsi kira_senarai(ubah senarai: Senarai<Nombor>) -> Nombor {
    biar ubah jumlah = 0;

    // For loop using 'untuk' and 'dalam'
    untuk nilai dalam senarai {
        jumlah = jumlah + nilai;
    }

    pulang jumlah;
}

// Conditional logic
fungsi semak_positif(n: Nombor) -> Benar {
    kalau n > 0 {
        pulang betul;
    } lain {
        pulang salah;
    }
}

// Pattern matching with 'padan'
fungsi gambar_nombor(n: Nombor) -> Teks {
    padan n {
        0 => "kosong",
        1 => "satu",
        2 => "dua",
        3 => "tiga",
        _ => "banyak",
    }
}

// === 07_EXAMPLES/kripto.rii ===
// kripto.rii
// RIINA = Rigorous Immutable Invariant â€” Normalized Axiom
//
// Cryptography example with effect annotations and security types

modul kripto;

// ============================================================================
// POST-QUANTUM CRYPTOGRAPHY (Kriptografi Pasca-Kuantum)
// ============================================================================

// ML-KEM (Module-Lattice Key Encapsulation Mechanism)
// Formerly known as CRYSTALS-Kyber

bentuk KunciAwamMLKEM {
    data: Bait,
}

bentuk KunciRahsiaMLKEM {
    data: Rahsia<Bait>,  // Private key is secret!
}

bentuk TeksCipher {
    data: Bait,
}

bentuk RahsiaDikongsi {
    data: Rahsia<Bait>,
}

// Generate ML-KEM key pair
// Effects: Kripto (cryptographic operation)
awam fungsi jana_kunci_mlkem() -> (KunciAwamMLKEM, KunciRahsiaMLKEM) kesan Kripto {
    masa_tetap {
        biar (awam, rahsia) = mlkem_1024::jana_pasangan();
        pulang (
            KunciAwamMLKEM { data: awam },
            KunciRahsiaMLKEM { data: rahsia }
        );
    }
}

// Encapsulate shared secret
awam fungsi kapsul(kunci_awam: KunciAwamMLKEM) -> (TeksCipher, RahsiaDikongsi) kesan Kripto {
    masa_tetap {
        biar (cipher, kongsi) = mlkem_1024::kapsul(kunci_awam.data);
        pulang (
            TeksCipher { data: cipher },
            RahsiaDikongsi { data: kongsi }
        );
    }
}

// Decapsulate shared secret
awam fungsi dekapsul(
    kunci_rahsia: KunciRahsiaMLKEM,
    cipher: TeksCipher
) -> RahsiaDikongsi kesan Kripto {
    masa_tetap {
        biar kongsi = mlkem_1024::dekapsul(kunci_rahsia.data, cipher.data);
        pulang RahsiaDikongsi { data: kongsi };
    }
}

// ============================================================================
// AUTHENTICATED ENCRYPTION (Penyulitan Tersahkan)
// ============================================================================

bentuk Kunci {
    data: Rahsia<Bait>,
}

bentuk Nonce {
    data: Bait,
}

bentuk DataTersahkan {
    cipher: Bait,
    tag: Bait,
}

// Encrypt with authentication using ChaCha20-Poly1305
awam fungsi sulit(
    kunci: Kunci,
    nonce: Nonce,
    data_berkaitan: Bait,
    teks_biasa: Rahsia<Bait>
) -> DataTersahkan kesan Kripto {
    masa_tetap {
        biar (cipher, tag) = chacha20_poly1305::sulit(
            kunci.data,
            nonce.data,
            data_berkaitan,
            teks_biasa
        );

        pulang DataTersahkan { cipher, tag };
    }
}

// Decrypt with authentication verification
awam fungsi nyahsulit(
    kunci: Kunci,
    nonce: Nonce,
    data_berkaitan: Bait,
    data_tersahkan: DataTersahkan
) -> Hasil<Rahsia<Bait>, RalatPenyahsulitan> kesan Kripto {
    masa_tetap {
        padan chacha20_poly1305::nyahsulit(
            kunci.data,
            nonce.data,
            data_berkaitan,
            data_tersahkan.cipher,
            data_tersahkan.tag
        ) {
            Jadi(teks_biasa) => pulang Jadi(teks_biasa),
            Gagal(_) => pulang Gagal(RalatPenyahsulitan::TagTidakSah),
        }
    }
}

// ============================================================================
// SECURE KEY DERIVATION (Derivasi Kunci Selamat)
// ============================================================================

// HKDF for key derivation
awam fungsi deriv_kunci(
    ikm: Rahsia<Bait>,     // Input keying material
    garam: Bait,           // Salt
    info: Bait,            // Context info
    panjang: Nombor        // Output length
) -> Rahsia<Bait> kesan Kripto {
    masa_tetap {
        // Extract phase
        biar prk = hkdf::ekstrak(garam, ikm);

        // Expand phase
        biar okm = hkdf::kembang(prk, info, panjang);

        pulang okm;
    }
}

// ============================================================================
// DIGITAL SIGNATURES (Tandatangan Digital)
// ============================================================================

// ML-DSA (Module-Lattice Digital Signature Algorithm)
// Formerly known as CRYSTALS-Dilithium

bentuk KunciTandatanganAwam {
    data: Bait,
}

bentuk KunciTandatanganRahsia {
    data: Rahsia<Bait>,
}

bentuk Tandatangan {
    data: Bait,
}

// Generate signing key pair
awam fungsi jana_kunci_tandatangan() -> (KunciTandatanganAwam, KunciTandatanganRahsia) kesan Kripto {
    masa_tetap {
        biar (awam, rahsia) = mldsa_87::jana_pasangan();
        pulang (
            KunciTandatanganAwam { data: awam },
            KunciTandatanganRahsia { data: rahsia }
        );
    }
}

// Sign a message
awam fungsi tandatangan(
    kunci_rahsia: KunciTandatanganRahsia,
    mesej: Bait
) -> Tandatangan kesan Kripto {
    masa_tetap {
        biar sig = mldsa_87::tandatangan(kunci_rahsia.data, mesej);
        pulang Tandatangan { data: sig };
    }
}

// Verify a signature
awam fungsi sahkan_tandatangan(
    kunci_awam: KunciTandatanganAwam,
    mesej: Bait,
    tandatangan: Tandatangan
) -> Benar kesan Kripto {
    masa_tetap {
        pulang mldsa_87::sahkan(kunci_awam.data, mesej, tandatangan.data);
    }
}

// ============================================================================
// SECURE MEMORY (Memori Selamat)
// ============================================================================

// Secure erasure - zeroize sensitive data
awam fungsi padam_selamat<T>(ubah data: Rahsia<T>) kesan Tulis {
    // kosongkan ensures memory is securely erased
    kosongkan data;
}

// Example: Complete encryption workflow
awam fungsi contoh_sulit_mesej(
    mesej: Teks,
    kunci_penerima: KunciAwamMLKEM
) -> (TeksCipher, DataTersahkan) kesan Kripto {
    // 1. Generate ephemeral shared secret via key encapsulation
    biar (cipher_kem, rahsia_kongsi) = kapsul(kunci_penerima);

    // 2. Derive encryption key from shared secret
    biar kunci_sulit = Kunci {
        data: deriv_kunci(
            rahsia_kongsi.data,
            b"salt-contoh",
            b"encryption-key",
            32
        )
    };

    // 3. Generate random nonce
    biar nonce = Nonce { data: jana_rawak(12) };

    // 4. Encrypt the message
    biar data_tersahkan = sulit(
        kunci_sulit,
        nonce,
        b"",  // No associated data
        sulit(mesej.ke_bait())
    );

    // 5. Securely erase the shared secret
    padam_selamat(rahsia_kongsi);

    pulang (cipher_kem, data_tersahkan);
}

// === 07_EXAMPLES/mudah.rii ===
// mudah.rii â€” Simplest compilable RIINA program

fungsi tambah(x: Int, y: Int) -> Int {
    x + y
}

tambah(3, 4)

// === 07_EXAMPLES/pemprosesan_data.rii ===
// pemprosesan_data.rii
// RIINA = Rigorous Immutable Invariant â€” Normalized Axiom
//
// Data Processing Example - Demonstrating collection operations,
// pattern matching, and secure data handling

modul pemprosesan_data;

guna std::koleksi;
guna std::io;

// ============================================================================
// DATA TYPES (Jenis Data)
// ============================================================================

// User record structure
bentuk Pengguna {
    id: Nombor,
    nama: Teks,
    umur: Nombor,
    emel: Rahsia<Teks>,  // Email is sensitive
    aktif: Benar,
}

// Transaction record
bentuk Transaksi {
    id: Nombor,
    pengguna_id: Nombor,
    jumlah: Nombor,        // Amount in cents
    jenis: JenisTransaksi,
    masa: Masa,
}

pilihan JenisTransaksi {
    Deposit,
    Pengeluaran,
    Pindahan,
}

// Processing result
bentuk HasilPemprosesan {
    jumlah_diproses: Nombor,
    jumlah_berjaya: Nombor,
    jumlah_gagal: Nombor,
}

// ============================================================================
// COLLECTION OPERATIONS (Operasi Koleksi)
// ============================================================================

// Filter active users - pure function
fungsi tapis_pengguna_aktif(
    senarai: Senarai<Pengguna>
) -> Senarai<Pengguna> kesan Bersih {
    pulang senarai.tapis(|p| p.aktif);
}

// Filter users by age range
fungsi tapis_umur(
    senarai: Senarai<Pengguna>,
    min_umur: Nombor,
    max_umur: Nombor
) -> Senarai<Pengguna> kesan Bersih {
    pulang senarai.tapis(|p| p.umur >= min_umur && p.umur <= max_umur);
}

// Map: extract user IDs
fungsi dapatkan_id_pengguna(
    senarai: Senarai<Pengguna>
) -> Senarai<Nombor> kesan Bersih {
    pulang senarai.peta(|p| p.id);
}

// Fold: calculate total transaction amount
fungsi jumlah_transaksi(
    senarai: Senarai<Transaksi>
) -> Nombor kesan Bersih {
    pulang senarai.lipat(0, |jumlah, t| {
        padan t.jenis {
            JenisTransaksi::Deposit => jumlah + t.jumlah,
            JenisTransaksi::Pengeluaran => jumlah - t.jumlah,
            JenisTransaksi::Pindahan => jumlah,  // Net zero
        }
    });
}

// ============================================================================
// PATTERN MATCHING (Padanan Corak)
// ============================================================================

// Categorize transaction by amount
fungsi kategorikan_transaksi(t: Transaksi) -> Teks kesan Bersih {
    padan t.jumlah {
        0..=10000 => "kecil",            // Small: 0-100.00
        10001..=100000 => "sederhana",   // Medium: 100.01-1000.00
        100001..=1000000 => "besar",     // Large: 1000.01-10000.00
        _ => "sangat_besar",              // Very large: >10000.00
    }
}

// Process transaction with validation
fungsi proses_transaksi(
    t: Transaksi,
    baki: Nombor
) -> Hasil<Nombor, RalatTransaksi> kesan Bersih {
    padan t.jenis {
        JenisTransaksi::Deposit => {
            pulang Jadi(baki + t.jumlah);
        }
        JenisTransaksi::Pengeluaran => {
            kalau baki >= t.jumlah {
                pulang Jadi(baki - t.jumlah);
            } lain {
                pulang Gagal(RalatTransaksi::BakiTidakCukup);
            }
        }
        JenisTransaksi::Pindahan => {
            kalau baki >= t.jumlah {
                pulang Jadi(baki - t.jumlah);
            } lain {
                pulang Gagal(RalatTransaksi::BakiTidakCukup);
            }
        }
    }
}

pilihan RalatTransaksi {
    BakiTidakCukup,
    TransaksiTidakSah,
    HadMelebihi,
}

// ============================================================================
// SECURE DATA HANDLING (Pengendalian Data Selamat)
// ============================================================================

// Statistics without exposing sensitive data
bentuk StatistikPengguna {
    jumlah_pengguna: Nombor,
    purata_umur: Nombor,
    pengguna_aktif: Nombor,
}

// Calculate statistics - no secrets exposed
fungsi kira_statistik(
    senarai: Senarai<Pengguna>
) -> StatistikPengguna kesan Bersih {
    biar jumlah = senarai.panjang();
    biar jumlah_umur = senarai.lipat(0, |j, p| j + p.umur);
    biar aktif = senarai.tapis(|p| p.aktif).panjang();

    pulang StatistikPengguna {
        jumlah_pengguna: jumlah,
        purata_umur: kalau jumlah > 0 { jumlah_umur / jumlah } lain { 0 },
        pengguna_aktif: aktif,
    };
}

// Anonymize user data for export
bentuk PenggunaAnonim {
    id_rawak: Teks,
    kumpulan_umur: Teks,
    aktif: Benar,
}

fungsi anonimkan_pengguna(p: Pengguna) -> PenggunaAnonim kesan Kripto {
    biar kumpulan = padan p.umur {
        0..=17 => "bawah_umur",
        18..=25 => "muda",
        26..=45 => "dewasa",
        46..=65 => "pertengahan",
        _ => "warga_emas",
    };

    pulang PenggunaAnonim {
        id_rawak: jana_id_rawak(),
        kumpulan_umur: kumpulan,
        aktif: p.aktif,
    };
}

// ============================================================================
// BATCH PROCESSING (Pemprosesan Kelompok)
// ============================================================================

// Process batch of transactions
awam fungsi proses_kelompok(
    transaksi: Senarai<Transaksi>,
    ubah baki: Nombor
) -> HasilPemprosesan kesan Tulis {
    biar ubah berjaya = 0;
    biar ubah gagal = 0;

    untuk t dalam transaksi {
        padan proses_transaksi(t, baki) {
            Jadi(baki_baru) => {
                baki = baki_baru;
                berjaya = berjaya + 1;
                laku Tulis log_transaksi(t.id, "berjaya");
            }
            Gagal(ralat) => {
                gagal = gagal + 1;
                laku Tulis log_ralat_transaksi(t.id, ralat);
            }
        }
    }

    pulang HasilPemprosesan {
        jumlah_diproses: transaksi.panjang(),
        jumlah_berjaya: berjaya,
        jumlah_gagal: gagal,
    };
}

// Pipeline: filter -> transform -> aggregate
awam fungsi analisis_pengguna_aktif(
    pengguna: Senarai<Pengguna>,
    min_umur: Nombor
) -> StatistikPengguna kesan Bersih {
    // Filter chain
    biar ditapis = pengguna
        .tapis(|p| p.aktif)
        .tapis(|p| p.umur >= min_umur);

    // Calculate statistics on filtered data
    pulang kira_statistik(ditapis);
}

// ============================================================================
// HELPER FUNCTIONS (Fungsi Pembantu)
// ============================================================================

fungsi log_transaksi(id: Nombor, status: Teks) kesan Tulis {
    biar mesej = format!("Transaksi {}: {}", id, status);
    laku Tulis cetak_baris(mesej);
}

fungsi log_ralat_transaksi(id: Nombor, ralat: RalatTransaksi) kesan Tulis {
    biar sebab = padan ralat {
        RalatTransaksi::BakiTidakCukup => "Baki tidak mencukupi",
        RalatTransaksi::TransaksiTidakSah => "Transaksi tidak sah",
        RalatTransaksi::HadMelebihi => "Had transaksi melebihi",
    };
    biar mesej = format!("Transaksi {} gagal: {}", id, sebab);
    laku Tulis cetak_baris(mesej);
}

fungsi jana_id_rawak() -> Teks kesan Kripto {
    // Generate random UUID
    pulang kripto::uuid_v4();
}

// ============================================================================
// EXAMPLE USAGE (Contoh Penggunaan)
// ============================================================================

awam fungsi contoh_utama() kesan Tulis + Kripto {
    // Sample data
    biar pengguna = [
        Pengguna { id: 1, nama: "Ahmad", umur: 28, emel: rahsia("ahmad@contoh.com"), aktif: betul },
        Pengguna { id: 2, nama: "Siti", umur: 35, emel: rahsia("siti@contoh.com"), aktif: betul },
        Pengguna { id: 3, nama: "Muthu", umur: 42, emel: rahsia("muthu@contoh.com"), aktif: salah },
        Pengguna { id: 4, nama: "Mei Ling", umur: 25, emel: rahsia("meiling@contoh.com"), aktif: betul },
    ];

    biar transaksi = [
        Transaksi { id: 1, pengguna_id: 1, jumlah: 50000, jenis: JenisTransaksi::Deposit, masa: sekarang() },
        Transaksi { id: 2, pengguna_id: 2, jumlah: 25000, jenis: JenisTransaksi::Pengeluaran, masa: sekarang() },
        Transaksi { id: 3, pengguna_id: 1, jumlah: 10000, jenis: JenisTransaksi::Pindahan, masa: sekarang() },
    ];

    // Process and report
    biar statistik = analisis_pengguna_aktif(pengguna, 25);
    laku Tulis cetak_baris(format!("Pengguna aktif berumur 25+: {}", statistik.pengguna_aktif));

    biar ubah baki = 100000;  // Initial balance: 1000.00
    biar hasil = proses_kelompok(transaksi, baki);
    laku Tulis cetak_baris(format!("Diproses: {}, Berjaya: {}, Gagal: {}",
        hasil.jumlah_diproses, hasil.jumlah_berjaya, hasil.jumlah_gagal));
}

// === 07_EXAMPLES/pengesahan.rii ===
// pengesahan.rii
// RIINA = Rigorous Immutable Invariant â€” Normalized Axiom
//
// Authentication example demonstrating security features

modul pengesahan;

guna std::kripto;
guna std::io;

// Security levels: Terbuka (Public) and Rahsia (Secret)
// Data marked 'rahsia' cannot leak to 'terbuka' without declassification

// Structure for user credentials
bentuk Kelayakan {
    nama_pengguna: Teks,
    kata_laluan: Rahsia<Teks>,  // Password is secret!
    garam: Bait,                 // Salt for hashing
}

// Structure for authentication result
pilihan HasilPengesahan {
    Berjaya(TokenSesi),
    Gagal(SebabGagal),
}

pilihan SebabGagal {
    PenggunaTidakDitemui,
    KataLaluanSalah,
    AkaunDikunci,
}

bentuk TokenSesi {
    id: Teks,
    tamat: Masa,
}

// Hash password with constant-time comparison
// kesan Kripto = cryptographic operation effect
fungsi hash_kata_laluan(
    kata: Rahsia<Teks>,
    garam: Bait
) -> Rahsia<Bait> kesan Kripto {
    // Constant-time block prevents timing attacks
    masa_tetap {
        biar derivasi = kripto::argon2id(kata, garam);
        pulang derivasi;
    }
}

// Verify password - returns proof if successful
// The proof can be used for declassification
fungsi sahkan_kata_laluan(
    input: Rahsia<Teks>,
    tersimpan: Rahsia<Bait>,
    garam: Bait
) -> Mungkin<BuktiSahKataLaluan> kesan Kripto {
    masa_tetap {
        biar hash_input = hash_kata_laluan(input, garam);

        // Constant-time comparison
        kalau kripto::banding_tetap(hash_input, tersimpan) {
            pulang Ada(bukti KeselamatanSahKataLaluan);
        } lain {
            pulang Tiada;
        }
    }
}

// Main authentication function
awam fungsi sahkan_pengguna(
    nama: Teks,
    kata: Rahsia<Teks>,
    pangkalan: Pangkalan
) -> HasilPengesahan kesan Baca + Kripto {
    // Look up user in database
    padan pangkalan.cari_pengguna(nama) {
        Tiada => pulang HasilPengesahan::Gagal(SebabGagal::PenggunaTidakDitemui),

        Ada(pengguna) => {
            // Check if account is locked
            kalau pengguna.dikunci {
                pulang HasilPengesahan::Gagal(SebabGagal::AkaunDikunci);
            }

            // Verify password
            padan sahkan_kata_laluan(kata, pengguna.hash_kata, pengguna.garam) {
                Tiada => pulang HasilPengesahan::Gagal(SebabGagal::KataLaluanSalah),

                Ada(bukti_sah) => {
                    // Create session token
                    biar token = cipta_token_sesi(pengguna.id);
                    pulang HasilPengesahan::Berjaya(token);
                }
            }
        }
    }
}

// Example of controlled declassification
// dedah() requires proof that operation is safe
fungsi log_percubaan_log_masuk(
    nama: Teks,
    berjaya: Benar,
    bukti: BuktiAuditSah
) kesan Tulis {
    // Only the username (public) can be logged
    // The password (secret) is never exposed
    biar mesej = kalau berjaya {
        format!("Log masuk berjaya: {}", nama)
    } lain {
        format!("Log masuk gagal: {}", nama)
    };

    laku Tulis log_keselamatan(mesej);
}

// Effect handling example
fungsi dengan_perlindungan_gagal<T>(
    operasi: fungsi() -> T kesan Kripto
) -> Hasil<T, Ralat> {
    kendali operasi() dengan {
        // Handle cryptographic failures gracefully
        ralat: RalatKripto => {
            log_ralat(ralat);
            pulang Gagal(ralat);
        }
    }
}

// === 07_EXAMPLES/rentetan.rii ===
// rentetan.rii â€” String equality test
// RIINA = Rigorous Immutable Invariant â€” Normalized Axiom

biar nama = "Ahmad";
biar nama2 = "Ahmad";
biar lain_nama = "Siti";

kalau nama == nama2 {
    cetakln("Nama sama!")
} lain {
    cetakln("Nama beza!")
};

kalau nama != lain_nama {
    cetakln("Betul, nama beza")
} lain {
    cetakln("Salah")
}

