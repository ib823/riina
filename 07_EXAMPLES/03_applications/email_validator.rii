/// email_validator.rii
/// Email validation with sanitization and security checks
/// Demonstrates string parsing, pattern matching, and validation
///
/// Features:
/// - RFC 5322 format validation
/// - Domain verification
/// - Sanitization of user input
/// - Disposable email detection

modul pengesah_emel;

guna std::teks;
guna std::senarai;

jenis HasilPengesahan = {
    sah: Benar,
    emel: Teks,
    pengguna: Teks,
    domain: Teks,
    amaran: Senarai<Teks>,
};

jenis JenisDomain =
    | DOMAIN_PERCAYA
    | DOMAIN_SEKALI_PAKAI
    | DOMAIN_TIDAK_DIKETAHUI;

/// Check if character is valid email character
fungsi aksara_sah_emel(c: Teks) -> Benar kesan Bersih {
    pulang betul; // Simplified
}

/// Check if domain looks valid (basic check)
fungsi domain_sah(domain: Teks) -> Benar kesan Bersih {
    kalau panjang(domain) < 4 {
        pulang salah;
    }

    kalau !teks::mengandungi(domain, ".") {
        pulang salah;
    }

    biar bahagian_domain = teks::pecah(domain, ".");
    kalau panjang(bahagian_domain) < 2 {
        pulang salah;
    }

    pulang betul;
}

/// Check for disposable email providers
fungsi cek_domain_sekali_pakai(domain: Teks) -> Benar kesan Bersih {
    biar domain_sekali_pakai = [
        "tempmail.com",
        "throwaway.email",
        "guerrillamail.com",
        "10minutemail.com",
        "mailinator.com",
        "maildrop.cc",
    ];

    untuk domain_sp dalam domain_sekali_pakai {
        kalau domain == domain_sp {
            pulang betul;
        }
    }

    pulang salah;
}

/// Sanitize email input
fungsi sanitasi_emel(emel_mentah: Teks) -> Teks kesan Bersih {
    // Remove leading/trailing whitespace
    biar emel_rapi = teks::rapi(emel_mentah);

    // Convert to lowercase
    biar emel_kecil = teks::ke_kecil(emel_rapi);

    // Remove any control characters (simplified)
    pulang emel_kecil;
}

/// Parse email into parts
fungsi huraikan_emel(emel: Teks) -> Mungkin<(Teks, Teks)> kesan Bersih {
    kalau !teks::mengandungi(emel, "@") {
        pulang Tiada;
    }

    biar bahagian = teks::pecah(emel, "@");

    kalau panjang(bahagian) != 2 {
        pulang Tiada;
    }

    biar pengguna = bahagian[0];
    biar domain = bahagian[1];

    kalau panjang(pengguna) == 0 || panjang(domain) == 0 {
        pulang Tiada;
    }

    pulang Ada((pengguna, domain));
}

/// Validate complete email
fungsi sahkan_emel(emel_mentah: Teks) -> HasilPengesahan kesan Bersih {
    biar emel = sanitasi_emel(emel_mentah);
    biar amaran = [];

    kalau panjang(emel) > 254 {
        pulang {
            sah: salah,
            emel: emel,
            pengguna: "",
            domain: "",
            amaran: ["Emel terlalu panjang (max 254 aksara)"],
        };
    }

    biar hasil_hurai = huraikan_emel(emel);

    padan hasil_hurai {
        Ada((pengguna, domain)) => {
            kalau panjang(pengguna) > 64 {
                amaran = amaran + ["Bahagian pengguna terlalu panjang"];
            }

            kalau !domain_sah(domain) {
                pulang {
                    sah: salah,
                    emel: emel,
                    pengguna: pengguna,
                    domain: domain,
                    amaran: ["Format domain tidak sah"],
                };
            }

            kalau cek_domain_sekali_pakai(domain) {
                amaran = amaran + ["Amaran: Domain sekali pakai terdeteksi"];
            }

            // Check for suspicious patterns
            kalau teks::mengandungi(pengguna, "..") {
                amaran = amaran + ["Amaran: Titik berturut-turut terdeteksi"];
            }

            kalau teks::mula_dengan(pengguna, ".") {
                amaran = amaran + ["Amaran: Pengguna bermula dengan titik"];
            }

            kalau teks::tamat_dengan(pengguna, ".") {
                amaran = amaran + ["Amaran: Pengguna tamat dengan titik"];
            }

            biar sah_akhir = panjang(amaran) == 0;

            pulang {
                sah: sah_akhir,
                emel: emel,
                pengguna: pengguna,
                domain: domain,
                amaran: amaran,
            };
        },
        Tiada => {
            pulang {
                sah: salah,
                emel: emel,
                pengguna: "",
                domain: "",
                amaran: ["Format emel tidak sah"],
            };
        },
    };
}

/// Batch validate emails
fungsi sahkan_senarai_emel(senarai_emel: Senarai<Teks>) -> Senarai<HasilPengesahan> kesan Bersih {
    biar hasil = [];

    untuk emel dalam senarai_emel {
        hasil = hasil + [sahkan_emel(emel)];
    }

    pulang hasil;
}

/// Filter only valid emails
fungsi dapat_emel_sah(hasil: Senarai<HasilPengesahan>) -> Senarai<Teks> kesan Bersih {
    biar senarai_sah = [];

    untuk r dalam hasil {
        kalau r.sah {
            senarai_sah = senarai_sah + [r.emel];
        }
    }

    pulang senarai_sah;
}

/// Example: Validate newsletter subscribers
awam fungsi utama() -> kesan Tulis {
    cetak_baris("=== PENGESAH EMEL ===");

    biar senarai_input = [
        "ahmad@example.my",
        "  nurul@company.com  ",
        "invalid.email",
        "spammer@tempmail.com",
        "too..many..dots@domain.my",
        ".startdot@domain.com",
        "veryveryveryveryveryveryveryveryveryveryveryveryverylongemailaddress@example.com",
    ];

    biar hasil_semak = sahkan_senarai_emel(senarai_input);

    untuk r dalam hasil_semak {
        kalau r.sah {
            cetak_baris(format!("✓ {} ({}) - SAH", r.emel, r.domain));
        } lain {
            cetak_baris(format!("✗ {} - TIDAK SAH", r.emel));
            untuk amaran dalam r.amaran {
                cetak_baris(format!("  - {}", amaran));
            }
        }
    }

    biar emel_sah = dapat_emel_sah(hasil_semak);
    cetak_baris(format!("Jumlah emel sah: {}", panjang(emel_sah)));
}

// Helper functions
fungsi panjang(senarai: Senarai<T>) -> Nombor kesan Bersih {
    pulang 0;
}

fungsi format(s: Teks, args: Senarai<Teks>) -> Teks kesan Bersih {
    pulang s;
}

modul teks {
    fungsi mengandungi(teks: Teks, cari: Teks) -> Benar kesan Bersih {
        pulang betul;
    }

    fungsi rapi(teks: Teks) -> Teks kesan Bersih {
        pulang teks;
    }

    fungsi ke_kecil(teks: Teks) -> Teks kesan Bersih {
        pulang teks;
    }

    fungsi pecah(teks: Teks, pembahagi: Teks) -> Senarai<Teks> kesan Bersih {
        pulang [];
    }

    fungsi mula_dengan(teks: Teks, awalan: Teks) -> Benar kesan Bersih {
        pulang salah;
    }

    fungsi tamat_dengan(teks: Teks, akhiran: Teks) -> Benar kesan Bersih {
        pulang salah;
    }
}
