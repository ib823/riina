; SPDX-License-Identifier: MPL-2.0
; Copyright (c) 2026 The RIINA Authors.
; Auto-generated from 02_FORMAL/coq/properties/LexOrder.v (16 validations)
; Generated by scripts/generate-full-stack.py
;
; Translation Validation for LexOrder
; Layer 9: Verifies compiler backend preserves formal semantics.
; Each assertion checks source IR â‰¡ target code for a proven property.

(set-logic QF_LIA)
(set-option :produce-models true)

; IR node representation
(declare-sort IRNode 0)
(declare-sort TargetNode 0)

; lex_lt: source semantics (matches Coq)
(declare-fun source_lex_lt () Bool)
(declare-fun target_lex_lt () Bool)
(assert (= source_lex_lt target_lex_lt))

; step_ty_lt: source semantics (matches Coq)
(declare-fun source_step_ty_lt () Bool)
(declare-fun target_step_ty_lt () Bool)
(assert (= source_step_ty_lt target_step_ty_lt))

; triple_lt: source semantics (matches Coq)
(declare-fun source_triple_lt () Bool)
(declare-fun target_triple_lt () Bool)
(assert (= source_triple_lt target_triple_lt))

; lex_lt_wf: translation preserves property (matches Coq: Theorem)
(declare-fun source_lex_lt_wf () Bool)
(declare-fun target_lex_lt_wf () Bool)
(assert (= source_lex_lt_wf target_lex_lt_wf))

; lex_induction: translation preserves property (matches Coq: Theorem)
(declare-fun source_lex_induction () Bool)
(declare-fun target_lex_induction () Bool)
(assert (= source_lex_induction target_lex_induction))

; lex_lt_left: translation preserves property (matches Coq: Lemma)
(declare-fun source_lex_lt_left () Bool)
(declare-fun target_lex_lt_left () Bool)
(assert (= source_lex_lt_left target_lex_lt_left))

; lex_lt_right: translation preserves property (matches Coq: Lemma)
(declare-fun source_lex_lt_right () Bool)
(declare-fun target_lex_lt_right () Bool)
(assert (= source_lex_lt_right target_lex_lt_right))

; step_ty_lt_wf: translation preserves property (matches Coq: Theorem)
(declare-fun source_step_ty_lt_wf () Bool)
(declare-fun target_step_ty_lt_wf () Bool)
(assert (= source_step_ty_lt_wf target_step_ty_lt_wf))

; step_ty_induction: translation preserves property (matches Coq: Theorem)
(declare-fun source_step_ty_induction () Bool)
(declare-fun target_step_ty_induction () Bool)
(assert (= source_step_ty_induction target_step_ty_induction))

; step_ty_lt_step: translation preserves property (matches Coq: Lemma)
(declare-fun source_step_ty_lt_step () Bool)
(declare-fun target_step_ty_lt_step () Bool)
(assert (= source_step_ty_lt_step target_step_ty_lt_step))

; step_ty_lt_ty: translation preserves property (matches Coq: Lemma)
(declare-fun source_step_ty_lt_ty () Bool)
(declare-fun target_step_ty_lt_ty () Bool)
(assert (= source_step_ty_lt_ty target_step_ty_lt_ty))

; step_ty_lt_fn_arg: translation preserves property (matches Coq: Lemma)
(declare-fun source_step_ty_lt_fn_arg () Bool)
(declare-fun target_step_ty_lt_fn_arg () Bool)
(assert (= source_step_ty_lt_fn_arg target_step_ty_lt_fn_arg))

; step_ty_lt_fn_res: translation preserves property (matches Coq: Lemma)
(declare-fun source_step_ty_lt_fn_res () Bool)
(declare-fun target_step_ty_lt_fn_res () Bool)
(assert (= source_step_ty_lt_fn_res target_step_ty_lt_fn_res))

; step_ty_lt_prod_left: translation preserves property (matches Coq: Lemma)
(declare-fun source_step_ty_lt_prod_left () Bool)
(declare-fun target_step_ty_lt_prod_left () Bool)
(assert (= source_step_ty_lt_prod_left target_step_ty_lt_prod_left))

; step_ty_lt_prod_right: translation preserves property (matches Coq: Lemma)
(declare-fun source_step_ty_lt_prod_right () Bool)
(declare-fun target_step_ty_lt_prod_right () Bool)
(assert (= source_step_ty_lt_prod_right target_step_ty_lt_prod_right))

; step_ty_lt_sum_left: translation preserves property (matches Coq: Lemma)
(declare-fun source_step_ty_lt_sum_left () Bool)
(declare-fun target_step_ty_lt_sum_left () Bool)
(assert (= source_step_ty_lt_sum_left target_step_ty_lt_sum_left))

; step_ty_lt_sum_right: translation preserves property (matches Coq: Lemma)
(declare-fun source_step_ty_lt_sum_right () Bool)
(declare-fun target_step_ty_lt_sum_right () Bool)
(assert (= source_step_ty_lt_sum_right target_step_ty_lt_sum_right))

; step_ty_lt_step_any: translation preserves property (matches Coq: Lemma)
(declare-fun source_step_ty_lt_step_any () Bool)
(declare-fun target_step_ty_lt_step_any () Bool)
(assert (= source_step_ty_lt_step_any target_step_ty_lt_step_any))

; triple_lt_wf: translation preserves property (matches Coq: Theorem)
(declare-fun source_triple_lt_wf () Bool)
(declare-fun target_triple_lt_wf () Bool)
(assert (= source_triple_lt_wf target_triple_lt_wf))

; Verify all translation validations are satisfiable
(check-sat)
(exit)
