; SPDX-License-Identifier: MPL-2.0
; Copyright (c) 2026 The RIINA Authors.
; Auto-generated from 02_FORMAL/coq/properties/TypeMeasure.v (29 validations)
; Generated by scripts/generate-full-stack.py
;
; Translation Validation for TypeMeasure
; Layer 9: Verifies compiler backend preserves formal semantics.
; Each assertion checks source IR â‰¡ target code for a proven property.

(set-logic QF_LIA)
(set-option :produce-models true)

; IR node representation
(declare-sort IRNode 0)
(declare-sort TargetNode 0)

; ty_size_lt: source semantics (matches Coq)
(declare-fun source_ty_size_lt () Bool)
(declare-fun target_ty_size_lt () Bool)
(assert (= source_ty_size_lt target_ty_size_lt))

; ty_size_pos: translation preserves property (matches Coq: Lemma)
(declare-fun source_ty_size_pos () Bool)
(declare-fun target_ty_size_pos () Bool)
(assert (= source_ty_size_pos target_ty_size_pos))

; ty_size_fn_arg: translation preserves property (matches Coq: Lemma)
(declare-fun source_ty_size_fn_arg () Bool)
(declare-fun target_ty_size_fn_arg () Bool)
(assert (= source_ty_size_fn_arg target_ty_size_fn_arg))

; ty_size_fn_res: translation preserves property (matches Coq: Lemma)
(declare-fun source_ty_size_fn_res () Bool)
(declare-fun target_ty_size_fn_res () Bool)
(assert (= source_ty_size_fn_res target_ty_size_fn_res))

; ty_size_prod_left: translation preserves property (matches Coq: Lemma)
(declare-fun source_ty_size_prod_left () Bool)
(declare-fun target_ty_size_prod_left () Bool)
(assert (= source_ty_size_prod_left target_ty_size_prod_left))

; ty_size_prod_right: translation preserves property (matches Coq: Lemma)
(declare-fun source_ty_size_prod_right () Bool)
(declare-fun target_ty_size_prod_right () Bool)
(assert (= source_ty_size_prod_right target_ty_size_prod_right))

; ty_size_sum_left: translation preserves property (matches Coq: Lemma)
(declare-fun source_ty_size_sum_left () Bool)
(declare-fun target_ty_size_sum_left () Bool)
(assert (= source_ty_size_sum_left target_ty_size_sum_left))

; ty_size_sum_right: translation preserves property (matches Coq: Lemma)
(declare-fun source_ty_size_sum_right () Bool)
(declare-fun target_ty_size_sum_right () Bool)
(assert (= source_ty_size_sum_right target_ty_size_sum_right))

; ty_size_ref_content: translation preserves property (matches Coq: Lemma)
(declare-fun source_ty_size_ref_content () Bool)
(declare-fun target_ty_size_ref_content () Bool)
(assert (= source_ty_size_ref_content target_ty_size_ref_content))

; ty_size_secret_content: translation preserves property (matches Coq: Lemma)
(declare-fun source_ty_size_secret_content () Bool)
(declare-fun target_ty_size_secret_content () Bool)
(assert (= source_ty_size_secret_content target_ty_size_secret_content))

; ty_size_proof_content: translation preserves property (matches Coq: Lemma)
(declare-fun source_ty_size_proof_content () Bool)
(declare-fun target_ty_size_proof_content () Bool)
(assert (= source_ty_size_proof_content target_ty_size_proof_content))

; ty_size_lt_wf: translation preserves property (matches Coq: Lemma)
(declare-fun source_ty_size_lt_wf () Bool)
(declare-fun target_ty_size_lt_wf () Bool)
(assert (= source_ty_size_lt_wf target_ty_size_lt_wf))

; ty_size_induction: translation preserves property (matches Coq: Lemma)
(declare-fun source_ty_size_induction () Bool)
(declare-fun target_ty_size_induction () Bool)
(assert (= source_ty_size_induction target_ty_size_induction))

; first_order_no_fn: translation preserves property (matches Coq: Lemma)
(declare-fun source_first_order_no_fn () Bool)
(declare-fun target_first_order_no_fn () Bool)
(assert (= source_first_order_no_fn target_first_order_no_fn))

; first_order_decidable: translation preserves property (matches Coq: Lemma)
(declare-fun source_first_order_decidable () Bool)
(declare-fun target_first_order_decidable () Bool)
(assert (= source_first_order_decidable target_first_order_decidable))

; first_order_prod_inv: translation preserves property (matches Coq: Lemma)
(declare-fun source_first_order_prod_inv () Bool)
(declare-fun target_first_order_prod_inv () Bool)
(assert (= source_first_order_prod_inv target_first_order_prod_inv))

; first_order_sum_inv: translation preserves property (matches Coq: Lemma)
(declare-fun source_first_order_sum_inv () Bool)
(declare-fun target_first_order_sum_inv () Bool)
(assert (= source_first_order_sum_inv target_first_order_sum_inv))

; first_order_ref_inv: translation preserves property (matches Coq: Lemma)
(declare-fun source_first_order_ref_inv () Bool)
(declare-fun target_first_order_ref_inv () Bool)
(assert (= source_first_order_ref_inv target_first_order_ref_inv))

; first_order_secret_inv: translation preserves property (matches Coq: Lemma)
(declare-fun source_first_order_secret_inv () Bool)
(declare-fun target_first_order_secret_inv () Bool)
(assert (= source_first_order_secret_inv target_first_order_secret_inv))

; first_order_proof_inv: translation preserves property (matches Coq: Lemma)
(declare-fun source_first_order_proof_inv () Bool)
(declare-fun target_first_order_proof_inv () Bool)
(assert (= source_first_order_proof_inv target_first_order_proof_inv))

; fo_compound_depth_prod: translation preserves property (matches Coq: Lemma)
(declare-fun source_fo_compound_depth_prod () Bool)
(declare-fun target_fo_compound_depth_prod () Bool)
(assert (= source_fo_compound_depth_prod target_fo_compound_depth_prod))

; fo_compound_depth_sum: translation preserves property (matches Coq: Lemma)
(declare-fun source_fo_compound_depth_sum () Bool)
(declare-fun target_fo_compound_depth_sum () Bool)
(assert (= source_fo_compound_depth_sum target_fo_compound_depth_sum))

; fo_compound_depth_prod_left: translation preserves property (matches Coq: Lemma)
(declare-fun source_fo_compound_depth_prod_left () Bool)
(declare-fun target_fo_compound_depth_prod_left () Bool)
(assert (= source_fo_compound_depth_prod_left target_fo_compound_depth_prod_left))

; fo_compound_depth_prod_right: translation preserves property (matches Coq: Lemma)
(declare-fun source_fo_compound_depth_prod_right () Bool)
(declare-fun target_fo_compound_depth_prod_right () Bool)
(assert (= source_fo_compound_depth_prod_right target_fo_compound_depth_prod_right))

; fo_compound_depth_sum_left: translation preserves property (matches Coq: Lemma)
(declare-fun source_fo_compound_depth_sum_left () Bool)
(declare-fun target_fo_compound_depth_sum_left () Bool)
(assert (= source_fo_compound_depth_sum_left target_fo_compound_depth_sum_left))

; fo_compound_depth_sum_right: translation preserves property (matches Coq: Lemma)
(declare-fun source_fo_compound_depth_sum_right () Bool)
(declare-fun target_fo_compound_depth_sum_right () Bool)
(assert (= source_fo_compound_depth_sum_right target_fo_compound_depth_sum_right))

; fo_compound_depth_primitive: translation preserves property (matches Coq: Lemma)
(declare-fun source_fo_compound_depth_primitive () Bool)
(declare-fun target_fo_compound_depth_primitive () Bool)
(assert (= source_fo_compound_depth_primitive target_fo_compound_depth_primitive))

; ty_depth_fn_arg: translation preserves property (matches Coq: Lemma)
(declare-fun source_ty_depth_fn_arg () Bool)
(declare-fun target_ty_depth_fn_arg () Bool)
(assert (= source_ty_depth_fn_arg target_ty_depth_fn_arg))

; ty_depth_fn_res: translation preserves property (matches Coq: Lemma)
(declare-fun source_ty_depth_fn_res () Bool)
(declare-fun target_ty_depth_fn_res () Bool)
(assert (= source_ty_depth_fn_res target_ty_depth_fn_res))

; first_order_base_depth: translation preserves property (matches Coq: Lemma)
(declare-fun source_first_order_base_depth () Bool)
(declare-fun target_first_order_base_depth () Bool)
(assert (= source_first_order_base_depth target_first_order_base_depth))

; Verify all translation validations are satisfiable
(check-sat)
(exit)
