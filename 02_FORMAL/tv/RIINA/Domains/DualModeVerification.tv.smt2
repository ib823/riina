; Copyright (c) 2026 The RIINA Authors. All rights reserved.
; Auto-generated from 02_FORMAL/coq/domains/DualModeVerification.v (22 validations)
; Generated by scripts/generate-full-stack.py
;
; Translation Validation for DualModeVerification
; Layer 9: Verifies compiler backend preserves formal semantics.
; Each assertion checks source IR â‰¡ target code for a proven property.

(set-logic QF_LIA)
(set-option :produce-models true)

; IR node representation
(declare-sort IRNode 0)
(declare-sort TargetNode 0)

; lightweight_check: source semantics (matches Coq)
(declare-fun source_lightweight_check () Bool)
(declare-fun target_lightweight_check () Bool)
(assert (= source_lightweight_check target_lightweight_check))

; full_check: source semantics (matches Coq)
(declare-fun source_full_check () Bool)
(declare-fun target_full_check () Bool)
(assert (= source_full_check target_full_check))

; decidable_refinement: source semantics (matches Coq)
(declare-fun source_decidable_refinement () Bool)
(declare-fun target_decidable_refinement () Bool)
(assert (= source_decidable_refinement target_decidable_refinement))

; refine_subtype: source semantics (matches Coq)
(declare-fun source_refine_subtype () Bool)
(declare-fun target_refine_subtype () Bool)
(assert (= source_refine_subtype target_refine_subtype))

; refine_conj: source semantics (matches Coq)
(declare-fun source_refine_conj () Bool)
(declare-fun target_refine_conj () Bool)
(assert (= source_refine_conj target_refine_conj))

; lightweight_sound: translation preserves property (matches Coq: Theorem)
(declare-fun source_lightweight_sound () Bool)
(declare-fun target_lightweight_sound () Bool)
(assert (= source_lightweight_sound target_lightweight_sound))

; lightweight_complete_decidable: translation preserves property (matches Coq: Theorem)
(declare-fun source_lightweight_complete_decidable () Bool)
(declare-fun target_lightweight_complete_decidable () Bool)
(assert (= source_lightweight_complete_decidable target_lightweight_complete_decidable))

; refine_subtype_refl: translation preserves property (matches Coq: Theorem)
(declare-fun source_refine_subtype_refl () Bool)
(declare-fun target_refine_subtype_refl () Bool)
(assert (= source_refine_subtype_refl target_refine_subtype_refl))

; refine_subtype_trans: translation preserves property (matches Coq: Theorem)
(declare-fun source_refine_subtype_trans () Bool)
(declare-fun target_refine_subtype_trans () Bool)
(assert (= source_refine_subtype_trans target_refine_subtype_trans))

; checked_values_satisfy: translation preserves property (matches Coq: Theorem)
(declare-fun source_checked_values_satisfy () Bool)
(declare-fun target_checked_values_satisfy () Bool)
(assert (= source_checked_values_satisfy target_checked_values_satisfy))

; dual_mode_agreement: translation preserves property (matches Coq: Theorem)
(declare-fun source_dual_mode_agreement () Bool)
(declare-fun target_dual_mode_agreement () Bool)
(assert (= source_dual_mode_agreement target_dual_mode_agreement))

; refinement_weakening: translation preserves property (matches Coq: Theorem)
(declare-fun source_refinement_weakening () Bool)
(declare-fun target_refinement_weakening () Bool)
(assert (= source_refinement_weakening target_refinement_weakening))

; conj_subtype_left: translation preserves property (matches Coq: Theorem)
(declare-fun source_conj_subtype_left () Bool)
(declare-fun target_conj_subtype_left () Bool)
(assert (= source_conj_subtype_left target_conj_subtype_left))

; conj_subtype_right: translation preserves property (matches Coq: Theorem)
(declare-fun source_conj_subtype_right () Bool)
(declare-fun target_conj_subtype_right () Bool)
(assert (= source_conj_subtype_right target_conj_subtype_right))

; conj_greatest_lower_bound: translation preserves property (matches Coq: Theorem)
(declare-fun source_conj_greatest_lower_bound () Bool)
(declare-fun target_conj_greatest_lower_bound () Bool)
(assert (= source_conj_greatest_lower_bound target_conj_greatest_lower_bound))

; conj_full_pred_comm: translation preserves property (matches Coq: Theorem)
(declare-fun source_conj_full_pred_comm () Bool)
(declare-fun target_conj_full_pred_comm () Bool)
(assert (= source_conj_full_pred_comm target_conj_full_pred_comm))

; conj_full_pred_assoc: translation preserves property (matches Coq: Theorem)
(declare-fun source_conj_full_pred_assoc () Bool)
(declare-fun target_conj_full_pred_assoc () Bool)
(assert (= source_conj_full_pred_assoc target_conj_full_pred_assoc))

; conj_light_is_andb: translation preserves property (matches Coq: Theorem)
(declare-fun source_conj_light_is_andb () Bool)
(declare-fun target_conj_light_is_andb () Bool)
(assert (= source_conj_light_is_andb target_conj_light_is_andb))

; eval_const: translation preserves property (matches Coq: Theorem)
(declare-fun source_eval_const () Bool)
(declare-fun target_eval_const () Bool)
(assert (= source_eval_const target_eval_const))

; eval_plus: translation preserves property (matches Coq: Theorem)
(declare-fun source_eval_plus () Bool)
(declare-fun target_eval_plus () Bool)
(assert (= source_eval_plus target_eval_plus))

; lightweight_false_implies_not_full: translation preserves property (matches Coq: Theorem)
(declare-fun source_lightweight_false_implies_not_full () Bool)
(declare-fun target_lightweight_false_implies_not_full () Bool)
(assert (= source_lightweight_false_implies_not_full target_lightweight_false_implies_not_full))

; subtype_lightweight_sound: translation preserves property (matches Coq: Theorem)
(declare-fun source_subtype_lightweight_sound () Bool)
(declare-fun target_subtype_lightweight_sound () Bool)
(assert (= source_subtype_lightweight_sound target_subtype_lightweight_sound))

; conj_decidable: translation preserves property (matches Coq: Theorem)
(declare-fun source_conj_decidable () Bool)
(declare-fun target_conj_decidable () Bool)
(assert (= source_conj_decidable target_conj_decidable))

; refine_subtype_antisym_eq: translation preserves property (matches Coq: Theorem)
(declare-fun source_refine_subtype_antisym_eq () Bool)
(declare-fun target_refine_subtype_antisym_eq () Bool)
(assert (= source_refine_subtype_antisym_eq target_refine_subtype_antisym_eq))

; eval_if_false: translation preserves property (matches Coq: Theorem)
(declare-fun source_eval_if_false () Bool)
(declare-fun target_eval_if_false () Bool)
(assert (= source_eval_if_false target_eval_if_false))

; eval_if_true: translation preserves property (matches Coq: Theorem)
(declare-fun source_eval_if_true () Bool)
(declare-fun target_eval_if_true () Bool)
(assert (= source_eval_if_true target_eval_if_true))

; conj_sub_both: translation preserves property (matches Coq: Theorem)
(declare-fun source_conj_sub_both () Bool)
(declare-fun target_conj_sub_both () Bool)
(assert (= source_conj_sub_both target_conj_sub_both))

; Verify all translation validations are satisfiable
(check-sat)
(exit)
