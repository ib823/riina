; Copyright (c) 2026 The RIINA Authors. All rights reserved.
; Auto-generated from 02_FORMAL/coq/domains/OwnershipTypes.v (20 validations)
; Generated by scripts/generate-full-stack.py
;
; Translation Validation for OwnershipTypes
; Layer 9: Verifies compiler backend preserves formal semantics.
; Each assertion checks source IR â‰¡ target code for a proven property.

(set-logic QF_LIA)
(set-option :produce-models true)

; IR node representation
(declare-sort IRNode 0)
(declare-sort TargetNode 0)

; lifetime_outlives: source semantics (matches Coq)
(declare-fun source_lifetime_outlives () Bool)
(declare-fun target_lifetime_outlives () Bool)
(assert (= source_lifetime_outlives target_lifetime_outlives))

; is_usable: source semantics (matches Coq)
(declare-fun source_is_usable () Bool)
(declare-fun target_is_usable () Bool)
(assert (= source_is_usable target_is_usable))

; can_mut_borrow: source semantics (matches Coq)
(declare-fun source_can_mut_borrow () Bool)
(declare-fun target_can_mut_borrow () Bool)
(assert (= source_can_mut_borrow target_can_mut_borrow))

; can_shared_borrow: source semantics (matches Coq)
(declare-fun source_can_shared_borrow () Bool)
(declare-fun target_can_shared_borrow () Bool)
(assert (= source_can_shared_borrow target_can_shared_borrow))

; count_borrows: source semantics (matches Coq)
(declare-fun source_count_borrows () Bool)
(declare-fun target_count_borrows () Bool)
(assert (= source_count_borrows target_count_borrows))

; count_mut_borrows: source semantics (matches Coq)
(declare-fun source_count_mut_borrows () Bool)
(declare-fun target_count_mut_borrows () Bool)
(assert (= source_count_mut_borrows target_count_mut_borrows))

; borrow_lifetime_valid: source semantics (matches Coq)
(declare-fun source_borrow_lifetime_valid () Bool)
(declare-fun target_borrow_lifetime_valid () Bool)
(assert (= source_borrow_lifetime_valid target_borrow_lifetime_valid))

; is_moved: source semantics (matches Coq)
(declare-fun source_is_moved () Bool)
(declare-fun target_is_moved () Bool)
(assert (= source_is_moved target_is_moved))

; is_dropped: source semantics (matches Coq)
(declare-fun source_is_dropped () Bool)
(declare-fun target_is_dropped () Bool)
(assert (= source_is_dropped target_is_dropped))

; box_new: source semantics (matches Coq)
(declare-fun source_box_new () Bool)
(declare-fun target_box_new () Bool)
(assert (= source_box_new target_box_new))

; well_formed_ctx: source semantics (matches Coq)
(declare-fun source_well_formed_ctx () Bool)
(declare-fun target_well_formed_ctx () Bool)
(assert (= source_well_formed_ctx target_well_formed_ctx))

; no_active_borrows: source semantics (matches Coq)
(declare-fun source_no_active_borrows () Bool)
(declare-fun target_no_active_borrows () Bool)
(assert (= source_no_active_borrows target_no_active_borrows))

; memory_safe: source semantics (matches Coq)
(declare-fun source_memory_safe () Bool)
(declare-fun target_memory_safe () Bool)
(assert (= source_memory_safe target_memory_safe))

; existsb_false_forall: translation preserves property (matches Coq: Lemma)
(declare-fun source_existsb_false_forall () Bool)
(declare-fun target_existsb_false_forall () Bool)
(assert (= source_existsb_false_forall target_existsb_false_forall))

; find_var_map_moved: translation preserves property (matches Coq: Lemma)
(declare-fun source_find_var_map_moved () Bool)
(declare-fun target_find_var_map_moved () Bool)
(assert (= source_find_var_map_moved target_find_var_map_moved))

; MEM_001_01: translation preserves property (matches Coq: Theorem)
(declare-fun source_MEM_001_01 () Bool)
(declare-fun target_MEM_001_01 () Bool)
(assert (= source_MEM_001_01 target_MEM_001_01))

; MEM_001_02: translation preserves property (matches Coq: Theorem)
(declare-fun source_MEM_001_02 () Bool)
(declare-fun target_MEM_001_02 () Bool)
(assert (= source_MEM_001_02 target_MEM_001_02))

; MEM_001_03: translation preserves property (matches Coq: Theorem)
(declare-fun source_MEM_001_03 () Bool)
(declare-fun target_MEM_001_03 () Bool)
(assert (= source_MEM_001_03 target_MEM_001_03))

; filter_all_false_empty: translation preserves property (matches Coq: Lemma)
(declare-fun source_filter_all_false_empty () Bool)
(declare-fun target_filter_all_false_empty () Bool)
(assert (= source_filter_all_false_empty target_filter_all_false_empty))

; MEM_001_04: translation preserves property (matches Coq: Theorem)
(declare-fun source_MEM_001_04 () Bool)
(declare-fun target_MEM_001_04 () Bool)
(assert (= source_MEM_001_04 target_MEM_001_04))

; MEM_001_05: translation preserves property (matches Coq: Theorem)
(declare-fun source_MEM_001_05 () Bool)
(declare-fun target_MEM_001_05 () Bool)
(assert (= source_MEM_001_05 target_MEM_001_05))

; MEM_001_06: translation preserves property (matches Coq: Theorem)
(declare-fun source_MEM_001_06 () Bool)
(declare-fun target_MEM_001_06 () Bool)
(assert (= source_MEM_001_06 target_MEM_001_06))

; MEM_001_07: translation preserves property (matches Coq: Theorem)
(declare-fun source_MEM_001_07 () Bool)
(declare-fun target_MEM_001_07 () Bool)
(assert (= source_MEM_001_07 target_MEM_001_07))

; MEM_001_08: translation preserves property (matches Coq: Theorem)
(declare-fun source_MEM_001_08 () Bool)
(declare-fun target_MEM_001_08 () Bool)
(assert (= source_MEM_001_08 target_MEM_001_08))

; MEM_001_09: translation preserves property (matches Coq: Theorem)
(declare-fun source_MEM_001_09 () Bool)
(declare-fun target_MEM_001_09 () Bool)
(assert (= source_MEM_001_09 target_MEM_001_09))

; find_var_map_dropped: translation preserves property (matches Coq: Lemma)
(declare-fun source_find_var_map_dropped () Bool)
(declare-fun target_find_var_map_dropped () Bool)
(assert (= source_find_var_map_dropped target_find_var_map_dropped))

; MEM_001_10: translation preserves property (matches Coq: Theorem)
(declare-fun source_MEM_001_10 () Bool)
(declare-fun target_MEM_001_10 () Bool)
(assert (= source_MEM_001_10 target_MEM_001_10))

; MEM_001_11: translation preserves property (matches Coq: Theorem)
(declare-fun source_MEM_001_11 () Bool)
(declare-fun target_MEM_001_11 () Bool)
(assert (= source_MEM_001_11 target_MEM_001_11))

; MEM_001_12: translation preserves property (matches Coq: Theorem)
(declare-fun source_MEM_001_12 () Bool)
(declare-fun target_MEM_001_12 () Bool)
(assert (= source_MEM_001_12 target_MEM_001_12))

; MEM_001_13: translation preserves property (matches Coq: Theorem)
(declare-fun source_MEM_001_13 () Bool)
(declare-fun target_MEM_001_13 () Bool)
(assert (= source_MEM_001_13 target_MEM_001_13))

; MEM_001_14: translation preserves property (matches Coq: Theorem)
(declare-fun source_MEM_001_14 () Bool)
(declare-fun target_MEM_001_14 () Bool)
(assert (= source_MEM_001_14 target_MEM_001_14))

; MEM_001_15: translation preserves property (matches Coq: Theorem)
(declare-fun source_MEM_001_15 () Bool)
(declare-fun target_MEM_001_15 () Bool)
(assert (= source_MEM_001_15 target_MEM_001_15))

; lifetime_outlives_refl: translation preserves property (matches Coq: Theorem)
(declare-fun source_lifetime_outlives_refl () Bool)
(declare-fun target_lifetime_outlives_refl () Bool)
(assert (= source_lifetime_outlives_refl target_lifetime_outlives_refl))

; Verify all translation validations are satisfiable
(check-sat)
(exit)
