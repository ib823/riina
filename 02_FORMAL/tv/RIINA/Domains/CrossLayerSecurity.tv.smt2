; SPDX-License-Identifier: MPL-2.0
; Copyright (c) 2026 The RIINA Authors.
; Auto-generated from 02_FORMAL/coq/domains/CrossLayerSecurity.v (21 validations)
; Generated by scripts/generate-full-stack.py
;
; Translation Validation for CrossLayerSecurity
; Layer 9: Verifies compiler backend preserves formal semantics.
; Each assertion checks source IR â‰¡ target code for a proven property.

(set-logic QF_LIA)
(set-option :produce-models true)

; IR node representation
(declare-sort IRNode 0)
(declare-sort TargetNode 0)

; label_eqb: source semantics (matches Coq)
(declare-fun source_label_eqb () Bool)
(declare-fun target_label_eqb () Bool)
(assert (= source_label_eqb target_label_eqb))

; label_leb: source semantics (matches Coq)
(declare-fun source_label_leb () Bool)
(declare-fun target_label_leb () Bool)
(assert (= source_label_leb target_label_leb))

; label_join: source semantics (matches Coq)
(declare-fun source_label_join () Bool)
(declare-fun target_label_join () Bool)
(assert (= source_label_join target_label_join))

; src_low_equiv: source semantics (matches Coq)
(declare-fun source_src_low_equiv () Bool)
(declare-fun target_src_low_equiv () Bool)
(assert (= source_src_low_equiv target_src_low_equiv))

; tgt_label_of_prog: source semantics (matches Coq)
(declare-fun source_tgt_label_of_prog () Bool)
(declare-fun target_tgt_label_of_prog () Bool)
(assert (= source_tgt_label_of_prog target_tgt_label_of_prog))

; is_constant_time: source semantics (matches Coq)
(declare-fun source_is_constant_time () Bool)
(declare-fun target_is_constant_time () Bool)
(assert (= source_is_constant_time target_is_constant_time))

; label_eqb_refl: translation preserves property (matches Coq: Lemma)
(declare-fun source_label_eqb_refl () Bool)
(declare-fun target_label_eqb_refl () Bool)
(assert (= source_label_eqb_refl target_label_eqb_refl))

; label_leb_refl: translation preserves property (matches Coq: Lemma)
(declare-fun source_label_leb_refl () Bool)
(declare-fun target_label_leb_refl () Bool)
(assert (= source_label_leb_refl target_label_leb_refl))

; label_leb_trans: translation preserves property (matches Coq: Lemma)
(declare-fun source_label_leb_trans () Bool)
(declare-fun target_label_leb_trans () Bool)
(assert (= source_label_leb_trans target_label_leb_trans))

; label_join_low_r: translation preserves property (matches Coq: Lemma)
(declare-fun source_label_join_low_r () Bool)
(declare-fun target_label_join_low_r () Bool)
(assert (= source_label_join_low_r target_label_join_low_r))

; label_join_comm: translation preserves property (matches Coq: Lemma)
(declare-fun source_label_join_comm () Bool)
(declare-fun target_label_join_comm () Bool)
(assert (= source_label_join_comm target_label_join_comm))

; 1: translation preserves property (matches Coq: Theorem)
(declare-fun source_1 () Bool)
(declare-fun target_1 () Bool)
(assert (= source_1 target_1))

; source_noninterference: translation preserves property (matches Coq: Theorem)
(declare-fun source_source_noninterference () Bool)
(declare-fun target_source_noninterference () Bool)
(assert (= source_source_noninterference target_source_noninterference))

; 2: translation preserves property (matches Coq: Theorem)
(declare-fun source_2 () Bool)
(declare-fun target_2 () Bool)
(assert (= source_2 target_2))

; 3: translation preserves property (matches Coq: Theorem)
(declare-fun source_3 () Bool)
(declare-fun target_3 () Bool)
(assert (= source_3 target_3))

; target_noninterference: translation preserves property (matches Coq: Theorem)
(declare-fun source_target_noninterference () Bool)
(declare-fun target_target_noninterference () Bool)
(assert (= source_target_noninterference target_target_noninterference))

; 4: translation preserves property (matches Coq: Theorem)
(declare-fun source_4 () Bool)
(declare-fun target_4 () Bool)
(assert (= source_4 target_4))

; 5: translation preserves property (matches Coq: Theorem)
(declare-fun source_5 () Bool)
(declare-fun target_5 () Bool)
(assert (= source_5 target_5))

; 6: translation preserves property (matches Coq: Theorem)
(declare-fun source_6 () Bool)
(declare-fun target_6 () Bool)
(assert (= source_6 target_6))

; 7: translation preserves property (matches Coq: Theorem)
(declare-fun source_7 () Bool)
(declare-fun target_7 () Bool)
(assert (= source_7 target_7))

; 8: translation preserves property (matches Coq: Theorem)
(declare-fun source_8 () Bool)
(declare-fun target_8 () Bool)
(assert (= source_8 target_8))

; 9: translation preserves property (matches Coq: Theorem)
(declare-fun source_9 () Bool)
(declare-fun target_9 () Bool)
(assert (= source_9 target_9))

; 10: translation preserves property (matches Coq: Theorem)
(declare-fun source_10 () Bool)
(declare-fun target_10 () Bool)
(assert (= source_10 target_10))

; label_lattice_join_least: translation preserves property (matches Coq: Theorem)
(declare-fun source_label_lattice_join_least () Bool)
(declare-fun target_label_lattice_join_least () Bool)
(assert (= source_label_lattice_join_least target_label_lattice_join_least))

; label_eqb_refl2: translation preserves property (matches Coq: Theorem)
(declare-fun source_label_eqb_refl2 () Bool)
(declare-fun target_label_eqb_refl2 () Bool)
(assert (= source_label_eqb_refl2 target_label_eqb_refl2))

; label_join_comm2: translation preserves property (matches Coq: Theorem)
(declare-fun source_label_join_comm2 () Bool)
(declare-fun target_label_join_comm2 () Bool)
(assert (= source_label_join_comm2 target_label_join_comm2))

; label_join_idem2: translation preserves property (matches Coq: Theorem)
(declare-fun source_label_join_idem2 () Bool)
(declare-fun target_label_join_idem2 () Bool)
(assert (= source_label_join_idem2 target_label_join_idem2))

; Verify all translation validations are satisfiable
(check-sat)
(exit)
