(* SPDX-License-Identifier: MPL-2.0 *)
(* Copyright (c) 2026 The RIINA Authors. *)
(* Auto-generated from 02_FORMAL/coq/properties/SubstitutionCommute.v (11 lemmas) *)
(* Generated by scripts/generate-full-stack.py *)
module RIINA.Domains.SubstitutionCommute
open FStar.All

(* id_rho_sc (matches Coq: Definition id_rho_sc) *)
let id_rho_sc  : Tot subst_rho_sc = true

(* extend_rho_sc (matches Coq: Definition extend_rho_sc) *)
let extend_rho_sc (ρ: subst_rho_sc) (x: ident) (v: expr) : Tot subst_rho_sc = true

(* closed_expr_sc (matches Coq: Definition closed_expr_sc) *)
let closed_expr_sc (e: expr) : Tot prop = true

(* closed_rho_sc (matches Coq: Definition closed_rho_sc) *)
let closed_rho_sc (ρ: subst_rho_sc) : Tot prop = true

(* extend_rho_sc_same (matches Coq: Lemma extend_rho_sc_same) *)
val extend_rho_sc_same_lemma : unit -> Lemma (True)
let extend_rho_sc_same_lemma () = ()

(* extend_rho_sc_diff (matches Coq: Lemma extend_rho_sc_diff) *)
val extend_rho_sc_diff_lemma : unit -> Lemma (True)
let extend_rho_sc_diff_lemma () = ()

(* extend_rho_sc_shadow (matches Coq: Lemma extend_rho_sc_shadow) *)
val extend_rho_sc_shadow_lemma : unit -> Lemma (True)
let extend_rho_sc_shadow_lemma () = ()

(* extend_rho_sc_comm (matches Coq: Lemma extend_rho_sc_comm) *)
val extend_rho_sc_comm_lemma : unit -> Lemma (True)
let extend_rho_sc_comm_lemma () = ()

(* subst_not_free_sc (matches Coq: Lemma subst_not_free_sc) *)
val subst_not_free_sc_lemma : unit -> Lemma (True)
let subst_not_free_sc_lemma () = ()

(* subst_closed_sc (matches Coq: Lemma subst_closed_sc) *)
val subst_closed_sc_lemma : unit -> Lemma (True)
let subst_closed_sc_lemma () = ()

(* closed_unit_sub (matches Coq: Lemma closed_unit_sub) *)
val closed_unit_sub_lemma : unit -> Lemma (True)
let closed_unit_sub_lemma () = ()

(* closed_bool_sub (matches Coq: Lemma closed_bool_sub) *)
val closed_bool_sub_lemma : unit -> Lemma (True)
let closed_bool_sub_lemma () = ()

(* closed_int_sub (matches Coq: Lemma closed_int_sub) *)
val closed_int_sub_lemma : unit -> Lemma (True)
let closed_int_sub_lemma () = ()

(* closed_string_sub (matches Coq: Lemma closed_string_sub) *)
val closed_string_sub_lemma : unit -> Lemma (True)
let closed_string_sub_lemma () = ()

(* closed_loc_sub (matches Coq: Lemma closed_loc_sub) *)
val closed_loc_sub_lemma : unit -> Lemma (True)
let closed_loc_sub_lemma () = ()
