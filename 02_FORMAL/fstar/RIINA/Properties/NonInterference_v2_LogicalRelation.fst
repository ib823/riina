(* SPDX-License-Identifier: MPL-2.0 *)
(* Copyright (c) 2026 The RIINA Authors. *)
(* Auto-generated from 02_FORMAL/coq/properties/NonInterference_v2_LogicalRelation.v (147 lemmas) *)
(* Generated by scripts/generate-full-stack.py *)
module RIINA.Domains.NonInterference_v2_LogicalRelation
open FStar.All

(* closed_except (matches Coq: Definition closed_except) *)
let closed_except (x: ident) (e: expr) : Tot prop = true

(* env_rel_n (matches Coq: Definition env_rel_n) *)
let env_rel_n (n: nat) (Σ: store_ty) (G: type_env) : Tot prop = true

(* env_rel (matches Coq: Definition env_rel) *)
let env_rel (Σ: store_ty) (G: type_env) : Tot prop = true

(* rho_closed_on (matches Coq: Definition rho_closed_on) *)
let rho_closed_on (G: type_env) : Tot prop = true

(* rho_no_free_all (matches Coq: Definition rho_no_free_all) *)
let rho_no_free_all  : Tot prop = true

(* env_typed (matches Coq: Definition env_typed) *)
let env_typed (Σ: store_ty) (Γ: type_env) : Tot prop = true

(* fundamental_at_step (matches Coq: Definition fundamental_at_step) *)
let fundamental_at_step (n: nat) : Tot prop = true

(* step_up_at (matches Coq: Definition step_up_at) *)
let step_up_at (n: nat) : Tot prop = true

(* step_up_and_fundamental (matches Coq: Definition step_up_and_fundamental) *)
let step_up_and_fundamental (n: nat) : Tot prop = true

(* closed_expr_lam (matches Coq: Lemma closed_expr_lam) *)
val closed_expr_lam_lemma : unit -> Lemma (True)
let closed_expr_lam_lemma () = ()

(* closed_expr_pair (matches Coq: Lemma closed_expr_pair) *)
val closed_expr_pair_lemma : unit -> Lemma (True)
let closed_expr_pair_lemma () = ()

(* closed_expr_pair_inv (matches Coq: Lemma closed_expr_pair_inv) *)
val closed_expr_pair_inv_lemma : unit -> Lemma (True)
let closed_expr_pair_inv_lemma () = ()

(* closed_expr_inl (matches Coq: Lemma closed_expr_inl) *)
val closed_expr_inl_lemma : unit -> Lemma (True)
let closed_expr_inl_lemma () = ()

(* closed_expr_inr (matches Coq: Lemma closed_expr_inr) *)
val closed_expr_inr_lemma : unit -> Lemma (True)
let closed_expr_inr_lemma () = ()

(* val_rel_closed_left_n (matches Coq: Lemma val_rel_closed_left_n) *)
val val_rel_closed_left_n_lemma : unit -> Lemma (True)
let val_rel_closed_left_n_lemma () = ()

(* val_rel_closed_right_n (matches Coq: Lemma val_rel_closed_right_n) *)
val val_rel_closed_right_n_lemma : unit -> Lemma (True)
let val_rel_closed_right_n_lemma () = ()

(* val_rel_value_left_n (matches Coq: Lemma val_rel_value_left_n) *)
val val_rel_value_left_n_lemma : unit -> Lemma (True)
let val_rel_value_left_n_lemma () = ()

(* val_rel_value_right_n (matches Coq: Lemma val_rel_value_right_n) *)
val val_rel_value_right_n_lemma : unit -> Lemma (True)
let val_rel_value_right_n_lemma () = ()

(* val_rel_closed_left (matches Coq: Lemma val_rel_closed_left) *)
val val_rel_closed_left_lemma : unit -> Lemma (True)
let val_rel_closed_left_lemma () = ()

(* val_rel_closed_right (matches Coq: Lemma val_rel_closed_right) *)
val val_rel_closed_right_lemma : unit -> Lemma (True)
let val_rel_closed_right_lemma () = ()

(* val_rel_value_left (matches Coq: Lemma val_rel_value_left) *)
val val_rel_value_left_lemma : unit -> Lemma (True)
let val_rel_value_left_lemma () = ()

(* val_rel_value_right (matches Coq: Lemma val_rel_value_right) *)
val val_rel_value_right_lemma : unit -> Lemma (True)
let val_rel_value_right_lemma () = ()

(* free_in_subst_rho (matches Coq: Lemma free_in_subst_rho) *)
val free_in_subst_rho_lemma : unit -> Lemma (True)
let free_in_subst_rho_lemma () = ()

(* env_rel_n_mono_store (matches Coq: Lemma env_rel_n_mono_store) *)
val env_rel_n_mono_store_lemma : unit -> Lemma (True)
let env_rel_n_mono_store_lemma () = ()

(* env_rel_mono_store (matches Coq: Lemma env_rel_mono_store) *)
val env_rel_mono_store_lemma : unit -> Lemma (True)
let env_rel_mono_store_lemma () = ()

(* env_typed_lookup (matches Coq: Lemma env_typed_lookup) *)
val env_typed_lookup_lemma : unit -> Lemma (True)
let env_typed_lookup_lemma () = ()

(* typing_nil_closed (matches Coq: Lemma typing_nil_closed) *)
val typing_nil_closed_lemma : unit -> Lemma (True)
let typing_nil_closed_lemma () = ()

(* env_typed_closed (matches Coq: Lemma env_typed_closed) *)
val env_typed_closed_lemma : unit -> Lemma (True)
let env_typed_closed_lemma () = ()

(* env_typed_extend (matches Coq: Lemma env_typed_extend) *)
val env_typed_extend_lemma : unit -> Lemma (True)
let env_typed_extend_lemma () = ()

(* value_subst_rho (matches Coq: Lemma value_subst_rho) *)
val value_subst_rho_lemma : unit -> Lemma (True)
let value_subst_rho_lemma () = ()

(* declass_ok_subst_rho (matches Coq: Lemma declass_ok_subst_rho) *)
val declass_ok_subst_rho_lemma : unit -> Lemma (True)
let declass_ok_subst_rho_lemma () = ()

(* subst_rho_typing_general (matches Coq: Lemma subst_rho_typing_general) *)
val subst_rho_typing_general_lemma : unit -> Lemma (True)
let subst_rho_typing_general_lemma () = ()

(* subst_rho_preserves_typing (matches Coq: Lemma subst_rho_preserves_typing) *)
val subst_rho_preserves_typing_lemma : unit -> Lemma (True)
let subst_rho_preserves_typing_lemma () = ()

(* env_rel_implies_env_typed (matches Coq: Lemma env_rel_implies_env_typed) *)
val env_rel_implies_env_typed_lemma : unit -> Lemma (True)
let env_rel_implies_env_typed_lemma () = ()

(* lam_typing_from_env_rel (matches Coq: Lemma lam_typing_from_env_rel) *)
val lam_typing_from_env_rel_lemma : unit -> Lemma (True)
let lam_typing_from_env_rel_lemma () = ()

(* val_rel_at_type_store_weaken (matches Coq: Lemma val_rel_at_type_store_weaken) *)
val val_rel_at_type_store_weaken_lemma : unit -> Lemma (True)
let val_rel_at_type_store_weaken_lemma () = ()

(* val_rel_n_store_weaken (matches Coq: Lemma val_rel_n_store_weaken) *)
val val_rel_n_store_weaken_lemma : unit -> Lemma (True)
let val_rel_n_store_weaken_lemma () = ()

(* closed_expr_unit_early (matches Coq: Lemma closed_expr_unit_early) *)
val closed_expr_unit_early_lemma : unit -> Lemma (True)
let closed_expr_unit_early_lemma () = ()

(* closed_expr_loc_early (matches Coq: Lemma closed_expr_loc_early) *)
val closed_expr_loc_early_lemma : unit -> Lemma (True)
let closed_expr_loc_early_lemma () = ()

(* val_rel_n_loc_general (matches Coq: Lemma val_rel_n_loc_general) *)
val val_rel_n_loc_general_lemma : unit -> Lemma (True)
let val_rel_n_loc_general_lemma () = ()

(* val_rel_n_unit_general (matches Coq: Lemma val_rel_n_unit_general) *)
val val_rel_n_unit_general_lemma : unit -> Lemma (True)
let val_rel_n_unit_general_lemma () = ()

(* store_max_update_single (matches Coq: Lemma store_max_update_single) *)
val store_max_update_single_lemma : unit -> Lemma (True)
let store_max_update_single_lemma () = ()

(* store_max_update_eq (matches Coq: Lemma store_max_update_eq) *)
val store_max_update_eq_lemma : unit -> Lemma (True)
let store_max_update_eq_lemma () = ()

(* store_rel_n_alloc_fresh (matches Coq: Lemma store_rel_n_alloc_fresh) *)
val store_rel_n_alloc_fresh_lemma : unit -> Lemma (True)
let store_rel_n_alloc_fresh_lemma () = ()

(* store_vals_rel_alloc_fresh (matches Coq: Lemma store_vals_rel_alloc_fresh) *)
val store_vals_rel_alloc_fresh_lemma : unit -> Lemma (True)
let store_vals_rel_alloc_fresh_lemma () = ()

(* val_rel_n_fo_extract (matches Coq: Lemma val_rel_n_fo_extract) *)
val val_rel_n_fo_extract_lemma : unit -> Lemma (True)
let val_rel_n_fo_extract_lemma () = ()

(* stores_agree_low_fo_alloc_fresh (matches Coq: Lemma stores_agree_low_fo_alloc_fresh) *)
val stores_agree_low_fo_alloc_fresh_lemma : unit -> Lemma (True)
let stores_agree_low_fo_alloc_fresh_lemma () = ()

(* store_rel_n_update_existing (matches Coq: Lemma store_rel_n_update_existing) *)
val store_rel_n_update_existing_lemma : unit -> Lemma (True)
let store_rel_n_update_existing_lemma () = ()

(* store_vals_rel_update_existing (matches Coq: Lemma store_vals_rel_update_existing) *)
val store_vals_rel_update_existing_lemma : unit -> Lemma (True)
let store_vals_rel_update_existing_lemma () = ()

(* stores_agree_low_fo_update_existing (matches Coq: Lemma stores_agree_low_fo_update_existing) *)
val stores_agree_low_fo_update_existing_lemma : unit -> Lemma (True)
let stores_agree_low_fo_update_existing_lemma () = ()

(* val_rel_n_to_val_rel (matches Coq: Lemma val_rel_n_to_val_rel) *)
val val_rel_n_to_val_rel_lemma : unit -> Lemma (True)
let val_rel_n_to_val_rel_lemma () = ()

(* val_rel_n_to_val_rel_any (matches Coq: Lemma val_rel_n_to_val_rel_any) *)
val val_rel_n_to_val_rel_any_lemma : unit -> Lemma (True)
let val_rel_n_to_val_rel_any_lemma () = ()

(* env_rel_rho_closed (matches Coq: Lemma env_rel_rho_closed) *)
val env_rel_rho_closed_lemma : unit -> Lemma (True)
let env_rel_rho_closed_lemma () = ()

(* lam_closedness_contradiction (matches Coq: Lemma lam_closedness_contradiction) *)
val lam_closedness_contradiction_lemma : unit -> Lemma (True)
let lam_closedness_contradiction_lemma () = ()

(* lam_closedness_contradiction2 (matches Coq: Lemma lam_closedness_contradiction2) *)
val lam_closedness_contradiction2_lemma : unit -> Lemma (True)
let lam_closedness_contradiction2_lemma () = ()

(* rho_no_free_all_single (matches Coq: Lemma rho_no_free_all_single) *)
val rho_no_free_all_single_lemma : unit -> Lemma (True)
let rho_no_free_all_single_lemma () = ()

(* env_rel_closed_left (matches Coq: Lemma env_rel_closed_left) *)
val env_rel_closed_left_lemma : unit -> Lemma (True)
let env_rel_closed_left_lemma () = ()

(* env_rel_closed_right (matches Coq: Lemma env_rel_closed_right) *)
val env_rel_closed_right_lemma : unit -> Lemma (True)
let env_rel_closed_right_lemma () = ()

(* closed_except_subst_rho_shadow (matches Coq: Lemma closed_except_subst_rho_shadow) *)
val closed_except_subst_rho_shadow_lemma : unit -> Lemma (True)
let closed_except_subst_rho_shadow_lemma () = ()

(* subst_not_free (matches Coq: Lemma subst_not_free) *)
val subst_not_free_lemma : unit -> Lemma (True)
let subst_not_free_lemma () = ()

(* rho_shadow_id (matches Coq: Lemma rho_shadow_id) *)
val rho_shadow_id_lemma : unit -> Lemma (True)
let rho_shadow_id_lemma () = ()

(* rho_shadow_identity (matches Coq: Lemma rho_shadow_identity) *)
val rho_shadow_identity_lemma : unit -> Lemma (True)
let rho_shadow_identity_lemma () = ()

(* subst_rho_identity (matches Coq: Lemma subst_rho_identity) *)
val subst_rho_identity_lemma : unit -> Lemma (True)
let subst_rho_identity_lemma () = ()

(* subst_rho_id (matches Coq: Lemma subst_rho_id) *)
val subst_rho_id_lemma : unit -> Lemma (True)
let subst_rho_id_lemma () = ()

(* rho_shadow_single_eq (matches Coq: Lemma rho_shadow_single_eq) *)
val rho_shadow_single_eq_lemma : unit -> Lemma (True)
let rho_shadow_single_eq_lemma () = ()

(* rho_shadow_single_id (matches Coq: Lemma rho_shadow_single_id) *)
val rho_shadow_single_id_lemma : unit -> Lemma (True)
let rho_shadow_single_id_lemma () = ()

(* subst_rho_single (matches Coq: Lemma subst_rho_single) *)
val subst_rho_single_lemma : unit -> Lemma (True)
let subst_rho_single_lemma () = ()

(* rho_shadow_extend_same (matches Coq: Lemma rho_shadow_extend_same) *)
val rho_shadow_extend_same_lemma : unit -> Lemma (True)
let rho_shadow_extend_same_lemma () = ()

(* rho_shadow_shadow_same (matches Coq: Lemma rho_shadow_shadow_same) *)
val rho_shadow_shadow_same_lemma : unit -> Lemma (True)
let rho_shadow_shadow_same_lemma () = ()

(* rho_shadow_shadow_comm (matches Coq: Lemma rho_shadow_shadow_comm) *)
val rho_shadow_shadow_comm_lemma : unit -> Lemma (True)
let rho_shadow_shadow_comm_lemma () = ()

(* rho_shadow_extend_comm (matches Coq: Lemma rho_shadow_extend_comm) *)
val rho_shadow_extend_comm_lemma : unit -> Lemma (True)
let rho_shadow_extend_comm_lemma () = ()

(* rho_no_free_extend (matches Coq: Lemma rho_no_free_extend) *)
val rho_no_free_extend_lemma : unit -> Lemma (True)
let rho_no_free_extend_lemma () = ()

(* rho_no_free_shadow (matches Coq: Lemma rho_no_free_shadow) *)
val rho_no_free_shadow_lemma : unit -> Lemma (True)
let rho_no_free_shadow_lemma () = ()

(* subst_rho_extend (matches Coq: Lemma subst_rho_extend) *)
val subst_rho_extend_lemma : unit -> Lemma (True)
let subst_rho_extend_lemma () = ()

(* env_rel_empty_n (matches Coq: Lemma env_rel_empty_n) *)
val env_rel_empty_n_lemma : unit -> Lemma (True)
let env_rel_empty_n_lemma () = ()

(* env_rel_empty (matches Coq: Lemma env_rel_empty) *)
val env_rel_empty_lemma : unit -> Lemma (True)
let env_rel_empty_lemma () = ()

(* env_rel_extend_n (matches Coq: Lemma env_rel_extend_n) *)
val env_rel_extend_n_lemma : unit -> Lemma (True)
let env_rel_extend_n_lemma () = ()

(* env_rel_extend (matches Coq: Lemma env_rel_extend) *)
val env_rel_extend_lemma : unit -> Lemma (True)
let env_rel_extend_lemma () = ()

(* multi_step_trans (matches Coq: Lemma multi_step_trans) *)
val multi_step_trans_lemma : unit -> Lemma (True)
let multi_step_trans_lemma () = ()

(* multi_step_app1 (matches Coq: Lemma multi_step_app1) *)
val multi_step_app1_lemma : unit -> Lemma (True)
let multi_step_app1_lemma () = ()

(* multi_step_app2 (matches Coq: Lemma multi_step_app2) *)
val multi_step_app2_lemma : unit -> Lemma (True)
let multi_step_app2_lemma () = ()

(* multi_step_pair1 (matches Coq: Lemma multi_step_pair1) *)
val multi_step_pair1_lemma : unit -> Lemma (True)
let multi_step_pair1_lemma () = ()

(* multi_step_pair2 (matches Coq: Lemma multi_step_pair2) *)
val multi_step_pair2_lemma : unit -> Lemma (True)
let multi_step_pair2_lemma () = ()

(* multi_step_fst (matches Coq: Lemma multi_step_fst) *)
val multi_step_fst_lemma : unit -> Lemma (True)
let multi_step_fst_lemma () = ()

(* multi_step_snd (matches Coq: Lemma multi_step_snd) *)
val multi_step_snd_lemma : unit -> Lemma (True)
let multi_step_snd_lemma () = ()

(* multi_step_inl (matches Coq: Lemma multi_step_inl) *)
val multi_step_inl_lemma : unit -> Lemma (True)
let multi_step_inl_lemma () = ()

(* multi_step_inr (matches Coq: Lemma multi_step_inr) *)
val multi_step_inr_lemma : unit -> Lemma (True)
let multi_step_inr_lemma () = ()

(* multi_step_case (matches Coq: Lemma multi_step_case) *)
val multi_step_case_lemma : unit -> Lemma (True)
let multi_step_case_lemma () = ()

(* multi_step_if (matches Coq: Lemma multi_step_if) *)
val multi_step_if_lemma : unit -> Lemma (True)
let multi_step_if_lemma () = ()

(* multi_step_let (matches Coq: Lemma multi_step_let) *)
val multi_step_let_lemma : unit -> Lemma (True)
let multi_step_let_lemma () = ()

(* multi_step_classify (matches Coq: Lemma multi_step_classify) *)
val multi_step_classify_lemma : unit -> Lemma (True)
let multi_step_classify_lemma () = ()

(* multi_step_prove (matches Coq: Lemma multi_step_prove) *)
val multi_step_prove_lemma : unit -> Lemma (True)
let multi_step_prove_lemma () = ()

(* multi_step_require (matches Coq: Lemma multi_step_require) *)
val multi_step_require_lemma : unit -> Lemma (True)
let multi_step_require_lemma () = ()

(* multi_step_grant (matches Coq: Lemma multi_step_grant) *)
val multi_step_grant_lemma : unit -> Lemma (True)
let multi_step_grant_lemma () = ()

(* multi_step_perform (matches Coq: Lemma multi_step_perform) *)
val multi_step_perform_lemma : unit -> Lemma (True)
let multi_step_perform_lemma () = ()

(* multi_step_handle (matches Coq: Lemma multi_step_handle) *)
val multi_step_handle_lemma : unit -> Lemma (True)
let multi_step_handle_lemma () = ()

(* multi_step_ref (matches Coq: Lemma multi_step_ref) *)
val multi_step_ref_lemma : unit -> Lemma (True)
let multi_step_ref_lemma () = ()

(* multi_step_deref (matches Coq: Lemma multi_step_deref) *)
val multi_step_deref_lemma : unit -> Lemma (True)
let multi_step_deref_lemma () = ()

(* multi_step_assign1 (matches Coq: Lemma multi_step_assign1) *)
val multi_step_assign1_lemma : unit -> Lemma (True)
let multi_step_assign1_lemma () = ()

(* multi_step_assign2 (matches Coq: Lemma multi_step_assign2) *)
val multi_step_assign2_lemma : unit -> Lemma (True)
let multi_step_assign2_lemma () = ()

(* exp_rel_of_val_rel (matches Coq: Lemma exp_rel_of_val_rel) *)
val exp_rel_of_val_rel_lemma : unit -> Lemma (True)
let exp_rel_of_val_rel_lemma () = ()

(* exp_rel_of_val_rel_step (matches Coq: Lemma exp_rel_of_val_rel_step) *)
val exp_rel_of_val_rel_step_lemma : unit -> Lemma (True)
let exp_rel_of_val_rel_step_lemma () = ()

(* exp_rel_of_val_rel_n (matches Coq: Lemma exp_rel_of_val_rel_n) *)
val exp_rel_of_val_rel_n_lemma : unit -> Lemma (True)
let exp_rel_of_val_rel_n_lemma () = ()

(* value_pair_inv (matches Coq: Lemma value_pair_inv) *)
val value_pair_inv_lemma : unit -> Lemma (True)
let value_pair_inv_lemma () = ()

(* value_inl_inv (matches Coq: Lemma value_inl_inv) *)
val value_inl_inv_lemma : unit -> Lemma (True)
let value_inl_inv_lemma () = ()

(* value_inr_inv (matches Coq: Lemma value_inr_inv) *)
val value_inr_inv_lemma : unit -> Lemma (True)
let value_inr_inv_lemma () = ()

(* closed_expr_inl_inv (matches Coq: Lemma closed_expr_inl_inv) *)
val closed_expr_inl_inv_lemma : unit -> Lemma (True)
let closed_expr_inl_inv_lemma () = ()

(* closed_expr_inr_inv (matches Coq: Lemma closed_expr_inr_inv) *)
val closed_expr_inr_inv_lemma : unit -> Lemma (True)
let closed_expr_inr_inv_lemma () = ()

(* val_rel_n_prod_decompose (matches Coq: Lemma val_rel_n_prod_decompose) *)
val val_rel_n_prod_decompose_lemma : unit -> Lemma (True)
let val_rel_n_prod_decompose_lemma () = ()

(* val_rel_n_of_first_order (matches Coq: Lemma val_rel_n_of_first_order) *)
val val_rel_n_of_first_order_lemma : unit -> Lemma (True)
let val_rel_n_of_first_order_lemma () = ()

(* val_rel_n_to_val_rel_fo (matches Coq: Lemma val_rel_n_to_val_rel_fo) *)
val val_rel_n_to_val_rel_fo_lemma : unit -> Lemma (True)
let val_rel_n_to_val_rel_fo_lemma () = ()

(* val_rel_at_type_to_val_rel_fo (matches Coq: Lemma val_rel_at_type_to_val_rel_fo) *)
val val_rel_at_type_to_val_rel_fo_lemma : unit -> Lemma (True)
let val_rel_at_type_to_val_rel_fo_lemma () = ()

(* has_type_pair_inv (matches Coq: Lemma has_type_pair_inv) *)
val has_type_pair_inv_lemma : unit -> Lemma (True)
let has_type_pair_inv_lemma () = ()

(* val_rel_n_prod_fst (matches Coq: Lemma val_rel_n_prod_fst) *)
val val_rel_n_prod_fst_lemma : unit -> Lemma (True)
let val_rel_n_prod_fst_lemma () = ()

(* val_rel_n_prod_snd (matches Coq: Lemma val_rel_n_prod_snd) *)
val val_rel_n_prod_snd_lemma : unit -> Lemma (True)
let val_rel_n_prod_snd_lemma () = ()

(* val_rel_n_typing_ho (matches Coq: Lemma val_rel_n_typing_ho) *)
val val_rel_n_typing_ho_lemma : unit -> Lemma (True)
let val_rel_n_typing_ho_lemma () = ()

(* has_type_inl_inv (matches Coq: Lemma has_type_inl_inv) *)
val has_type_inl_inv_lemma : unit -> Lemma (True)
let has_type_inl_inv_lemma () = ()

(* has_type_inr_inv (matches Coq: Lemma has_type_inr_inv) *)
val has_type_inr_inv_lemma : unit -> Lemma (True)
let has_type_inr_inv_lemma () = ()

(* has_type_classify_inv (matches Coq: Lemma has_type_classify_inv) *)
val has_type_classify_inv_lemma : unit -> Lemma (True)
let has_type_classify_inv_lemma () = ()

(* has_type_prove_inv (matches Coq: Lemma has_type_prove_inv) *)
val has_type_prove_inv_lemma : unit -> Lemma (True)
let has_type_prove_inv_lemma () = ()

(* val_rel_n_prod_compose (matches Coq: Lemma val_rel_n_prod_compose) *)
val val_rel_n_prod_compose_lemma : unit -> Lemma (True)
let val_rel_n_prod_compose_lemma () = ()

(* val_rel_n_from_prod_fst (matches Coq: Lemma val_rel_n_from_prod_fst) *)
val val_rel_n_from_prod_fst_lemma : unit -> Lemma (True)
let val_rel_n_from_prod_fst_lemma () = ()

(* val_rel_n_from_prod_snd (matches Coq: Lemma val_rel_n_from_prod_snd) *)
val val_rel_n_from_prod_snd_lemma : unit -> Lemma (True)
let val_rel_n_from_prod_snd_lemma () = ()

(* val_rel_n_sum_inl (matches Coq: Lemma val_rel_n_sum_inl) *)
val val_rel_n_sum_inl_lemma : unit -> Lemma (True)
let val_rel_n_sum_inl_lemma () = ()

(* val_rel_n_sum_inr (matches Coq: Lemma val_rel_n_sum_inr) *)
val val_rel_n_sum_inr_lemma : unit -> Lemma (True)
let val_rel_n_sum_inr_lemma () = ()

(* val_rel_n_sum_decompose (matches Coq: Lemma val_rel_n_sum_decompose) *)
val val_rel_n_sum_decompose_lemma : unit -> Lemma (True)
let val_rel_n_sum_decompose_lemma () = ()

(* val_rel_n_from_sum_inl (matches Coq: Lemma val_rel_n_from_sum_inl) *)
val val_rel_n_from_sum_inl_lemma : unit -> Lemma (True)
let val_rel_n_from_sum_inl_lemma () = ()

(* val_rel_n_from_sum_inr (matches Coq: Lemma val_rel_n_from_sum_inr) *)
val val_rel_n_from_sum_inr_lemma : unit -> Lemma (True)
let val_rel_n_from_sum_inr_lemma () = ()

(* val_rel_n_prod_fst_at (matches Coq: Lemma val_rel_n_prod_fst_at) *)
val val_rel_n_prod_fst_at_lemma : unit -> Lemma (True)
let val_rel_n_prod_fst_at_lemma () = ()

(* val_rel_n_prod_snd_at (matches Coq: Lemma val_rel_n_prod_snd_at) *)
val val_rel_n_prod_snd_at_lemma : unit -> Lemma (True)
let val_rel_n_prod_snd_at_lemma () = ()

(* closed_expr_unit (matches Coq: Lemma closed_expr_unit) *)
val closed_expr_unit_lemma : unit -> Lemma (True)
let closed_expr_unit_lemma () = ()

(* closed_expr_bool (matches Coq: Lemma closed_expr_bool) *)
val closed_expr_bool_lemma : unit -> Lemma (True)
let closed_expr_bool_lemma () = ()

(* closed_expr_int (matches Coq: Lemma closed_expr_int) *)
val closed_expr_int_lemma : unit -> Lemma (True)
let closed_expr_int_lemma () = ()

(* closed_expr_string (matches Coq: Lemma closed_expr_string) *)
val closed_expr_string_lemma : unit -> Lemma (True)
let closed_expr_string_lemma () = ()

(* closed_expr_loc (matches Coq: Lemma closed_expr_loc) *)
val closed_expr_loc_lemma : unit -> Lemma (True)
let closed_expr_loc_lemma () = ()

(* val_rel_unit (matches Coq: Lemma val_rel_unit) *)
val val_rel_unit_lemma : unit -> Lemma (True)
let val_rel_unit_lemma () = ()

(* val_rel_bool (matches Coq: Lemma val_rel_bool) *)
val val_rel_bool_lemma : unit -> Lemma (True)
let val_rel_bool_lemma () = ()

(* val_rel_n_bool_eq (matches Coq: Lemma val_rel_n_bool_eq) *)
val val_rel_n_bool_eq_lemma : unit -> Lemma (True)
let val_rel_n_bool_eq_lemma () = ()

(* val_rel_int (matches Coq: Lemma val_rel_int) *)
val val_rel_int_lemma : unit -> Lemma (True)
let val_rel_int_lemma () = ()

(* val_rel_n_classify (matches Coq: Lemma val_rel_n_classify) *)
val val_rel_n_classify_lemma : unit -> Lemma (True)
let val_rel_n_classify_lemma () = ()

(* val_rel_n_prove (matches Coq: Lemma val_rel_n_prove) *)
val val_rel_n_prove_lemma : unit -> Lemma (True)
let val_rel_n_prove_lemma () = ()

(* val_rel_string (matches Coq: Lemma val_rel_string) *)
val val_rel_string_lemma : unit -> Lemma (True)
let val_rel_string_lemma () = ()

(* val_rel_loc (matches Coq: Lemma val_rel_loc) *)
val val_rel_loc_lemma : unit -> Lemma (True)
let val_rel_loc_lemma () = ()

(* fundamental_at_0 (matches Coq: Lemma fundamental_at_0) *)
val fundamental_at_0_lemma : unit -> Lemma (True)
let fundamental_at_0_lemma () = ()

(* step_up_at_0 (matches Coq: Lemma step_up_at_0) *)
val step_up_at_0_lemma : unit -> Lemma (True)
let step_up_at_0_lemma () = ()

(* multi_step_preservation_aux (matches Coq: Lemma multi_step_preservation_aux) *)
val multi_step_preservation_aux_lemma : unit -> Lemma (True)
let multi_step_preservation_aux_lemma () = ()

(* multi_step_preservation (matches Coq: Lemma multi_step_preservation) *)
val multi_step_preservation_lemma : unit -> Lemma (True)
let multi_step_preservation_lemma () = ()

(* has_type_level_irrelevant (matches Coq: Lemma has_type_level_irrelevant) *)
val has_type_level_irrelevant_lemma : unit -> Lemma (True)
let has_type_level_irrelevant_lemma () = ()

(* store_wf_fresh_not_in_ty (matches Coq: Lemma store_wf_fresh_not_in_ty) *)
val store_wf_fresh_not_in_ty_lemma : unit -> Lemma (True)
let store_wf_fresh_not_in_ty_lemma () = ()

(* store_rel_n_same_fresh (matches Coq: Lemma store_rel_n_same_fresh) *)
val store_rel_n_same_fresh_lemma : unit -> Lemma (True)
let store_rel_n_same_fresh_lemma () = ()

(* logical_relation (matches Coq: Theorem logical_relation) *)
val logical_relation_lemma : unit -> Lemma (True)
let logical_relation_lemma () = ()

(* step_up_and_fundamental_mutual (matches Coq: Theorem step_up_and_fundamental_mutual) *)
val step_up_and_fundamental_mutual_lemma : unit -> Lemma (True)
let step_up_and_fundamental_mutual_lemma () = ()

(* val_rel_closed (matches Coq: Lemma val_rel_closed) *)
val val_rel_closed_lemma : unit -> Lemma (True)
let val_rel_closed_lemma () = ()

(* env_rel_single (matches Coq: Lemma env_rel_single) *)
val env_rel_single_lemma : unit -> Lemma (True)
let env_rel_single_lemma () = ()

(* non_interference_stmt (matches Coq: Theorem non_interference_stmt) *)
val non_interference_stmt_lemma : unit -> Lemma (True)
let non_interference_stmt_lemma () = ()

(* subst_rho_declassify_dist (matches Coq: Lemma subst_rho_declassify_dist) *)
val subst_rho_declassify_dist_lemma : unit -> Lemma (True)
let subst_rho_declassify_dist_lemma () = ()
