(* SPDX-License-Identifier: MPL-2.0 *)
(* Copyright (c) 2026 The RIINA Authors. *)
(* Auto-generated from 02_FORMAL/coq/properties/MaximumAxiomElimination.v (53 lemmas) *)
(* Generated by scripts/generate-full-stack.py *)
module RIINA.Domains.MaximumAxiomElimination
open FStar.All

(* sec_label (matches Coq) *)
type sec_label =
  | L  (* Low - public *)
  | H

(* ty (matches Coq) *)
type ty =
  | TUnit
  | TBool
  | TNat
  | TRef
  | TProd
  | TSum
  | TArrow

(* expr (matches Coq) *)
type expr =
  | EVar
  | EUnit
  | EBool
  | ENat
  | ELoc
  | EPair
  | EFst
  | ESnd
  | EInl
  | EInr
  | ELam
  | EApp
  | ERef
  | EDeref
  | EAssign
  | EIf
  | ELet

(* label_leq (matches Coq: Definition label_leq) *)
let label_leq  : Tot bool = true

(* store_empty (matches Coq: Definition store_empty) *)
let store_empty  : Tot store = true

(* store_ty_empty (matches Coq: Definition store_ty_empty) *)
let store_ty_empty  : Tot store_typing = true

(* store_update (matches Coq: Definition store_update) *)
let store_update (σ: store) (l: nat) (v: expr) : Tot store = true

(* store_ty_update (matches Coq: Definition store_ty_update) *)
let store_ty_update (Σ: store_typing) (l: nat) (T: ty) (lab: sec_label) : Tot store_typing = true

(* store_ty_extends (matches Coq: Definition store_ty_extends) *)
let store_ty_extends  : Tot prop = true

(* store_rel_n (matches Coq: Definition store_rel_n) *)
let store_rel_n (n: nat) (Σ: store_typing) : Tot prop = true

(* exp_rel_n (matches Coq: Definition exp_rel_n) *)
let exp_rel_n (n: nat) (Σ: store_typing) (T: ty) : Tot prop = true

(* label_join (matches Coq: Definition label_join) *)
let label_join  : Tot sec_label = true

(* label_leq_refl (matches Coq: Lemma label_leq_refl) *)
val label_leq_refl_lemma : unit -> Lemma (True)
let label_leq_refl_lemma () = ()

(* label_leq_trans (matches Coq: Lemma label_leq_trans) *)
val label_leq_trans_lemma : unit -> Lemma (True)
let label_leq_trans_lemma () = ()

(* label_leq_antisym (matches Coq: Lemma label_leq_antisym) *)
val label_leq_antisym_lemma : unit -> Lemma (True)
let label_leq_antisym_lemma () = ()

(* ty_size_pos (matches Coq: Lemma ty_size_pos) *)
val ty_size_pos_lemma : unit -> Lemma (True)
let ty_size_pos_lemma () = ()

(* ty_size_prod_left (matches Coq: Lemma ty_size_prod_left) *)
val ty_size_prod_left_lemma : unit -> Lemma (True)
let ty_size_prod_left_lemma () = ()

(* ty_size_prod_right (matches Coq: Lemma ty_size_prod_right) *)
val ty_size_prod_right_lemma : unit -> Lemma (True)
let ty_size_prod_right_lemma () = ()

(* ty_size_sum_left (matches Coq: Lemma ty_size_sum_left) *)
val ty_size_sum_left_lemma : unit -> Lemma (True)
let ty_size_sum_left_lemma () = ()

(* ty_size_sum_right (matches Coq: Lemma ty_size_sum_right) *)
val ty_size_sum_right_lemma : unit -> Lemma (True)
let ty_size_sum_right_lemma () = ()

(* store_update_lookup_eq (matches Coq: Lemma store_update_lookup_eq) *)
val store_update_lookup_eq_lemma : unit -> Lemma (True)
let store_update_lookup_eq_lemma () = ()

(* store_update_lookup_neq (matches Coq: Lemma store_update_lookup_neq) *)
val store_update_lookup_neq_lemma : unit -> Lemma (True)
let store_update_lookup_neq_lemma () = ()

(* store_ty_update_lookup_eq (matches Coq: Lemma store_ty_update_lookup_eq) *)
val store_ty_update_lookup_eq_lemma : unit -> Lemma (True)
let store_ty_update_lookup_eq_lemma () = ()

(* store_ty_update_lookup_neq (matches Coq: Lemma store_ty_update_lookup_neq) *)
val store_ty_update_lookup_neq_lemma : unit -> Lemma (True)
let store_ty_update_lookup_neq_lemma () = ()

(* store_ty_extends_refl (matches Coq: Lemma store_ty_extends_refl) *)
val store_ty_extends_refl_lemma : unit -> Lemma (True)
let store_ty_extends_refl_lemma () = ()

(* store_ty_extends_trans (matches Coq: Lemma store_ty_extends_trans) *)
val store_ty_extends_trans_lemma : unit -> Lemma (True)
let store_ty_extends_trans_lemma () = ()

(* val_rel_n_zero (matches Coq: Lemma val_rel_n_zero) *)
val val_rel_n_zero_lemma : unit -> Lemma (True)
let val_rel_n_zero_lemma () = ()

(* val_rel_n_unit (matches Coq: Lemma val_rel_n_unit) *)
val val_rel_n_unit_lemma : unit -> Lemma (True)
let val_rel_n_unit_lemma () = ()

(* val_rel_n_bool (matches Coq: Lemma val_rel_n_bool) *)
val val_rel_n_bool_lemma : unit -> Lemma (True)
let val_rel_n_bool_lemma () = ()

(* val_rel_n_nat (matches Coq: Lemma val_rel_n_nat) *)
val val_rel_n_nat_lemma : unit -> Lemma (True)
let val_rel_n_nat_lemma () = ()

(* val_rel_n_ref (matches Coq: Lemma val_rel_n_ref) *)
val val_rel_n_ref_lemma : unit -> Lemma (True)
let val_rel_n_ref_lemma () = ()

(* val_rel_n_ref_same_loc (matches Coq: Lemma val_rel_n_ref_same_loc) *)
val val_rel_n_ref_same_loc_lemma : unit -> Lemma (True)
let val_rel_n_ref_same_loc_lemma () = ()

(* val_rel_n_cumulative (matches Coq: Lemma val_rel_n_cumulative) *)
val val_rel_n_cumulative_lemma : unit -> Lemma (True)
let val_rel_n_cumulative_lemma () = ()

(* val_rel_n_step_down (matches Coq: Lemma val_rel_n_step_down) *)
val val_rel_n_step_down_lemma : unit -> Lemma (True)
let val_rel_n_step_down_lemma () = ()

(* val_rel_n_value_left (matches Coq: Lemma val_rel_n_value_left) *)
val val_rel_n_value_left_lemma : unit -> Lemma (True)
let val_rel_n_value_left_lemma () = ()

(* val_rel_n_value_right (matches Coq: Lemma val_rel_n_value_right) *)
val val_rel_n_value_right_lemma : unit -> Lemma (True)
let val_rel_n_value_right_lemma () = ()

(* val_rel_n_prod (matches Coq: Lemma val_rel_n_prod) *)
val val_rel_n_prod_lemma : unit -> Lemma (True)
let val_rel_n_prod_lemma () = ()

(* val_rel_n_inl (matches Coq: Lemma val_rel_n_inl) *)
val val_rel_n_inl_lemma : unit -> Lemma (True)
let val_rel_n_inl_lemma () = ()

(* val_rel_n_inr (matches Coq: Lemma val_rel_n_inr) *)
val val_rel_n_inr_lemma : unit -> Lemma (True)
let val_rel_n_inr_lemma () = ()

(* val_rel_n_lam (matches Coq: Lemma val_rel_n_lam) *)
val val_rel_n_lam_lemma : unit -> Lemma (True)
let val_rel_n_lam_lemma () = ()

(* val_rel_n_fo_step_independent (matches Coq: Lemma val_rel_n_fo_step_independent) *)
val val_rel_n_fo_step_independent_lemma : unit -> Lemma (True)
let val_rel_n_fo_step_independent_lemma () = ()

(* store_rel_n_zero (matches Coq: Lemma store_rel_n_zero) *)
val store_rel_n_zero_lemma : unit -> Lemma (True)
let store_rel_n_zero_lemma () = ()

(* store_rel_n_step_down (matches Coq: Lemma store_rel_n_step_down) *)
val store_rel_n_step_down_lemma : unit -> Lemma (True)
let store_rel_n_step_down_lemma () = ()

(* store_rel_n_empty (matches Coq: Lemma store_rel_n_empty) *)
val store_rel_n_empty_lemma : unit -> Lemma (True)
let store_rel_n_empty_lemma () = ()

(* store_update_preserves_rel (matches Coq: Lemma store_update_preserves_rel) *)
val store_update_preserves_rel_lemma : unit -> Lemma (True)
let store_update_preserves_rel_lemma () = ()

(* store_ty_extends_antisym (matches Coq: Lemma store_ty_extends_antisym) *)
val store_ty_extends_antisym_lemma : unit -> Lemma (True)
let store_ty_extends_antisym_lemma () = ()

(* store_ty_update_extends (matches Coq: Lemma store_ty_update_extends) *)
val store_ty_update_extends_lemma : unit -> Lemma (True)
let store_ty_update_extends_lemma () = ()

(* store_lookup_deterministic (matches Coq: Lemma store_lookup_deterministic) *)
val store_lookup_deterministic_lemma : unit -> Lemma (True)
let store_lookup_deterministic_lemma () = ()

(* store_ty_lookup_deterministic (matches Coq: Lemma store_ty_lookup_deterministic) *)
val store_ty_lookup_deterministic_lemma : unit -> Lemma (True)
let store_ty_lookup_deterministic_lemma () = ()

(* store_update_idem (matches Coq: Lemma store_update_idem) *)
val store_update_idem_lemma : unit -> Lemma (True)
let store_update_idem_lemma () = ()

(* store_update_comm (matches Coq: Lemma store_update_comm) *)
val store_update_comm_lemma : unit -> Lemma (True)
let store_update_comm_lemma () = ()

(* exp_rel_n_zero (matches Coq: Lemma exp_rel_n_zero) *)
val exp_rel_n_zero_lemma : unit -> Lemma (True)
let exp_rel_n_zero_lemma () = ()

(* exp_rel_n_unit_expr (matches Coq: Lemma exp_rel_n_unit_expr) *)
val exp_rel_n_unit_expr_lemma : unit -> Lemma (True)
let exp_rel_n_unit_expr_lemma () = ()

(* exp_rel_n_step_down (matches Coq: Lemma exp_rel_n_step_down) *)
val exp_rel_n_step_down_lemma : unit -> Lemma (True)
let exp_rel_n_step_down_lemma () = ()

(* val_rel_implies_exp_rel (matches Coq: Lemma val_rel_implies_exp_rel) *)
val val_rel_implies_exp_rel_lemma : unit -> Lemma (True)
let val_rel_implies_exp_rel_lemma () = ()

(* exp_rel_n_bool_expr (matches Coq: Lemma exp_rel_n_bool_expr) *)
val exp_rel_n_bool_expr_lemma : unit -> Lemma (True)
let exp_rel_n_bool_expr_lemma () = ()

(* label_join_comm (matches Coq: Lemma label_join_comm) *)
val label_join_comm_lemma : unit -> Lemma (True)
let label_join_comm_lemma () = ()

(* label_join_assoc (matches Coq: Lemma label_join_assoc) *)
val label_join_assoc_lemma : unit -> Lemma (True)
let label_join_assoc_lemma () = ()

(* label_join_idem (matches Coq: Lemma label_join_idem) *)
val label_join_idem_lemma : unit -> Lemma (True)
let label_join_idem_lemma () = ()

(* ty_eq_dec (matches Coq: Lemma ty_eq_dec) *)
val ty_eq_dec_lemma : unit -> Lemma (True)
let ty_eq_dec_lemma () = ()

(* first_order_prod_components (matches Coq: Lemma first_order_prod_components) *)
val first_order_prod_components_lemma : unit -> Lemma (True)
let first_order_prod_components_lemma () = ()

(* first_order_sum_components (matches Coq: Lemma first_order_sum_components) *)
val first_order_sum_components_lemma : unit -> Lemma (True)
let first_order_sum_components_lemma () = ()

(* fo_depth_prod (matches Coq: Lemma fo_depth_prod) *)
val fo_depth_prod_lemma : unit -> Lemma (True)
let fo_depth_prod_lemma () = ()

(* fo_depth_sum (matches Coq: Lemma fo_depth_sum) *)
val fo_depth_sum_lemma : unit -> Lemma (True)
let fo_depth_sum_lemma () = ()

(* fo_depth_primitive (matches Coq: Lemma fo_depth_primitive) *)
val fo_depth_primitive_lemma : unit -> Lemma (True)
let fo_depth_primitive_lemma () = ()
