(* SPDX-License-Identifier: MPL-2.0 *)
(* Copyright (c) 2026 The RIINA Authors. *)
(* Auto-generated from 02_FORMAL/coq/termination/SizedTypes.v (16 lemmas) *)
(* Generated by scripts/generate-full-stack.py *)
module RIINA.Domains.SizedTypes
open FStar.All

(* sized_ty (matches Coq) *)
type sized_ty =
  | STBase  (* Base type with implicit size *)
  | STSized  (* Type with explicit size bound *)

(* sized_ty_base (matches Coq: Definition sized_ty_base) *)
let sized_ty_base (st: sized_ty) : Tot ty = true

(* sized_ty_bound (matches Coq: Definition sized_ty_bound) *)
let sized_ty_bound (st: sized_ty) : Tot nat = true

(* terminates (matches Coq: Definition terminates) *)
let terminates (e: expr) (st: store) (ctx: effect_ctx) : Tot prop = true

(* step_terminates (matches Coq: Definition step_terminates) *)
let step_terminates (e: expr) (st: store) (ctx: effect_ctx) : Tot prop = true

(* expr_size_pos (matches Coq: Lemma expr_size_pos) *)
val expr_size_pos_lemma : unit -> Lemma (True)
let expr_size_pos_lemma () = ()

(* value_prod_decompose (matches Coq: Lemma value_prod_decompose) *)
val value_prod_decompose_lemma : unit -> Lemma (True)
let value_prod_decompose_lemma () = ()

(* value_sum_decompose (matches Coq: Lemma value_sum_decompose) *)
val value_sum_decompose_lemma : unit -> Lemma (True)
let value_sum_decompose_lemma () = ()

(* value_bool_decompose (matches Coq: Lemma value_bool_decompose) *)
val value_bool_decompose_lemma : unit -> Lemma (True)
let value_bool_decompose_lemma () = ()

(* value_fn_decompose (matches Coq: Lemma value_fn_decompose) *)
val value_fn_decompose_lemma : unit -> Lemma (True)
let value_fn_decompose_lemma () = ()

(* fst_steps_once (matches Coq: Lemma fst_steps_once) *)
val fst_steps_once_lemma : unit -> Lemma (True)
let fst_steps_once_lemma () = ()

(* snd_steps_once (matches Coq: Lemma snd_steps_once) *)
val snd_steps_once_lemma : unit -> Lemma (True)
let snd_steps_once_lemma () = ()

(* case_inl_steps_once (matches Coq: Lemma case_inl_steps_once) *)
val case_inl_steps_once_lemma : unit -> Lemma (True)
let case_inl_steps_once_lemma () = ()

(* case_inr_steps_once (matches Coq: Lemma case_inr_steps_once) *)
val case_inr_steps_once_lemma : unit -> Lemma (True)
let case_inr_steps_once_lemma () = ()

(* if_true_steps_once (matches Coq: Lemma if_true_steps_once) *)
val if_true_steps_once_lemma : unit -> Lemma (True)
let if_true_steps_once_lemma () = ()

(* if_false_steps_once (matches Coq: Lemma if_false_steps_once) *)
val if_false_steps_once_lemma : unit -> Lemma (True)
let if_false_steps_once_lemma () = ()

(* let_value_steps_once (matches Coq: Lemma let_value_steps_once) *)
val let_value_steps_once_lemma : unit -> Lemma (True)
let let_value_steps_once_lemma () = ()

(* handle_value_steps_once (matches Coq: Lemma handle_value_steps_once) *)
val handle_value_steps_once_lemma : unit -> Lemma (True)
let handle_value_steps_once_lemma () = ()

(* app_lam_steps_once (matches Coq: Lemma app_lam_steps_once) *)
val app_lam_steps_once_lemma : unit -> Lemma (True)
let app_lam_steps_once_lemma () = ()

(* step_to_multi (matches Coq: Lemma step_to_multi) *)
val step_to_multi_lemma : unit -> Lemma (True)
let step_to_multi_lemma () = ()

(* multi_step_trans (matches Coq: Lemma multi_step_trans) *)
val multi_step_trans_lemma : unit -> Lemma (True)
let multi_step_trans_lemma () = ()
