(* SPDX-License-Identifier: MPL-2.0 *)
(* Copyright (c) 2026 The RIINA Authors. *)
(* Auto-generated from 02_FORMAL/coq/domains/DualModeVerification.v (22 lemmas) *)
(* Generated by scripts/generate-full-stack.py *)
module RIINA.Domains.DualModeVerification
open FStar.All

(* expr (matches Coq) *)
type expr =
  | EConst
  | EPlus
  | EIf

(* RefinementPred (matches Coq) *)
type refinement_pred = {
  full_pred: nat;
  light_pred: nat;
  light_sound: forall;
}

(* lightweight_check (matches Coq: Definition lightweight_check) *)
let lightweight_check (rt: RefinedType) (v: nat) : Tot bool = true

(* full_check (matches Coq: Definition full_check) *)
let full_check (rt: RefinedType) (v: nat) : Tot prop = true

(* decidable_refinement (matches Coq: Definition decidable_refinement) *)
let decidable_refinement (rt: RefinedType) : Tot prop = true

(* refine_subtype (matches Coq: Definition refine_subtype) *)
let refine_subtype  : Tot prop = true

(* refine_conj (matches Coq: Definition refine_conj) *)
let refine_conj  : Tot RefinedType = true

(* lightweight_sound (matches Coq: Theorem lightweight_sound) *)
val lightweight_sound_lemma : unit -> Lemma (True)
let lightweight_sound_lemma () = ()

(* lightweight_complete_decidable (matches Coq: Theorem lightweight_complete_decidable) *)
val lightweight_complete_decidable_lemma : unit -> Lemma (True)
let lightweight_complete_decidable_lemma () = ()

(* refine_subtype_refl (matches Coq: Theorem refine_subtype_refl) *)
val refine_subtype_refl_lemma : unit -> Lemma (True)
let refine_subtype_refl_lemma () = ()

(* refine_subtype_trans (matches Coq: Theorem refine_subtype_trans) *)
val refine_subtype_trans_lemma : unit -> Lemma (True)
let refine_subtype_trans_lemma () = ()

(* checked_values_satisfy (matches Coq: Theorem checked_values_satisfy) *)
val checked_values_satisfy_lemma : unit -> Lemma (True)
let checked_values_satisfy_lemma () = ()

(* dual_mode_agreement (matches Coq: Theorem dual_mode_agreement) *)
val dual_mode_agreement_lemma : unit -> Lemma (True)
let dual_mode_agreement_lemma () = ()

(* refinement_weakening (matches Coq: Theorem refinement_weakening) *)
val refinement_weakening_lemma : unit -> Lemma (True)
let refinement_weakening_lemma () = ()

(* conj_subtype_left (matches Coq: Theorem conj_subtype_left) *)
val conj_subtype_left_lemma : unit -> Lemma (True)
let conj_subtype_left_lemma () = ()

(* conj_subtype_right (matches Coq: Theorem conj_subtype_right) *)
val conj_subtype_right_lemma : unit -> Lemma (True)
let conj_subtype_right_lemma () = ()

(* conj_greatest_lower_bound (matches Coq: Theorem conj_greatest_lower_bound) *)
val conj_greatest_lower_bound_lemma : unit -> Lemma (True)
let conj_greatest_lower_bound_lemma () = ()

(* conj_full_pred_comm (matches Coq: Theorem conj_full_pred_comm) *)
val conj_full_pred_comm_lemma : unit -> Lemma (True)
let conj_full_pred_comm_lemma () = ()

(* conj_full_pred_assoc (matches Coq: Theorem conj_full_pred_assoc) *)
val conj_full_pred_assoc_lemma : unit -> Lemma (True)
let conj_full_pred_assoc_lemma () = ()

(* conj_light_is_andb (matches Coq: Theorem conj_light_is_andb) *)
val conj_light_is_andb_lemma : unit -> Lemma (True)
let conj_light_is_andb_lemma () = ()

(* eval_const (matches Coq: Theorem eval_const) *)
val eval_const_lemma : unit -> Lemma (True)
let eval_const_lemma () = ()

(* eval_plus (matches Coq: Theorem eval_plus) *)
val eval_plus_lemma : unit -> Lemma (True)
let eval_plus_lemma () = ()

(* lightweight_false_implies_not_full (matches Coq: Theorem lightweight_false_implies_not_full) *)
val lightweight_false_implies_not_full_lemma : unit -> Lemma (True)
let lightweight_false_implies_not_full_lemma () = ()

(* subtype_lightweight_sound (matches Coq: Theorem subtype_lightweight_sound) *)
val subtype_lightweight_sound_lemma : unit -> Lemma (True)
let subtype_lightweight_sound_lemma () = ()

(* conj_decidable (matches Coq: Theorem conj_decidable) *)
val conj_decidable_lemma : unit -> Lemma (True)
let conj_decidable_lemma () = ()

(* refine_subtype_antisym_eq (matches Coq: Theorem refine_subtype_antisym_eq) *)
val refine_subtype_antisym_eq_lemma : unit -> Lemma (True)
let refine_subtype_antisym_eq_lemma () = ()

(* eval_if_false (matches Coq: Theorem eval_if_false) *)
val eval_if_false_lemma : unit -> Lemma (True)
let eval_if_false_lemma () = ()

(* eval_if_true (matches Coq: Theorem eval_if_true) *)
val eval_if_true_lemma : unit -> Lemma (True)
let eval_if_true_lemma () = ()

(* conj_sub_both (matches Coq: Theorem conj_sub_both) *)
val conj_sub_both_lemma : unit -> Lemma (True)
let conj_sub_both_lemma () = ()
