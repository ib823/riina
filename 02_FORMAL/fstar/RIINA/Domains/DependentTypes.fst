(* Copyright (c) 2026 The RIINA Authors. All rights reserved. *)
(* Auto-generated from 02_FORMAL/coq/domains/DependentTypes.v (33 lemmas) *)
(* Generated by scripts/generate-full-stack.py *)
module RIINA.Domains.DependentTypes
open FStar.All

(* DTerm (matches Coq) *)
type d_term =
  | DVar
  | DLam  (* λx:A.b *)
  | DApp  (* f a *)
  | DPair  (* (a, b) *)
  | DFst  (* π₁ *)
  | DSnd  (* π₂ *)
  | DRefl  (* refl *)
  | DJ  (* J eliminator *)
  | DNil  (* nil : Vec A 0 *)
  | DCons  (* cons : A → Vec A n → Vec A (S n) *)
  | DHead  (* head : Vec A (S n) → A *)
  | DTail  (* tail : Vec A (S n) → Vec A n *)

(* TYPE_005_01 (matches Coq: Theorem TYPE_005_01) *)
val TYPE_005_01_lemma : unit -> Lemma (True)
let TYPE_005_01_lemma () = ()

(* TYPE_005_02 (matches Coq: Theorem TYPE_005_02) *)
val TYPE_005_02_lemma : unit -> Lemma (True)
let TYPE_005_02_lemma () = ()

(* TYPE_005_03 (matches Coq: Theorem TYPE_005_03) *)
val TYPE_005_03_lemma : unit -> Lemma (True)
let TYPE_005_03_lemma () = ()

(* TYPE_005_04 (matches Coq: Theorem TYPE_005_04) *)
val TYPE_005_04_lemma : unit -> Lemma (True)
let TYPE_005_04_lemma () = ()

(* TYPE_005_05 (matches Coq: Theorem TYPE_005_05) *)
val TYPE_005_05_lemma : unit -> Lemma (True)
let TYPE_005_05_lemma () = ()

(* TYPE_005_06 (matches Coq: Theorem TYPE_005_06) *)
val TYPE_005_06_lemma : unit -> Lemma (True)
let TYPE_005_06_lemma () = ()

(* TYPE_005_07 (matches Coq: Theorem TYPE_005_07) *)
val TYPE_005_07_lemma : unit -> Lemma (True)
let TYPE_005_07_lemma () = ()

(* TYPE_005_08 (matches Coq: Theorem TYPE_005_08) *)
val TYPE_005_08_lemma : unit -> Lemma (True)
let TYPE_005_08_lemma () = ()

(* vec_cons_length_semantic (matches Coq: Lemma vec_cons_length_semantic) *)
val vec_cons_length_semantic_lemma : unit -> Lemma (True)
let vec_cons_length_semantic_lemma () = ()

(* TYPE_005_09 (matches Coq: Theorem TYPE_005_09) *)
val TYPE_005_09_lemma : unit -> Lemma (True)
let TYPE_005_09_lemma () = ()

(* vec_head_nonempty_semantic (matches Coq: Lemma vec_head_nonempty_semantic) *)
val vec_head_nonempty_semantic_lemma : unit -> Lemma (True)
let vec_head_nonempty_semantic_lemma () = ()

(* TYPE_005_10 (matches Coq: Theorem TYPE_005_10) *)
val TYPE_005_10_lemma : unit -> Lemma (True)
let TYPE_005_10_lemma () = ()

(* vec_dep_pattern_match (matches Coq: Lemma vec_dep_pattern_match) *)
val vec_dep_pattern_match_lemma : unit -> Lemma (True)
let vec_dep_pattern_match_lemma () = ()

(* TYPE_005_11 (matches Coq: Theorem TYPE_005_11) *)
val TYPE_005_11_lemma : unit -> Lemma (True)
let TYPE_005_11_lemma () = ()

(* transport_refl (matches Coq: Lemma transport_refl) *)
val transport_refl_lemma : unit -> Lemma (True)
let transport_refl_lemma () = ()

(* transport_trans (matches Coq: Lemma transport_trans) *)
val transport_trans_lemma : unit -> Lemma (True)
let transport_trans_lemma () = ()

(* TYPE_005_12 (matches Coq: Theorem TYPE_005_12) *)
val TYPE_005_12_lemma : unit -> Lemma (True)
let TYPE_005_12_lemma () = ()

(* dep_congruence (matches Coq: Lemma dep_congruence) *)
val dep_congruence_lemma : unit -> Lemma (True)
let dep_congruence_lemma () = ()

(* congruence2 (matches Coq: Lemma congruence2) *)
val congruence2_lemma : unit -> Lemma (True)
let congruence2_lemma () = ()

(* lt_wf_aux (matches Coq: Lemma lt_wf_aux) *)
val lt_wf_aux_lemma : unit -> Lemma (True)
let lt_wf_aux_lemma () = ()

(* lt_well_founded (matches Coq: Lemma lt_well_founded) *)
val lt_well_founded_lemma : unit -> Lemma (True)
let lt_well_founded_lemma () = ()

(* TYPE_005_13 (matches Coq: Theorem TYPE_005_13) *)
val TYPE_005_13_lemma : unit -> Lemma (True)
let TYPE_005_13_lemma () = ()

(* nat_dep_ind (matches Coq: Lemma nat_dep_ind) *)
val nat_dep_ind_lemma : unit -> Lemma (True)
let nat_dep_ind_lemma () = ()

(* strong_ind (matches Coq: Lemma strong_ind) *)
val strong_ind_lemma : unit -> Lemma (True)
let strong_ind_lemma () = ()

(* TYPE_005_14 (matches Coq: Theorem TYPE_005_14) *)
val TYPE_005_14_lemma : unit -> Lemma (True)
let TYPE_005_14_lemma () = ()

(* dec_eq_nat (matches Coq: Lemma dec_eq_nat) *)
val dec_eq_nat_lemma : unit -> Lemma (True)
let dec_eq_nat_lemma () = ()

(* dec_eq_bool (matches Coq: Lemma dec_eq_bool) *)
val dec_eq_bool_lemma : unit -> Lemma (True)
let dec_eq_bool_lemma () = ()

(* dec_eq_prod (matches Coq: Lemma dec_eq_prod) *)
val dec_eq_prod_lemma : unit -> Lemma (True)
let dec_eq_prod_lemma () = ()

(* dec_eq_option (matches Coq: Lemma dec_eq_option) *)
val dec_eq_option_lemma : unit -> Lemma (True)
let dec_eq_option_lemma () = ()

(* dec_eq_list (matches Coq: Lemma dec_eq_list) *)
val dec_eq_list_lemma : unit -> Lemma (True)
let dec_eq_list_lemma () = ()

(* dec_to_bool (matches Coq: Lemma dec_to_bool) *)
val dec_to_bool_lemma : unit -> Lemma (True)
let dec_to_bool_lemma () = ()

(* nat_eq_reflect (matches Coq: Lemma nat_eq_reflect) *)
val nat_eq_reflect_lemma : unit -> Lemma (True)
let nat_eq_reflect_lemma () = ()

(* uip_dec (matches Coq: Lemma uip_dec) *)
val uip_dec_lemma : unit -> Lemma (True)
let uip_dec_lemma () = ()
