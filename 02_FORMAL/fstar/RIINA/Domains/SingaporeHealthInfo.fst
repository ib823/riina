(* SPDX-License-Identifier: MPL-2.0 *)
(* Copyright (c) 2026 The RIINA Authors. *)
(* Auto-generated from 02_FORMAL/coq/domains/SingaporeHealthInfo.v (28 lemmas) *)
(* Generated by scripts/generate-full-stack.py *)
module RIINA.Domains.SingaporeHealthInfo
open FStar.All

(* SGHealthcareProvider (matches Coq) *)
type sg_healthcare_provider =
  | PublicHospital
  | PrivateHospital
  | GPClinic
  | SpecialistClinic
  | Polyclinic
  | Pharmacy_SG

(* HealthInfoCategory (matches Coq) *)
type health_info_category =
  | GeneralHealth
  | MentalHealthSG
  | HIV_STI_SG
  | GeneticInfo
  | SubstanceAbuse

(* UseType (matches Coq) *)
type use_type =
  | Treatment
  | Research
  | PublicHealth
  | InsuranceUnderwriting  (* PROHIBITED *)
  | Employment

(* hib_cybersecurity (matches Coq: Definition hib_cybersecurity) *)
let hib_cybersecurity (r: SGHealthRecord) : Tot prop = true

(* nehr_sharing_compliant (matches Coq: Definition nehr_sharing_compliant) *)
let nehr_sharing_compliant (r: SGHealthRecord) : Tot prop = true

(* hib_audit_compliant (matches Coq: Definition hib_audit_compliant) *)
let hib_audit_compliant (r: SGHealthRecord) : Tot prop = true

(* sg_health_sensitive (matches Coq: Definition sg_health_sensitive) *)
let sg_health_sensitive (c: HealthInfoCategory) : Tot prop = true

(* sensitive_health_protected (matches Coq: Definition sensitive_health_protected) *)
let sensitive_health_protected (r: SGHealthRecord) : Tot prop = true

(* use_permitted (matches Coq: Definition use_permitted) *)
let use_permitted (u: UseType) : Tot prop = true

(* hib_fully_compliant (matches Coq: Definition hib_fully_compliant) *)
let hib_fully_compliant (r: SGHealthRecord) : Tot prop = true

(* hib_access_deadline (matches Coq: Definition hib_access_deadline) *)
let hib_access_deadline  : Tot nat = true

(* patient_access_fulfilled (matches Coq: Definition patient_access_fulfilled) *)
let patient_access_fulfilled (req: PatientAccessRequest) : Tot prop = true

(* correction_properly_logged (matches Coq: Definition correction_properly_logged) *)
let correction_properly_logged (c: HealthDataCorrection) : Tot prop = true

(* exchange_authorized (matches Coq: Definition exchange_authorized) *)
let exchange_authorized (ex: HealthDataExchange) : Tot prop = true

(* hib_penalty_exposure (matches Coq: Definition hib_penalty_exposure) *)
let hib_penalty_exposure (r: SGHealthRecord) : Tot prop = true

(* public_hospital_nehr_mandatory (matches Coq: Definition public_hospital_nehr_mandatory) *)
let public_hospital_nehr_mandatory (r: SGHealthRecord) : Tot prop = true

(* hib_req_1 (matches Coq: Theorem hib_req_1) *)
val hib_req_1_lemma : unit -> Lemma (True)
let hib_req_1_lemma () = ()

(* hib_req_2 (matches Coq: Theorem hib_req_2) *)
val hib_req_2_lemma : unit -> Lemma (True)
let hib_req_2_lemma () = ()

(* hib_req_3 (matches Coq: Theorem hib_req_3) *)
val hib_req_3_lemma : unit -> Lemma (True)
let hib_req_3_lemma () = ()

(* hib_req_4 (matches Coq: Theorem hib_req_4) *)
val hib_req_4_lemma : unit -> Lemma (True)
let hib_req_4_lemma () = ()

(* hib_prohibited_insurance (matches Coq: Theorem hib_prohibited_insurance) *)
val hib_prohibited_insurance_lemma : unit -> Lemma (True)
let hib_prohibited_insurance_lemma () = ()

(* hib_prohibited_employment (matches Coq: Theorem hib_prohibited_employment) *)
val hib_prohibited_employment_lemma : unit -> Lemma (True)
let hib_prohibited_employment_lemma () = ()

(* hib_treatment_allowed (matches Coq: Theorem hib_treatment_allowed) *)
val hib_treatment_allowed_lemma : unit -> Lemma (True)
let hib_treatment_allowed_lemma () = ()

(* hib_composition (matches Coq: Theorem hib_composition) *)
val hib_composition_lemma : unit -> Lemma (True)
let hib_composition_lemma () = ()

(* sg_provider_coverage (matches Coq: Theorem sg_provider_coverage) *)
val sg_provider_coverage_lemma : unit -> Lemma (True)
let sg_provider_coverage_lemma () = ()

(* health_category_coverage (matches Coq: Theorem health_category_coverage) *)
val health_category_coverage_lemma : unit -> Lemma (True)
let health_category_coverage_lemma () = ()

(* patient_access_right (matches Coq: Theorem patient_access_right) *)
val patient_access_right_lemma : unit -> Lemma (True)
let patient_access_right_lemma () = ()

(* patient_access_late_violation (matches Coq: Theorem patient_access_late_violation) *)
val patient_access_late_violation_lemma : unit -> Lemma (True)
let patient_access_late_violation_lemma () = ()

(* data_correction_logged (matches Coq: Theorem data_correction_logged) *)
val data_correction_logged_lemma : unit -> Lemma (True)
let data_correction_logged_lemma () = ()

(* cross_institutional_exchange (matches Coq: Theorem cross_institutional_exchange) *)
val cross_institutional_exchange_lemma : unit -> Lemma (True)
let cross_institutional_exchange_lemma () = ()

(* general_health_not_sensitive (matches Coq: Theorem general_health_not_sensitive) *)
val general_health_not_sensitive_lemma : unit -> Lemma (True)
let general_health_not_sensitive_lemma () = ()

(* mental_health_is_sensitive (matches Coq: Theorem mental_health_is_sensitive) *)
val mental_health_is_sensitive_lemma : unit -> Lemma (True)
let mental_health_is_sensitive_lemma () = ()

(* hiv_sti_is_sensitive (matches Coq: Theorem hiv_sti_is_sensitive) *)
val hiv_sti_is_sensitive_lemma : unit -> Lemma (True)
let hiv_sti_is_sensitive_lemma () = ()

(* genetic_info_is_sensitive (matches Coq: Theorem genetic_info_is_sensitive) *)
val genetic_info_is_sensitive_lemma : unit -> Lemma (True)
let genetic_info_is_sensitive_lemma () = ()

(* nehr_requires_encryption (matches Coq: Theorem nehr_requires_encryption) *)
val nehr_requires_encryption_lemma : unit -> Lemma (True)
let nehr_requires_encryption_lemma () = ()

(* nehr_requires_sharing (matches Coq: Theorem nehr_requires_sharing) *)
val nehr_requires_sharing_lemma : unit -> Lemma (True)
let nehr_requires_sharing_lemma () = ()

(* use_type_coverage (matches Coq: Theorem use_type_coverage) *)
val use_type_coverage_lemma : unit -> Lemma (True)
let use_type_coverage_lemma () = ()

(* research_allowed (matches Coq: Theorem research_allowed) *)
val research_allowed_lemma : unit -> Lemma (True)
let research_allowed_lemma () = ()

(* public_health_allowed (matches Coq: Theorem public_health_allowed) *)
val public_health_allowed_lemma : unit -> Lemma (True)
let public_health_allowed_lemma () = ()

(* hib_full_implies_cybersecurity (matches Coq: Theorem hib_full_implies_cybersecurity) *)
val hib_full_implies_cybersecurity_lemma : unit -> Lemma (True)
let hib_full_implies_cybersecurity_lemma () = ()

(* hib_full_implies_audit (matches Coq: Theorem hib_full_implies_audit) *)
val hib_full_implies_audit_lemma : unit -> Lemma (True)
let hib_full_implies_audit_lemma () = ()

(* hib_full_implies_nehr (matches Coq: Theorem hib_full_implies_nehr) *)
val hib_full_implies_nehr_lemma : unit -> Lemma (True)
let hib_full_implies_nehr_lemma () = ()

(* cybersecurity_eliminates_penalty (matches Coq: Theorem cybersecurity_eliminates_penalty) *)
val cybersecurity_eliminates_penalty_lemma : unit -> Lemma (True)
let cybersecurity_eliminates_penalty_lemma () = ()

(* public_hospital_must_share (matches Coq: Theorem public_hospital_must_share) *)
val public_hospital_must_share_lemma : unit -> Lemma (True)
let public_hospital_must_share_lemma () = ()
