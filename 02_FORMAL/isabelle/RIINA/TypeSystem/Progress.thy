(* SPDX-License-Identifier: MPL-2.0 *)
(* Copyright (c) 2026 The RIINA Authors. See AUTHORS file. *)

(*
 * RIINA Progress - Isabelle/HOL Port
 *
 * Auto-generated port of 02_FORMAL/coq/type_system/Progress.v (9 theorems).
 *
 * Generated by scripts/generate-multiprover.py
 *
 * Correspondence Table:
 *
 * | Coq Definition     | Isabelle Definition    | Status |
 * |--------------------|------------------------|--------|
 * | canonical_bool     | canonical_bool         | OK     |
 * | canonical_fn       | canonical_fn           | OK     |
 * | canonical_pair     | canonical_pair         | OK     |
 * | canonical_sum      | canonical_sum          | OK     |
 * | canonical_ref      | canonical_ref          | OK     |
 * | canonical_secret   | canonical_secret       | OK     |
 * | canonical_proof    | canonical_proof        | OK     |
 * | lookup_nil_contra  | lookup_nil_contra      | OK     |
 * | progress           | progress               | OK     |
 *)

theory Progress
  imports Main
begin

(* canonical_bool (matches Coq) *)
lemma canonical_bool: "\<forall> v ε Σ, has_type nil Σ Public v TBool ε \<longrightarrow> value v \<longrightarrow> \<exists> b, v = EBool b"
  by simp

(* canonical_fn (matches Coq) *)
lemma canonical_fn: "\<forall> v T1 T2 ε ε' Σ, has_type nil Σ Public v (TFn T1 T2 ε) ε' \<longrightarrow> value v \<longrightarrow> \<exists> x body, v = ELam x T1 body"
  by simp

(* canonical_pair (matches Coq) *)
lemma canonical_pair: "\<forall> v T1 T2 ε Σ, has_type nil Σ Public v (TProd T1 T2) ε \<longrightarrow> value v \<longrightarrow> \<exists> v1 v2, v = EPair v1 v2 \<and> value v1 \<and> value v2"
  by auto

(* canonical_sum (matches Coq) *)
lemma canonical_sum: "\<forall> v T1 T2 ε Σ, has_type nil Σ Public v (TSum T1 T2) ε \<longrightarrow> value v \<longrightarrow> (\<exists> v', v = EInl v' T2 \<and> value v') \<or> (\<exists> v', v = EInr v' T1 \<and> value v')"
  by auto

(* canonical_ref (matches Coq) *)
lemma canonical_ref: "\<forall> v T l ε Σ, has_type nil Σ Public v (TRef T l) ε \<longrightarrow> value v \<longrightarrow> \<exists> l', v = ELoc l'"
  by simp

(* canonical_secret (matches Coq) *)
lemma canonical_secret: "\<forall> v T ε Σ, has_type nil Σ Public v (TSecret T) ε \<longrightarrow> value v \<longrightarrow> \<exists> v', v = EClassify v' \<and> value v'"
  by auto

(* canonical_proof (matches Coq) *)
lemma canonical_proof: "\<forall> v T ε Σ, has_type nil Σ Public v (TProof T) ε \<longrightarrow> value v \<longrightarrow> \<exists> v', v = EProve v' \<and> value v'"
  by auto

(* lookup_nil_contra (matches Coq) *)
lemma lookup_nil_contra: "\<forall> x T, lookup x nil = Some T \<longrightarrow> False"
  by auto

(* progress (matches Coq) *)
lemma progress: "progress_stmt"
  by (cases rule: ‹_›.cases; simp)

end
