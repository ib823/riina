(* SPDX-License-Identifier: MPL-2.0 *)
(* Copyright (c) 2026 The RIINA Authors. See AUTHORS file. *)

(*
 * RIINA Semantics - Isabelle/HOL Port
 *
 * Auto-generated port of 02_FORMAL/coq/foundations/Semantics.v (13 theorems).
 *
 * Generated by scripts/generate-multiprover.py
 *
 * Correspondence Table:
 *
 * | Coq Definition     | Isabelle Definition    | Status |
 * |--------------------|------------------------|--------|
 * | fresh_loc          | fresh_loc              | OK     |
 * | has_effect         | has_effect             | OK     |
 * | store_has_values   | store_has_values       | OK     |
 * | store_lookup_above_max | store_lookup_above_max | OK     |
 * | store_lookup_fresh | store_lookup_fresh     | OK     |
 * | value_not_step     | value_not_step         | OK     |
 * | value_does_not_step | value_does_not_step    | OK     |
 * | step_deterministic_cfg | step_deterministic_cfg | OK     |
 * | step_deterministic | step_deterministic     | OK     |
 * | store_update_lookup_eq | store_update_lookup_eq | OK     |
 * | store_update_lookup_neq | store_update_lookup_neq | OK     |
 * | store_has_values_empty | store_has_values_empty | OK     |
 * | store_update_preserves_values | store_update_preserves_values | OK     |
 * | step_preserves_store_values_aux | step_preserves_store_values_aux | OK     |
 * | step_preserves_store_values | step_preserves_store_values | OK     |
 * | multi_step_preserves_store_values | multi_step_preserves_store_values | OK     |
 *)

theory Semantics
  imports Main
begin

(* fresh_loc (matches Coq: Definition fresh_loc) *)
definition fresh_loc :: "store \<Rightarrow> loc" where
  "fresh_loc st \<equiv> S (store_max st)"

(* has_effect (matches Coq: Definition has_effect) *)
definition has_effect :: "effect \<Rightarrow> effect_ctx \<Rightarrow> bool" where
  "has_effect eff ctx \<equiv> In eff ctx"

(* store_has_values (matches Coq: Definition store_has_values) *)
definition store_has_values :: "store \<Rightarrow> bool" where
  "store_has_values st \<equiv> forall l v, store_lookup l st = Some v -> value v"

(* store_lookup_above_max (matches Coq) *)
lemma store_lookup_above_max: "\<forall> st l, store_max st < l \<longrightarrow> store_lookup l st = None"
  by (cases rule: ‹_›.cases; simp)

(* store_lookup_fresh (matches Coq) *)
lemma store_lookup_fresh: "\<forall> st, store_lookup (fresh_loc st) st = None"
  by auto

(* value_not_step (matches Coq) *)
lemma value_not_step: "\<forall> v st ctx cfg, value v \<longrightarrow> ~ ((v, st, ctx) --> cfg)"
  by auto

(* value_does_not_step (matches Coq) *)
lemma value_does_not_step: "\<forall> v st ctx e' st' ctx', value v \<longrightarrow> (v, st, ctx) --> (e', st', ctx') \<longrightarrow> False"
  by auto

(* step_deterministic_cfg (matches Coq) *)
lemma step_deterministic_cfg: "\<forall> cfg cfg1 cfg2, step cfg cfg1 \<longrightarrow> step cfg cfg2 \<longrightarrow> cfg1 = cfg2"
  by auto

(* step_deterministic (matches Coq) *)
lemma step_deterministic: "\<forall> t st ctx t1 st1 ctx1 t2 st2 ctx2, (t, st, ctx) --> (t1, st1, ctx1) \<longrightarrow> (t, st, ctx) --> (t2, st2, ctx2) \<longrightarrow> t1 = t2 \<and> st1 = st2 \<and> ctx1 = ctx2"
  by simp

(* store_update_lookup_eq (matches Coq) *)
lemma store_update_lookup_eq: "\<forall> st l v, store_lookup l (store_update l v st) = Some v"
  by (cases rule: ‹_›.cases; simp)

(* store_update_lookup_neq (matches Coq) *)
lemma store_update_lookup_neq: "\<forall> st l l' v, l \<noteq> l' \<longrightarrow> store_lookup l' (store_update l v st) = store_lookup l' st"
  by (cases rule: ‹_›.cases; simp)

(* Empty store has the values property *)
(* store_has_values_empty (matches Coq) *)
lemma store_has_values_empty: "store_has_values nil"
  by auto

(* store_update preserves store_has_values when updating with a value *)
(* store_update_preserves_values (matches Coq) *)
lemma store_update_preserves_values: "\<forall> st l v, store_has_values st \<longrightarrow> value v \<longrightarrow> store_has_values (store_update l v st)"
  by auto

(* Step preserves store_has_values - auxiliary for proving by induction *)
(* step_preserves_store_values_aux (matches Coq) *)
lemma step_preserves_store_values_aux: "\<forall> cfg1 cfg2, cfg1 --> cfg2 \<longrightarrow> store_has_values (snd (fst cfg1)) \<longrightarrow> store_has_values (snd (fst cfg2))"
  by auto

(* Step preserves store_has_values *)
(* step_preserves_store_values (matches Coq) *)
lemma step_preserves_store_values: "\<forall> e st ctx e' st' ctx', (e, st, ctx) --> (e', st', ctx') \<longrightarrow> store_has_values st \<longrightarrow> store_has_values st'"
  by auto

(* Multi-step preserves store_has_values *)
(* multi_step_preserves_store_values (matches Coq) *)
lemma multi_step_preserves_store_values: "\<forall> cfg1 cfg2, multi_step cfg1 cfg2 \<longrightarrow> store_has_values (snd (fst cfg1)) \<longrightarrow> store_has_values (snd (fst cfg2))"
  by auto

end
