(* SPDX-License-Identifier: MPL-2.0 *)
(* Copyright (c) 2026 The RIINA Authors. See AUTHORS file. *)

(*
 * RIINA Syntax - Isabelle/HOL Port
 *
 * Auto-generated port of 02_FORMAL/coq/foundations/Syntax.v (5 theorems).
 *
 * Generated by scripts/generate-multiprover.py
 *
 * Correspondence Table:
 *
 * | Coq Definition     | Isabelle Definition    | Status |
 * |--------------------|------------------------|--------|
 * | security_level     | security_level         | OK     |
 * | effect             | effect                 | OK     |
 * | taint_source       | taint_source           | OK     |
 * | sanitizer          | sanitizer              | OK     |
 * | capability_kind    | capability_kind        | OK     |
 * | ty                 | ty                     | OK     |
 * | expr               | expr                   | OK     |
 * | sec_level_num      | sec_level_num          | OK     |
 * | sec_leq            | sec_leq                | OK     |
 * | sec_leq_dec        | sec_leq_dec            | OK     |
 * | sec_join           | sec_join               | OK     |
 * | sec_meet           | sec_meet               | OK     |
 * | effect_cat         | effect_cat             | OK     |
 * | effect_level       | effect_level           | OK     |
 * | effect_join        | effect_join            | OK     |
 * | taint_combine      | taint_combine          | OK     |
 * | TCapabilityOld     | TCapabilityOld         | OK     |
 * | declass_ok         | declass_ok             | OK     |
 * | effect_join_pure_l | effect_join_pure_l     | OK     |
 * | effect_join_pure_r | effect_join_pure_r     | OK     |
 * | value_subst        | value_subst            | OK     |
 * | declass_ok_subst   | declass_ok_subst       | OK     |
 * | value_not_stuck    | value_not_stuck        | OK     |
 *)

theory Syntax
  imports Main
begin

(* security_level (matches Coq: Inductive security_level) *)
datatype security_level =
    LPublic  (* Publicly observable *)
  |     LInternal  (* Internal use only *)
  |     LSession  (* Session-scoped *)
  |     LUser  (* User-level sensitive *)
  |     LSystem  (* System-level sensitive *)
  |     LSecret

(* effect (matches Coq: Inductive effect) *)
datatype effect =
    EffPure  (* No observable effect *)
  |     EffRead  (* Memory/state read *)
  |     EffWrite  (* Memory/state write *)
  |     EffFileSystem  (* File system access *)
  (* Network effects *)
  |     EffNetwork  (* Network I/O *)
  |     EffNetSecure  (* Secure network (TLS) *)
  (* Crypto effects *)
  |     EffCrypto  (* Cryptographic operations *)
  |     EffRandom  (* Random number generation *)
  (* System effects *)
  |     EffSystem  (* System calls *)
  |     EffTime  (* Time/clock access *)
  |     EffProcess  (* Process management *)
  (* RIINA product effects - D40 integration *)
  |     EffPanel  (* Panel UI operations *)
  |     EffZirah  (* Zirah API operations *)
  |     EffBenteng  (* Benteng auth operations *)
  |     EffSandi  (* Sandi crypto operations *)
  |     EffMenara  (* Menara device operations *)
  |     EffGapura
  |     CatPure
  |     CatIO
  |     CatNetwork
  |     CatCrypto
  |     CatSystem
  |     CatProduct

(* taint_source (matches Coq: Inductive taint_source) *)
datatype taint_source =
    TaintNetworkExternal  (* External network input *)
  |     TaintNetworkInternal  (* Internal network input *)
  (* User input sources *)
  |     TaintUserInput  (* Direct user input *)
  |     TaintFileSystem  (* File system data *)
  |     TaintDatabase  (* Database query results *)
  |     TaintEnvironment  (* Environment variables *)
  (* RIINA product sources *)
  |     TaintGapuraRequest  (* Gapura API request *)
  |     TaintZirahEvent  (* Zirah event data *)
  |     TaintZirahEndpoint  (* Zirah endpoint data *)
  |     TaintBentengBiometric  (* Benteng biometric data *)
  |     TaintSandiSignature  (* Sandi signature input *)
  |     TaintMenaraDevice

(* sanitizer (matches Coq: Inductive sanitizer) *)
datatype sanitizer =
    SanHtmlEscape  (* HTML entity escaping *)
  |     SanUrlEncode  (* URL encoding *)
  |     SanJsEscape  (* JavaScript string escaping *)
  |     SanCssEscape  (* CSS escaping *)
  (* SQL sanitizers *)
  |     SanSqlEscape  (* SQL string escaping *)
  |     SanSqlParam  (* Parameterized query *)
  (* Injection prevention *)
  |     SanXssFilter  (* XSS filtering *)
  |     SanPathTraversal  (* Path traversal check *)
  |     SanCommandEscape  (* Command injection prevention *)
  |     SanLdapEscape  (* LDAP injection prevention *)
  |     SanXmlEscape  (* XML escaping *)
  (* Validation sanitizers *)
  |     SanJsonValidation  (* JSON structure validation *)
  |     SanXmlValidation  (* XML schema validation *)
  |     SanEmailValidation  (* Email format validation *)
  |     SanPhoneValidation  (* Phone format validation *)
  (* Bound sanitizers *)
  |     SanLengthBound  (* Maximum length check *)
  |     SanRangeBound  (* Numeric range check *)
  |     SanRegexMatch  (* Regex pattern match *)
  |     SanWhitelist  (* Whitelist check *)
  (* Crypto sanitizers *)
  |     SanHashVerify  (* Hash verification *)
  |     SanSignatureVerify  (* Signature verification *)
  |     SanMacVerify  (* MAC verification *)
  (* RIINA product sanitizers *)
  |     SanGapuraAuth  (* Gapura authentication check *)
  |     SanZirahSession  (* Zirah session validation *)
  |     SanBentengBiometric  (* Benteng biometric verification *)
  |     SanSandiDecrypt  (* Sandi decryption check *)
  |     SanMenaraAttestation
  |     SanSingle
  |     SanAnd  (* Both required *)
  |     SanSeq

(* capability_kind (matches Coq: Inductive capability_kind) *)
datatype capability_kind =
    CapFileRead  (* Read file *)
  |     CapFileWrite  (* Write file *)
  |     CapFileExecute  (* Execute file *)
  |     CapFileDelete  (* Delete file *)
  (* Network capabilities *)
  |     CapNetConnect  (* Outbound connection *)
  |     CapNetListen  (* Listen for connections *)
  |     CapNetBind  (* Bind to port *)
  (* Process capabilities *)
  |     CapProcSpawn  (* Spawn process *)
  |     CapProcSignal  (* Send signal *)
  (* System capabilities *)
  |     CapSysTime  (* Access system time *)
  |     CapSysRandom  (* Access random *)
  |     CapSysEnv  (* Access environment *)
  (* RIINA product capabilities *)
  |     CapRootProduct  (* Root product capability *)
  |     CapProductAccess
  |     CapBasic
  |     CapRevocable
  |     CapTimeBound  (* Expires after N seconds *)
  |     CapDelegated

(* ty (matches Coq: Inductive ty) *)
datatype ty =
    TUnit
  |     TBool
  |     TInt
  |     TString
  |     TBytes  (* Function types *)
  |     TFn  (* T1 -[ε]-> T2 *)
  (* Compound types *)
  |     TProd  (* T1 × T2 *)
  |     TSum  (* T1 + T2 *)
  |     TList  (* List[T] *)
  |     TOption  (* Option[T] *)
  (* Reference types *)
  |     TRef  (* Ref[T]@l *)
  (* Security types - D42 integration *)
  |     TSecret  (* Secret[T] - classified data *)
  |     TLabeled  (* Labeled[T, l] - security label *)
  |     TTainted  (* Tainted[T, src] - tainted data *)
  |     TSanitized  (* Sanitized[T, san] - sanitized data *)
  |     TProof  (* Proof[T] - declassification proof *)
  (* Capability types - D42-J integration *)
  |     TCapability  (* Cap[kind] *)
  |     TCapabilityFull  (* Full capability with constraints *)
  (* Session types - D42-F integration *)
  |     TChan  (* Chan[S] - channel with session *)
  |     TSecureChan  (* SecureChan[S, l] *)
  (* Constant-time types - for crypto *)
  |     TConstantTime  (* ConstantTime[T] *)
  (* Zeroizing types - secure memory *)
  |     TZeroizing
  |     SessEnd  (* Session end *)
  |     SessSend  (* !T.S - send T then continue *)
  |     SessRecv  (* ?T.S - receive T then continue *)
  |     SessSelect  (* S1 ⊕ S2 - internal choice *)
  |     SessBranch  (* S1 & S2 - external choice *)
  |     SessRec  (* μX.S - recursive session *)
  |     SessVar

(* expr (matches Coq: Inductive expr) *)
datatype expr =
    EUnit
  |     EBool
  |     EInt
  |     EString
  |     ELoc
  |     EVar  (* Functions *)
  |     ELam  (* λx:T. e *)
  |     EApp  (* e1 e2 *)
  
  (* Products *)
  |     EPair  (* (e1, e2) *)
  |     EFst  (* fst e *)
  |     ESnd  (* snd e *)
  
  (* Sums *)
  |     EInl  (* inl e : T *)
  |     EInr  (* inr e : T *)
  |     ECase
  |     EIf  (* if e1 then e2 else e3 *)
  |     ELet  (* let x = e1 in e2 *)
  
  (* Effects *)
  |     EPerform  (* perform ε e *)
  |     EHandle  (* handle e with x => h *)
  
  (* References *)
  |     ERef  (* ref e @ l *)
  |     EDeref  (* !e *)
  |     EAssign  (* e1 := e2 *)
  
  (* Security *)
  |     EClassify  (* classify e *)
  |     EDeclassify  (* declassify e with proof *)
  |     EProve  (* prove e *)
  
  (* Capabilities *)
  |     ERequire  (* require ε in e *)
  |     EGrant

(* sec_level_num (matches Coq: Definition sec_level_num) *)
fun sec_level_num :: "security_level \<Rightarrow> nat" where
  "sec_level_num LPublic = 0"
|   "sec_level_num LInternal = 1"
|   "sec_level_num LSession = 2"
|   "sec_level_num LUser = 3"
|   "sec_level_num LSystem = 4"
|   "sec_level_num LSecret = 5"

(* sec_leq (matches Coq: Definition sec_leq) *)
definition sec_leq :: "bool" where
  "sec_leq \<equiv> sec_level_num l1 <= sec_level_num l2"

(* sec_leq_dec (matches Coq: Definition sec_leq_dec) *)
definition sec_leq_dec :: "bool" where
  "sec_leq_dec \<equiv> Nat"

(* sec_join (matches Coq: Definition sec_join) *)
definition sec_join :: "security_level" where
  "sec_join \<equiv> if Nat"

(* sec_meet (matches Coq: Definition sec_meet) *)
definition sec_meet :: "security_level" where
  "sec_meet \<equiv> if Nat"

(* effect_cat (matches Coq: Definition effect_cat) *)
fun effect_cat :: "effect \<Rightarrow> effect_category" where
  "effect_cat EffPure = CatPure"
|   "effect_cat EffFileSystem = CatIO"
|   "effect_cat EffNetSecure = CatNetwork"
|   "effect_cat EffRandom = CatCrypto"
|   "effect_cat EffProcess = CatSystem"
|   "effect_cat EffGapura = CatProduct"

(* effect_level (matches Coq: Definition effect_level) *)
fun effect_level :: "effect \<Rightarrow> nat" where
  "effect_level EffPure = 0"
|   "effect_level EffRead = 1"
|   "effect_level EffWrite = 2"
|   "effect_level EffFileSystem = 3"
|   "effect_level EffNetwork = 4"
|   "effect_level EffNetSecure = 5"
|   "effect_level EffCrypto = 6"
|   "effect_level EffRandom = 7"
|   "effect_level EffSystem = 8"
|   "effect_level EffTime = 9"
|   "effect_level EffProcess = 10"
|   "effect_level EffPanel = 11"
|   "effect_level EffZirah = 12"
|   "effect_level EffBenteng = 13"
|   "effect_level EffSandi = 14"
|   "effect_level EffMenara = 15"
|   "effect_level EffGapura = 16"

(* effect_join (matches Coq: Definition effect_join) *)
definition effect_join :: "effect" where
  "effect_join \<equiv> if Nat"

(* taint_combine (matches Coq: Definition taint_combine) *)
fun taint_combine :: "taint_source" where
  "taint_combine TaintNetworkExternal = t1"
|   "taint_combine _ = t2"

(* TCapabilityOld (matches Coq: Definition TCapabilityOld) *)
fun TCapabilityOld :: "effect \<Rightarrow> ty" where
  "TCapabilityOld EffPure = CapSysRandom"
|   "TCapabilityOld EffRead = CapFileRead"
|   "TCapabilityOld EffWrite = CapFileWrite"
|   "TCapabilityOld EffNetwork = CapNetConnect"
|   "TCapabilityOld _ = CapSysRandom"

(* declass_ok (matches Coq: Definition declass_ok) *)
definition declass_ok :: "bool" where
  "declass_ok \<equiv> exists v, value v /\ e1 = EClassify v /\ e2 = EProve (EClassify v)"

(* Pure is identity for effect join *)
(* effect_join_pure_l (matches Coq) *)
lemma effect_join_pure_l: "\<forall> e, effect_join EffPure e = e"
  by (cases rule: ‹_›.cases; simp)

(* effect_join_pure_r (matches Coq) *)
lemma effect_join_pure_r: "\<forall> e, effect_join e EffPure = e"
  by (cases rule: ‹_›.cases; simp)

(* value_subst (matches Coq) *)
lemma value_subst: "\<forall> x v1 v2, value v1 \<longrightarrow> value v2 \<longrightarrow> value ([x := v2] v1)"
  by auto

(* declass_ok_subst (matches Coq) *)
lemma declass_ok_subst: "\<forall> x v e1 e2, value v \<longrightarrow> declass_ok e1 e2 \<longrightarrow> declass_ok ([x := v] e1) ([x := v] e2)"
  by (cases rule: ‹_›.cases; simp)

(* value_not_stuck (matches Coq) *)
lemma value_not_stuck: "\<forall> e, value e \<longrightarrow> e = EUnit \<or> (\<exists> b, e = EBool b) \<or> (\<exists> n, e = EInt n) \<or> (\<exists> s, e = EString s) \<or> (\<exists> x T body, e = ELam x T body) \<or> (\<exists> v1 v2, e = EPair v1 v2) \<or> (\<exists> v T, e = EInl v T) \<or> (\<exists> v T, e = EInr v T) \<or> (\<exists> l, e = ELoc l) \<or> (\<exists> v, e = EClassify v) \<or> (\<exists> v, e = EProve v)"
  by simp

end
