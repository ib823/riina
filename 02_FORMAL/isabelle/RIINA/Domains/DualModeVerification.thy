(* SPDX-License-Identifier: MPL-2.0 *)
(* Copyright (c) 2026 The RIINA Authors. See AUTHORS file. *)

(*
 * RIINA DualModeVerification - Isabelle/HOL Port
 *
 * Auto-generated port of 02_FORMAL/coq/domains/DualModeVerification.v (22 theorems).
 *
 * Generated by scripts/generate-multiprover.py
 *
 * Correspondence Table:
 *
 * | Coq Definition     | Isabelle Definition    | Status |
 * |--------------------|------------------------|--------|
 * | expr               | expr                   | OK     |
 * | RefinementPred     | refinement_pred        | OK     |
 * | lightweight_check  | lightweight_check      | OK     |
 * | full_check         | full_check             | OK     |
 * | decidable_refinement | decidable_refinement   | OK     |
 * | refine_subtype     | refine_subtype         | OK     |
 * | refine_conj        | refine_conj            | OK     |
 * | lightweight_sound  | lightweight_sound      | OK     |
 * | lightweight_complete_decidable | lightweight_complete_decidable | OK     |
 * | refine_subtype_refl | refine_subtype_refl    | OK     |
 * | refine_subtype_trans | refine_subtype_trans   | OK     |
 * | checked_values_satisfy | checked_values_satisfy | OK     |
 * | dual_mode_agreement | dual_mode_agreement    | OK     |
 * | refinement_weakening | refinement_weakening   | OK     |
 * | conj_subtype_left  | conj_subtype_left      | OK     |
 * | conj_subtype_right | conj_subtype_right     | OK     |
 * | conj_greatest_lower_bound | conj_greatest_lower_bound | OK     |
 * | conj_full_pred_comm | conj_full_pred_comm    | OK     |
 * | conj_full_pred_assoc | conj_full_pred_assoc   | OK     |
 * | conj_light_is_andb | conj_light_is_andb     | OK     |
 * | eval_const         | eval_const             | OK     |
 * | eval_plus          | eval_plus              | OK     |
 * | lightweight_false_implies_not_full | lightweight_false_implies_not_full | OK     |
 * | subtype_lightweight_sound | subtype_lightweight_sound | OK     |
 * | conj_decidable     | conj_decidable         | OK     |
 * | refine_subtype_antisym_eq | refine_subtype_antisym_eq | OK     |
 * | eval_if_false      | eval_if_false          | OK     |
 * | eval_if_true       | eval_if_true           | OK     |
 * | conj_sub_both      | conj_sub_both          | OK     |
 *)

theory DualModeVerification
  imports Main
begin

(* Boolean conjunction helper (matches Coq: andb_true_iff) *)
lemma andb_true_iff: "(a \<and> b) = True \<longleftrightarrow> a = True \<and> b = True"
  by auto

(* expr (matches Coq: Inductive expr) *)
datatype expr =
    EConst
  |     EPlus
  |     EIf

(* RefinementPred (matches Coq: Record RefinementPred) *)
record refinement_pred =
  full_pred :: nat
  light_pred :: nat
  light_sound :: forall

(* lightweight_check (matches Coq: Definition lightweight_check) *)
definition lightweight_check :: "RefinedType \<Rightarrow> nat \<Rightarrow> bool" where
  "lightweight_check rt v \<equiv> light_pred rt v"

(* full_check (matches Coq: Definition full_check) *)
definition full_check :: "RefinedType \<Rightarrow> nat \<Rightarrow> bool" where
  "full_check rt v \<equiv> full_pred rt v"

(* decidable_refinement (matches Coq: Definition decidable_refinement) *)
definition decidable_refinement :: "RefinedType \<Rightarrow> bool" where
  "decidable_refinement rt \<equiv> forall n, full_pred rt n <-> light_pred rt n = true"

(* refine_subtype (matches Coq: Definition refine_subtype) *)
definition refine_subtype :: "bool" where
  "refine_subtype \<equiv> forall n, full_pred r1 n -> full_pred r2 n"

(* refine_conj (matches Coq: Definition refine_conj) *)
definition refine_conj :: "RefinedType" where
  "refine_conj \<equiv> mkRefinement
    (fun n => full_pred r1 n /\ full_pred r2 n)
    (fun n => light_pred r1 n \<and> light_pred r2 n)
    (fun n H =>
       let P := andb_prop _ _ H in
       conj (light_sound r1 n (proj1 P)) (light_sound r2 n (proj2 P)))"

(* Theorem 1: Lightweight checking is sound. *)
(* lightweight_sound (matches Coq) *)
lemma lightweight_sound: "\<forall> (rt : RefinedType) (v : nat), lightweight_check rt v = True \<longrightarrow> full_check rt v"
  by auto

(* Theorem 2: For decidable predicates, lightweight is complete. *)
(* lightweight_complete_decidable (matches Coq) *)
lemma lightweight_complete_decidable: "\<forall> (rt : RefinedType) (v : nat), decidable_refinement rt \<longrightarrow> full_check rt v \<longrightarrow> lightweight_check rt v = True"
  by auto

(* Theorem 3: Refinement subtyping is reflexive. *)
(* refine_subtype_refl (matches Coq) *)
lemma refine_subtype_refl: "\<forall> (rt : RefinedType), refine_subtype rt rt"
  by auto

(* Theorem 4: Refinement subtyping is transitive. *)
(* refine_subtype_trans (matches Coq) *)
lemma refine_subtype_trans: "\<forall> (r1 r2 r3 : RefinedType), refine_subtype r1 r2 \<longrightarrow> refine_subtype r2 r3 \<longrightarrow> refine_subtype r1 r3"
  by auto

(* Theorem 5: Checked values satisfy their refinements. *)
(* checked_values_satisfy (matches Coq) *)
lemma checked_values_satisfy: "\<forall> (rt : RefinedType) (e : expr), lightweight_check rt (eval e) = True \<longrightarrow> full_check rt (eval e)"
  by auto

(* Theorem 6: Dual-mode agrees on decidable predicates. *)
(* dual_mode_agreement (matches Coq) *)
lemma dual_mode_agreement: "\<forall> (rt : RefinedType) (v : nat), decidable_refinement rt \<longrightarrow> (lightweight_check rt v = True <-> full_check rt v)"
  by auto

(* Theorem 7: Weakening — stronger refinement implies weaker. *)
(* refinement_weakening (matches Coq) *)
lemma refinement_weakening: "\<forall> (r1 r2 : RefinedType) (v : nat), refine_subtype r1 r2 \<longrightarrow> full_check r1 v \<longrightarrow> full_check r2 v"
  by auto

(* Theorem 8: Conjunction subtype left projection. *)
(* conj_subtype_left (matches Coq) *)
lemma conj_subtype_left: "\<forall> (r1 r2 : RefinedType), refine_subtype (refine_conj r1 r2) r1"
  by auto

(* Theorem 9: Conjunction subtype right projection. *)
(* conj_subtype_right (matches Coq) *)
lemma conj_subtype_right: "\<forall> (r1 r2 : RefinedType), refine_subtype (refine_conj r1 r2) r2"
  by auto

(* Theorem 10: Conjunction is the greatest lower bound. *)
(* conj_greatest_lower_bound (matches Coq) *)
lemma conj_greatest_lower_bound: "\<forall> (r1 r2 r3 : RefinedType), refine_subtype r3 r1 \<longrightarrow> refine_subtype r3 r2 \<longrightarrow> refine_subtype r3 (refine_conj r1 r2)"
  by auto

(* Theorem 11: Conjunction is commutative on full_pred *)
(* conj_full_pred_comm (matches Coq) *)
lemma conj_full_pred_comm: "\<forall> (r1 r2 : RefinedType) (v : nat), full_pred (refine_conj r1 r2) v <-> full_pred (refine_conj r2 r1) v"
  by auto

(* Theorem 12: Conjunction is associative on full_pred *)
(* conj_full_pred_assoc (matches Coq) *)
lemma conj_full_pred_assoc: "\<forall> (r1 r2 r3 : RefinedType) (v : nat), full_pred (refine_conj (refine_conj r1 r2) r3) v <-> full_pred (refine_conj r1 (refine_conj r2 r3)) v"
  by auto

(* Theorem 13: Conjunction light_pred is AND *)
(* conj_light_is_andb (matches Coq) *)
lemma conj_light_is_andb: "\<forall> (r1 r2 : RefinedType) (v : nat), light_pred (refine_conj r1 r2) v = (light_pred r1 v && light_pred r2 v)%bool"
  by simp

(* Theorem 14: Eval of EConst is the constant itself *)
(* eval_const (matches Coq) *)
lemma eval_const: "\<forall> n, eval (EConst n) = n"
  by simp

(* Theorem 15: Eval of EPlus is sum of evaluations *)
(* eval_plus (matches Coq) *)
lemma eval_plus: "\<forall> e1 e2, eval (EPlus e1 e2) = eval e1 + eval e2"
  by simp

(* Theorem 16: Lightweight check false implies not full_check for decidable *)
(* lightweight_false_implies_not_full (matches Coq) *)
lemma lightweight_false_implies_not_full: "\<forall> (rt : RefinedType) (v : nat), decidable_refinement rt \<longrightarrow> lightweight_check rt v = False \<longrightarrow> ~ full_check rt v"
  by auto

(* Theorem 17: Subtype preserves lightweight soundness *)
(* subtype_lightweight_sound (matches Coq) *)
lemma subtype_lightweight_sound: "\<forall> (r1 r2 : RefinedType) (v : nat), refine_subtype r1 r2 \<longrightarrow> lightweight_check r1 v = True \<longrightarrow> full_check r2 v"
  by auto

(* Theorem 18: Conjunction of decidable refinements is decidable *)
(* conj_decidable (matches Coq) *)
lemma conj_decidable: "\<forall> (r1 r2 : RefinedType), decidable_refinement r1 \<longrightarrow> decidable_refinement r2 \<longrightarrow> decidable_refinement (refine_conj r1 r2)"
  by auto

(* Theorem 19: Refine_subtype is antisymmetric under full_pred equality *)
(* refine_subtype_antisym_eq (matches Coq) *)
lemma refine_subtype_antisym_eq: "\<forall> (r1 r2 : RefinedType), refine_subtype r1 r2 \<longrightarrow> refine_subtype r2 r1 \<longrightarrow> \<forall> n, full_pred r1 n <-> full_pred r2 n"
  by auto

(* Theorem 20: Eval of EIf with 0 guard takes else branch *)
(* eval_if_false (matches Coq) *)
lemma eval_if_false: "\<forall> et ef, eval (EIf (EConst 0) et ef) = eval ef"
  by simp

(* Theorem 21: Eval of EIf with nonzero guard takes then branch *)
(* eval_if_true (matches Coq) *)
lemma eval_if_true: "\<forall> n et ef, n \<noteq> 0 \<longrightarrow> eval (EIf (EConst n) et ef) = eval et"
  by (cases rule: ‹_›.cases; simp)

(* Theorem 22: Conjunction subtyping both ways *)
(* conj_sub_both (matches Coq) *)
lemma conj_sub_both: "\<forall> (r1 r2 : RefinedType) (v : nat), full_check (refine_conj r1 r2) v \<longrightarrow> full_check r1 v \<and> full_check r2 v"
  by auto

end
