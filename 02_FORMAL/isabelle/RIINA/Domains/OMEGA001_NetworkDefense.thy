(* SPDX-License-Identifier: MPL-2.0 *)
(* Copyright (c) 2026 The RIINA Authors. See AUTHORS file. *)

(*
 * RIINA OMEGA001_NetworkDefense - Isabelle/HOL Port
 *
 * Auto-generated port of 02_FORMAL/coq/domains/OMEGA001_NetworkDefense.v (30 theorems).
 *
 * Generated by scripts/generate-multiprover.py
 *
 * Correspondence Table:
 *
 * | Coq Definition     | Isabelle Definition    | Status |
 * |--------------------|------------------------|--------|
 * | ConnState          | conn_state             | OK     |
 * | TokenBucket        | token_bucket           | OK     |
 * | NetCapability      | net_capability         | OK     |
 * | SynCookie          | syn_cookie             | OK     |
 * | Connection         | connection             | OK     |
 * | tb_refill          | tb_refill              | OK     |
 * | tb_available       | tb_available           | OK     |
 * | cap_valid          | cap_valid              | OK     |
 * | cap_permits        | cap_permits            | OK     |
 * | cap_is_subset      | cap_is_subset          | OK     |
 * | hmac_compute       | hmac_compute           | OK     |
 * | syn_cookie_generate | syn_cookie_generate    | OK     |
 * | syn_cookie_verify  | syn_cookie_verify      | OK     |
 * | pow_hash           | pow_hash               | OK     |
 * | pow_valid          | pow_valid              | OK     |
 * | pow_verify         | pow_verify             | OK     |
 * | conn_count_by_src  | conn_count_by_src      | OK     |
 * | conn_limit_per_src | conn_limit_per_src     | OK     |
 * | conn_allowed       | conn_allowed           | OK     |
 * | OMEGA_001_01_tb_capacity_bound | OMEGA_001_01_tb_capacity_bound | OK     |
 * | OMEGA_001_02_tb_consume_decreases | OMEGA_001_02_tb_consume_decreases | OK     |
 * | OMEGA_001_03_tb_consume_fails_insufficient | OMEGA_001_03_tb_consume_fails_insufficient | OK     |
 * | OMEGA_001_04_tb_refill_monotone | OMEGA_001_04_tb_refill_monotone | OK     |
 * | OMEGA_001_05_tb_consume_preserves_capacity | OMEGA_001_05_tb_consume_preserves_capacity | OK     |
 * | OMEGA_001_06_tb_zero_cost_always_succeeds | OMEGA_001_06_tb_zero_cost_always_succeeds | OK     |
 * | OMEGA_001_07_tb_refill_preserves_capacity | OMEGA_001_07_tb_refill_preserves_capacity | OK     |
 * | OMEGA_001_08_tb_available_bound | OMEGA_001_08_tb_available_bound | OK     |
 * | OMEGA_002_01_expired_cap_invalid | OMEGA_002_01_expired_cap_invalid | OK     |
 * | OMEGA_002_02_cap_subset_reflexive | OMEGA_002_02_cap_subset_reflexive | OK     |
 * | OMEGA_002_03_delegation_attenuation | OMEGA_002_03_delegation_attenuation | OK     |
 * | OMEGA_002_04_delegation_permission_subset | OMEGA_002_04_delegation_permission_subset | OK     |
 * | OMEGA_002_05_nondelegatable_blocks | OMEGA_002_05_nondelegatable_blocks | OK     |
 * | OMEGA_002_06_empty_cap_permits_nothing | OMEGA_002_06_empty_cap_permits_nothing | OK     |
 * | OMEGA_002_07_cap_permits_sound | OMEGA_002_07_cap_permits_sound | OK     |
 * | OMEGA_003_01_syn_cookie_verify_sound | OMEGA_003_01_syn_cookie_verify_sound | OK     |
 * | OMEGA_003_02_syn_cookie_wrong_secret | OMEGA_003_02_syn_cookie_wrong_secret | OK     |
 * | OMEGA_003_03_syn_cookie_deterministic | OMEGA_003_03_syn_cookie_deterministic | OK     |
 * | OMEGA_003_04_syn_cookie_stateless | OMEGA_003_04_syn_cookie_stateless | OK     |
 * | OMEGA_003_05_syn_cookie_ip_sensitive | OMEGA_003_05_syn_cookie_ip_sensitive | OK     |
 * | OMEGA_003_06_wrong_mac_rejected | OMEGA_003_06_wrong_mac_rejected | OK     |
 * | OMEGA_004_01_empty_table_allows | OMEGA_004_01_empty_table_allows | OK     |
 * | OMEGA_004_02_conn_count_nonneg | OMEGA_004_02_conn_count_nonneg | OK     |
 * | OMEGA_004_03_conn_count_bound | OMEGA_004_03_conn_count_bound | OK     |
 * | OMEGA_004_04_conn_lookup_deterministic | OMEGA_004_04_conn_lookup_deterministic | OK     |
 * | OMEGA_004_05_pow_verify_sound | OMEGA_004_05_pow_verify_sound | OK     |
 * | OMEGA_005_01_pow_deterministic | OMEGA_005_01_pow_deterministic | OK     |
 * | OMEGA_005_02_pow_zero_difficulty_impossible | OMEGA_005_02_pow_zero_difficulty_impossible | OK     |
 * | OMEGA_005_03_pow_verify_complete | OMEGA_005_03_pow_verify_complete | OK     |
 * | OMEGA_005_04_pow_hash_deterministic | OMEGA_005_04_pow_hash_deterministic | OK     |
 *)

theory OMEGA001_NetworkDefense
  imports Main
begin

(* ConnState (matches Coq: Inductive ConnState) *)
datatype conn_state =
    ConnNew
  |     ConnEstablished
  |     ConnClosing
  |     ConnClosed

(* TokenBucket (matches Coq: Record TokenBucket) *)
record token_bucket =
  tb_tokens :: nat
  tb_capacity :: nat
  tb_refill_rate :: nat  (* tokens per tick *)
  tb_last_refill :: nat  (* tick count *)

(* NetCapability (matches Coq: Record NetCapability) *)
record net_capability =
  cap_id :: nat
  cap_permissions :: 'a list
  cap_expiry :: nat
  cap_delegatable :: bool
  cap_signature :: nat  (* HMAC signature *)

(* SynCookie (matches Coq: Record SynCookie) *)
record syn_cookie =
  sc_client_ip :: nat
  sc_client_port :: nat
  sc_server_port :: nat
  sc_timestamp :: nat
  sc_mss_index :: nat

(* Connection (matches Coq: Record Connection) *)
record connection =
  conn_src :: nat
  conn_dst :: nat
  conn_state :: ConnState
  conn_bytes_in :: nat
  conn_bytes_out :: nat
  conn_start_time :: nat

(* tb_refill (matches Coq: Definition tb_refill) *)
definition tb_refill :: "TokenBucket \<Rightarrow> nat \<Rightarrow> TokenBucket" where
  "tb_refill tb now \<equiv> let elapsed := now - tb_last_refill tb in
  let new_tokens := Nat"

(* tb_available (matches Coq: Definition tb_available) *)
definition tb_available :: "TokenBucket \<Rightarrow> nat" where
  "tb_available tb \<equiv> tb_tokens tb"

(* cap_valid (matches Coq: Definition cap_valid) *)
definition cap_valid :: "NetCapability \<Rightarrow> nat \<Rightarrow> bool" where
  "cap_valid cap now \<equiv> now <? cap_expiry cap"

(* cap_permits (matches Coq: Definition cap_permits) *)
definition cap_permits :: "NetCapability \<Rightarrow> nat \<Rightarrow> bool" where
  "cap_permits cap port \<equiv> existsb (Nat"

(* cap_is_subset (matches Coq: Definition cap_is_subset) *)
definition cap_is_subset :: "bool" where
  "cap_is_subset \<equiv> forallb (fun p => existsb (Nat"

(* hmac_compute (matches Coq: Definition hmac_compute) *)
definition hmac_compute :: "nat \<Rightarrow> nat \<Rightarrow> nat" where
  "hmac_compute key data \<equiv> key + data"

(* syn_cookie_generate (matches Coq: Definition syn_cookie_generate) *)
definition syn_cookie_generate :: "nat \<Rightarrow> SynCookie \<Rightarrow> nat" where
  "syn_cookie_generate secret cookie \<equiv> hmac_compute secret (sc_client_ip cookie + sc_client_port cookie +
                       sc_server_port cookie + sc_timestamp cookie)"

(* syn_cookie_verify (matches Coq: Definition syn_cookie_verify) *)
definition syn_cookie_verify :: "nat \<Rightarrow> SynCookie \<Rightarrow> nat \<Rightarrow> bool" where
  "syn_cookie_verify secret cookie mac \<equiv> Nat"

(* pow_hash (matches Coq: Definition pow_hash) *)
definition pow_hash :: "nat" where
  "pow_hash \<equiv> nonce + challenge"

(* pow_valid (matches Coq: Definition pow_valid) *)
definition pow_valid :: "bool" where
  "pow_valid \<equiv> pow_hash nonce challenge <? difficulty"

(* pow_verify (matches Coq: Definition pow_verify) *)
definition pow_verify :: "bool" where
  "pow_verify \<equiv> pow_valid nonce challenge difficulty"

(* conn_count_by_src (matches Coq: Definition conn_count_by_src) *)
definition conn_count_by_src :: "ConnTable \<Rightarrow> nat \<Rightarrow> nat" where
  "conn_count_by_src table src \<equiv> length (filter (fun c => Nat"

(* conn_limit_per_src (matches Coq: Definition conn_limit_per_src) *)
definition conn_limit_per_src :: "nat" where
  "conn_limit_per_src \<equiv> 100"

(* conn_allowed (matches Coq: Definition conn_allowed) *)
definition conn_allowed :: "ConnTable \<Rightarrow> nat \<Rightarrow> bool" where
  "conn_allowed table src \<equiv> conn_count_by_src table src <? conn_limit_per_src"

(* ===============================================================================
    PROOFS: RATE LIMITING (8 theorems)
    =============================================================================== *)
(* OMEGA_001_01_tb_capacity_bound (matches Coq) *)
lemma OMEGA_001_01_tb_capacity_bound: "\<forall> tb now, tb_tokens (tb_refill tb now) \<le> tb_capacity tb"
  by auto

(* OMEGA_001_02_tb_consume_decreases (matches Coq) *)
lemma OMEGA_001_02_tb_consume_decreases: "\<forall> tb cost tb', tb_consume tb cost = Some tb' \<longrightarrow> tb_tokens tb' = tb_tokens tb - cost"
  by (cases rule: ‹_›.cases; simp)

(* OMEGA_001_03_tb_consume_fails_insufficient (matches Coq) *)
lemma OMEGA_001_03_tb_consume_fails_insufficient: "\<forall> tb cost, tb_tokens tb < cost \<longrightarrow> tb_consume tb cost = None"
  by (cases rule: ‹_›.cases; simp)

(* OMEGA_001_04_tb_refill_monotone (matches Coq) *)
lemma OMEGA_001_04_tb_refill_monotone: "\<forall> tb t1 t2, t1 \<le> t2 \<longrightarrow> tb_last_refill tb \<le> t1 \<longrightarrow> tb_tokens (tb_refill tb t1) \<le> tb_tokens (tb_refill tb t2)"
  by simp

(* OMEGA_001_05_tb_consume_preserves_capacity (matches Coq) *)
lemma OMEGA_001_05_tb_consume_preserves_capacity: "\<forall> tb cost tb', tb_consume tb cost = Some tb' \<longrightarrow> tb_capacity tb' = tb_capacity tb"
  by (cases rule: ‹_›.cases; simp)

(* OMEGA_001_06_tb_zero_cost_always_succeeds (matches Coq) *)
lemma OMEGA_001_06_tb_zero_cost_always_succeeds: "\<forall> tb, \<exists> tb', tb_consume tb 0 = Some tb'"
  by simp

(* OMEGA_001_07_tb_refill_preserves_capacity (matches Coq) *)
lemma OMEGA_001_07_tb_refill_preserves_capacity: "\<forall> tb now, tb_capacity (tb_refill tb now) = tb_capacity tb"
  by simp

(* OMEGA_001_08_tb_available_bound (matches Coq) *)
lemma OMEGA_001_08_tb_available_bound: "\<forall> tb, tb_available tb \<le> tb_capacity tb \<or> tb_available tb > tb_capacity tb"
  by simp

(* ===============================================================================
    PROOFS: CAPABILITY SECURITY (7 theorems)
    =============================================================================== *)
(* OMEGA_002_01_expired_cap_invalid (matches Coq) *)
lemma OMEGA_002_01_expired_cap_invalid: "\<forall> cap now, now \<ge> cap_expiry cap \<longrightarrow> cap_valid cap now = False"
  by auto

(* OMEGA_002_02_cap_subset_reflexive (matches Coq) *)
lemma OMEGA_002_02_cap_subset_reflexive: "\<forall> cap, cap_is_subset cap cap = True"
  by auto

(* OMEGA_002_03_delegation_attenuation (matches Coq) *)
lemma OMEGA_002_03_delegation_attenuation: "\<forall> parent perms expiry sig child, cap_delegate parent perms expiry sig = Some child \<longrightarrow> cap_expiry child \<le> cap_expiry parent"
  by auto

(* OMEGA_002_04_delegation_permission_subset (matches Coq) *)
lemma OMEGA_002_04_delegation_permission_subset: "\<forall> parent perms expiry sig child, cap_delegate parent perms expiry sig = Some child \<longrightarrow> cap_is_subset child parent = True"
  by auto

(* OMEGA_002_05_nondelegatable_blocks (matches Coq) *)
lemma OMEGA_002_05_nondelegatable_blocks: "\<forall> parent perms expiry sig, cap_delegatable parent = False \<longrightarrow> cap_delegate parent perms expiry sig = None"
  by simp

(* OMEGA_002_06_empty_cap_permits_nothing (matches Coq) *)
lemma OMEGA_002_06_empty_cap_permits_nothing: "\<forall> port, cap_permits {| cap_id := 0; cap_permissions := []; cap_expiry := 0; cap_delegatable := false; cap_signature := 0 |} port = False"
  by simp

(* OMEGA_002_07_cap_permits_sound (matches Coq) *)
lemma OMEGA_002_07_cap_permits_sound: "\<forall> cap port, cap_permits cap port = True \<longrightarrow> In port (cap_permissions cap) \<or> \<exists> p, In p (cap_permissions cap) \<and> Nat.eqb port p = True"
  by auto

(* ===============================================================================
    PROOFS: SYN COOKIE (6 theorems)
    =============================================================================== *)
(* OMEGA_003_01_syn_cookie_verify_sound (matches Coq) *)
lemma OMEGA_003_01_syn_cookie_verify_sound: "\<forall> secret cookie, syn_cookie_verify secret cookie (syn_cookie_generate secret cookie) = True"
  by auto

(* OMEGA_003_02_syn_cookie_wrong_secret (matches Coq) *)
lemma OMEGA_003_02_syn_cookie_wrong_secret: "\<forall> s1 s2 cookie, s1 \<noteq> s2 \<longrightarrow> (* Wrong secret produces different MAC *) syn_cookie_generate s1 cookie \<noteq> syn_cookie_generate s2 cookie"
  by simp

(* OMEGA_003_03_syn_cookie_deterministic (matches Coq) *)
lemma OMEGA_003_03_syn_cookie_deterministic: "\<forall> secret cookie, syn_cookie_generate secret cookie = syn_cookie_generate secret cookie"
  by simp

(* OMEGA_003_04_syn_cookie_stateless (matches Coq) *)
lemma OMEGA_003_04_syn_cookie_stateless: "\<forall> secret cookie mac, syn_cookie_verify secret cookie mac = True \<longrightarrow> mac = syn_cookie_generate secret cookie"
  by auto

(* OMEGA_003_05_syn_cookie_ip_sensitive (matches Coq) *)
lemma OMEGA_003_05_syn_cookie_ip_sensitive: "\<forall> secret c1 c2, sc_client_ip c1 \<noteq> sc_client_ip c2 \<longrightarrow> sc_client_port c1 = sc_client_port c2 \<longrightarrow> sc_server_port c1 = sc_server_port c2 \<longrightarrow> sc_timestamp c1 = sc_timestamp c2 \<longrightarrow> syn_cookie_generate secret c1 \<noteq> syn_cookie_generate secret c2"
  by simp

(* OMEGA_003_06_wrong_mac_rejected (matches Coq) *)
lemma OMEGA_003_06_wrong_mac_rejected: "\<forall> secret cookie mac, mac \<noteq> syn_cookie_generate secret cookie \<longrightarrow> syn_cookie_verify secret cookie mac = False"
  by auto

(* ===============================================================================
    PROOFS: CONNECTION LIMITING (5 theorems)
    =============================================================================== *)
(* OMEGA_004_01_empty_table_allows (matches Coq) *)
lemma OMEGA_004_01_empty_table_allows: "\<forall> src, conn_allowed [] src = True"
  by simp

(* OMEGA_004_02_conn_count_nonneg (matches Coq) *)
lemma OMEGA_004_02_conn_count_nonneg: "\<forall> table src, conn_count_by_src table src \<ge> 0"
  by simp

(* OMEGA_004_03_conn_count_bound (matches Coq) *)
lemma OMEGA_004_03_conn_count_bound: "\<forall> table src, conn_count_by_src table src \<le> length table"
  by auto

(* OMEGA_004_04_conn_lookup_deterministic (matches Coq) *)
lemma OMEGA_004_04_conn_lookup_deterministic: "\<forall> table src dst c1 c2, conn_lookup table src dst = Some c1 \<longrightarrow> conn_lookup table src dst = Some c2 \<longrightarrow> c1 = c2"
  by auto

(* OMEGA_004_05_pow_verify_sound (matches Coq) *)
lemma OMEGA_004_05_pow_verify_sound: "\<forall> nonce challenge difficulty, pow_valid nonce challenge difficulty = True \<longrightarrow> pow_verify nonce challenge difficulty = True"
  by auto

(* ===============================================================================
    PROOFS: PROOF-OF-WORK (4 theorems)
    =============================================================================== *)
(* OMEGA_005_01_pow_deterministic (matches Coq) *)
lemma OMEGA_005_01_pow_deterministic: "\<forall> n c d, pow_valid n c d = pow_valid n c d"
  by simp

(* OMEGA_005_02_pow_zero_difficulty_impossible (matches Coq) *)
lemma OMEGA_005_02_pow_zero_difficulty_impossible: "\<forall> n c, pow_valid n c 0 = False"
  by simp

(* OMEGA_005_03_pow_verify_complete (matches Coq) *)
lemma OMEGA_005_03_pow_verify_complete: "\<forall> n c d, pow_verify n c d = True \<longrightarrow> pow_valid n c d = True"
  by auto

(* OMEGA_005_04_pow_hash_deterministic (matches Coq) *)
lemma OMEGA_005_04_pow_hash_deterministic: "\<forall> n c, pow_hash n c = pow_hash n c"
  by simp

end
