(* Copyright (c) 2026 The RIINA Authors. All rights reserved. *)

(*
 * RIINA ControlFlowIntegrity - Isabelle/HOL Port
 *
 * Auto-generated port of 02_FORMAL/coq/domains/ControlFlowIntegrity.v (21 theorems).
 *
 * Generated by scripts/generate-multiprover.py
 *
 * Correspondence Table:
 *
 * | Coq Definition     | Isabelle Definition    | Status |
 * |--------------------|------------------------|--------|
 * | EdgeType           | edge_type              | OK     |
 * | MemPerm            | mem_perm               | OK     |
 * | RelocState         | reloc_state            | OK     |
 * | BasicBlock         | basic_block            | OK     |
 * | CFGEdge            | cfg_edge               | OK     |
 * | ShadowEntry        | shadow_entry           | OK     |
 * | FuncType           | func_type              | OK     |
 * | TypedFuncPtr       | typed_func_ptr         | OK     |
 * | VTable             | v_table                | OK     |
 * | TypedObject        | typed_object           | OK     |
 * | ExceptionHandler   | exception_handler      | OK     |
 * | JmpBuf             | jmp_buf                | OK     |
 * | ThreadContext      | thread_context         | OK     |
 * | edge_in_cfg        | edge_in_cfg            | OK     |
 * | shadow_push        | shadow_push            | OK     |
 * | valid_return       | valid_return           | OK     |
 * | valid_indirect_call | valid_indirect_call    | OK     |
 * | has_perm           | has_perm               | OK     |
 * | w_xor_x            | w_xor_x                | OK     |
 * | vtable_type_matches | vtable_type_matches    | OK     |
 * | handler_registered | handler_registered     | OK     |
 * | longjmp_safe       | longjmp_safe           | OK     |
 * | got_writable       | got_writable           | OK     |
 * | got_protected      | got_protected          | OK     |
 * | thread_accessible  | thread_accessible      | OK     |
 * | ctl_001_rop_impossible | ctl_001_rop_impossible | OK     |
 * | ctl_002_jop_impossible | ctl_002_jop_impossible | OK     |
 * | ctl_003_cop_impossible | ctl_003_cop_impossible | OK     |
 * | ctl_004_ret2libc_impossible | ctl_004_ret2libc_impossible | OK     |
 * | ctl_005_srop_impossible | ctl_005_srop_impossible | OK     |
 * | ctl_006_code_injection_impossible | ctl_006_code_injection_impossible | OK     |
 * | ctl_007_code_reuse_controlled | ctl_007_code_reuse_controlled | OK     |
 * | ctl_008_data_only_mitigated | ctl_008_data_only_mitigated | OK     |
 * | ctl_009_cf_bending_impossible | ctl_009_cf_bending_impossible | OK     |
 * | ctl_010_indirect_call_safe | ctl_010_indirect_call_safe | OK     |
 * | ctl_011_vtable_hijack_impossible | ctl_011_vtable_hijack_impossible | OK     |
 * | ctl_012_exception_safe | ctl_012_exception_safe | OK     |
 * | ctl_013_longjmp_safe | ctl_013_longjmp_safe   | OK     |
 * | ctl_014_got_plt_protected | ctl_014_got_plt_protected | OK     |
 * | ctl_015_thread_hijack_impossible | ctl_015_thread_hijack_impossible | OK     |
 * | ctl_016_shadow_push_pop_identity | ctl_016_shadow_push_pop_identity | OK     |
 * | ctl_017_valid_return_after_push | ctl_017_valid_return_after_push | OK     |
 * | ctl_018_wxor_x_empty | ctl_018_wxor_x_empty   | OK     |
 * | ctl_019_reloc_state_decidable | ctl_019_reloc_state_decidable | OK     |
 * | ctl_020_shadow_push_length | ctl_020_shadow_push_length | OK     |
 * | ctl_021_valid_trace_prefix | ctl_021_valid_trace_prefix | OK     |
 *)

theory ControlFlowIntegrity
  imports Main
begin

(* EdgeType (matches Coq: Inductive EdgeType) *)
datatype edge_type =
    DirectJump  (* Direct jump to known target *)
  |     ConditionalJump  (* Conditional branch *)
  |     DirectCall  (* Direct function call *)
  |     Return  (* Return to caller *)
  |     FallThrough

(* MemPerm (matches Coq: Inductive MemPerm) *)
datatype mem_perm =
    Readable
  |     Writable
  |     Executable

(* RelocState (matches Coq: Inductive RelocState) *)
datatype reloc_state =
    PreReloc  (* Can be written during loading *)
  |     PostReloc

(* BasicBlock (matches Coq: Record BasicBlock) *)
record basic_block =
  bb_id :: nat
  bb_start :: InstrAddr
  bb_end :: InstrAddr
  bb_func :: FuncId

(* CFGEdge (matches Coq: Record CFGEdge) *)
record cfg_edge =
  edge_src :: BasicBlock
  edge_dst :: BasicBlock
  edge_type :: EdgeType

(* ShadowEntry (matches Coq: Record ShadowEntry) *)
record shadow_entry =
  se_return_addr :: InstrAddr
  se_caller_func :: FuncId

(* FuncType (matches Coq: Record FuncType) *)
record func_type =
  ft_arg_types :: 'a list
  Simplified :: just
  ft_ret_type :: nat

(* TypedFuncPtr (matches Coq: Record TypedFuncPtr) *)
record typed_func_ptr =
  tfp_addr :: InstrAddr
  tfp_type :: FuncType

(* VTable (matches Coq: Record VTable) *)
record v_table =
  vt_type_id :: nat
  vt_methods :: 'a list

(* TypedObject (matches Coq: Record TypedObject) *)
record typed_object =
  to_vtable :: VTable
  to_expected_type :: nat

(* ExceptionHandler (matches Coq: Record ExceptionHandler) *)
record exception_handler =
  eh_type :: nat  (* Exception type handled *)
  eh_addr :: InstrAddr  (* Handler address *)

(* JmpBuf (matches Coq: Record JmpBuf) *)
record jmp_buf =
  jb_valid :: bool
  jb_target :: InstrAddr
  jb_stack_ptr :: nat

(* ThreadContext (matches Coq: Record ThreadContext) *)
record thread_context =
  tc_id :: nat
  tc_owner :: nat  (* Owning process/capability *)
  tc_valid :: bool

(* edge_in_cfg (matches Coq: Definition edge_in_cfg) *)
definition edge_in_cfg :: "CFGEdge \<Rightarrow> ValidCFG \<Rightarrow> bool" where
  "edge_in_cfg e cfg \<equiv> In e cfg"

(* shadow_push (matches Coq: Definition shadow_push) *)
definition shadow_push :: "ShadowStack \<Rightarrow> InstrAddr \<Rightarrow> FuncId \<Rightarrow> ShadowStack" where
  "shadow_push ss ret caller \<equiv> mkShadowEntry ret caller :: ss"

(* valid_return (matches Coq: Definition valid_return) *)
fun valid_return :: "ShadowStack \<Rightarrow> InstrAddr \<Rightarrow> bool" where
  "valid_return nil = False"

(* valid_indirect_call (matches Coq: Definition valid_indirect_call) *)
definition valid_indirect_call :: "ValidTargets \<Rightarrow> TypedFuncPtr \<Rightarrow> bool" where
  "valid_indirect_call vt fp \<equiv> In (tfp_addr fp) (vt (tfp_type fp))"

(* has_perm (matches Coq: Definition has_perm) *)
definition has_perm :: "MemPerm \<Rightarrow> bool" where
  "has_perm p \<equiv> In p perms"

(* w_xor_x (matches Coq: Definition w_xor_x) *)
definition w_xor_x :: "bool" where
  "w_xor_x \<equiv> ~ (has_perm perms Writable /\ has_perm perms Executable)"

(* vtable_type_matches (matches Coq: Definition vtable_type_matches) *)
definition vtable_type_matches :: "TypedObject \<Rightarrow> bool" where
  "vtable_type_matches obj \<equiv> vt_type_id (to_vtable obj) = to_expected_type obj"

(* handler_registered (matches Coq: Definition handler_registered) *)
definition handler_registered :: "ValidHandlers \<Rightarrow> ExceptionHandler \<Rightarrow> bool" where
  "handler_registered vhs h \<equiv> In h vhs"

(* longjmp_safe (matches Coq: Definition longjmp_safe) *)
definition longjmp_safe :: "JmpBuf \<Rightarrow> bool" where
  "longjmp_safe jb \<equiv> jb_valid jb = true"

(* got_writable (matches Coq: Definition got_writable) *)
definition got_writable :: "RelocState \<Rightarrow> bool" where
  "got_writable rs \<equiv> rs = PreReloc"

(* got_protected (matches Coq: Definition got_protected) *)
definition got_protected :: "RelocState \<Rightarrow> bool" where
  "got_protected rs \<equiv> rs = PostReloc"

(* thread_accessible (matches Coq: Definition thread_accessible) *)
definition thread_accessible :: "ThreadContext \<Rightarrow> nat \<Rightarrow> bool" where
  "thread_accessible tc accessor \<equiv> tc_owner tc = accessor /\ tc_valid tc = true"

(* ctl_001_rop_impossible (matches Coq) *)
lemma ctl_001_rop_impossible: "\<forall> (ss : ShadowStack) (attacker_addr : InstrAddr), (* Attacker cannot return to address not on shadow stack *) valid_return ss attacker_addr \<longrightarrow> \<exists> e, In e ss \<and> se_return_addr e = attacker_addr"
  by (cases rule: ‹_›.cases; simp)

(* ctl_002_jop_impossible (matches Coq) *)
lemma ctl_002_jop_impossible: "\<forall> (cfg : ValidCFG) (trace : Trace), valid_trace cfg trace \<longrightarrow> \<forall> b1 b2, In b1 trace \<longrightarrow> In b2 trace \<longrightarrow> (* If b1 transitions to b2, must be in CFG *) (\<exists> rest, trace = b1 :: b2 :: rest) \<longrightarrow> \<exists> e, edge_in_cfg e cfg \<and> edge_src e = b1 \<and> edge_dst e = b2"
  by auto

(* ctl_003_cop_impossible (matches Coq) *)
lemma ctl_003_cop_impossible: "\<forall> (vt : ValidTargets) (fp : TypedFuncPtr), valid_indirect_call vt fp \<longrightarrow> In (tfp_addr fp) (vt (tfp_type fp))"
  by auto

(* ctl_004_ret2libc_impossible (matches Coq) *)
lemma ctl_004_ret2libc_impossible: "\<forall> (ss : ShadowStack) (libc_addr : InstrAddr), valid_return ss libc_addr \<longrightarrow> (* Return must go to legitimate return site *) match ss with | nil => False | e :: _ => se_return_addr e = libc_addr end"
  by auto

(* ctl_005_srop_impossible (matches Coq) *)
lemma ctl_005_srop_impossible: "\<forall> (ss : ShadowStack) (sig_frame_addr : InstrAddr), (* Signal returns also validated against shadow stack *) valid_return ss sig_frame_addr \<longrightarrow> \<exists> e, In e ss \<and> se_return_addr e = sig_frame_addr"
  by (cases rule: ‹_›.cases; simp)

(* ctl_006_code_injection_impossible (matches Coq) *)
lemma ctl_006_code_injection_impossible: "\<forall> (perms : list MemPerm), w_xor_x perms \<longrightarrow> ~ (has_perm perms Writable \<and> has_perm perms Executable)"
  by auto

(* ctl_007_code_reuse_controlled (matches Coq) *)
lemma ctl_007_code_reuse_controlled: "\<forall> (cfg : ValidCFG) (trace : Trace), valid_trace cfg trace \<longrightarrow> \<forall> b1 b2 rest, trace = b1 :: b2 :: rest \<longrightarrow> \<exists> e, edge_in_cfg e cfg \<and> edge_src e = b1 \<and> edge_dst e = b2"
  by auto

(* ctl_008_data_only_mitigated (matches Coq) *)
lemma ctl_008_data_only_mitigated: "\<forall> (cfg : ValidCFG) (trace : Trace), valid_trace cfg trace \<longrightarrow> (* Even with corrupted data, control flow follows CFG *) \<forall> b1 b2, In b1 trace \<longrightarrow> (\<exists> rest, trace = b1 :: b2 :: rest) \<longrightarrow> \<exists> e, edge_in_cfg e cfg \<and> edge_src e = b1 \<and> edge_dst e = b2"
  by auto

(* ctl_009_cf_bending_impossible (matches Coq) *)
lemma ctl_009_cf_bending_impossible: "\<forall> (cfg : ValidCFG) (trace : Trace), valid_trace cfg trace \<longrightarrow> (* Every transition in trace is in CFG *) \<forall> b1 b2 rest, trace = b1 :: b2 :: rest \<longrightarrow> \<exists> e, edge_in_cfg e cfg"
  by auto

(* ctl_010_indirect_call_safe (matches Coq) *)
lemma ctl_010_indirect_call_safe: "\<forall> (vt : ValidTargets) (fp : TypedFuncPtr), valid_indirect_call vt fp \<longrightarrow> (* Target must be in valid set for that type *) In (tfp_addr fp) (vt (tfp_type fp))"
  by auto

(* ctl_011_vtable_hijack_impossible (matches Coq) *)
lemma ctl_011_vtable_hijack_impossible: "\<forall> (obj : TypedObject), vtable_type_matches obj \<longrightarrow> vt_type_id (to_vtable obj) = to_expected_type obj"
  by auto

(* ctl_012_exception_safe (matches Coq) *)
lemma ctl_012_exception_safe: "\<forall> (vhs : ValidHandlers) (h : ExceptionHandler), handler_registered vhs h \<longrightarrow> In h vhs"
  by auto

(* ctl_013_longjmp_safe (matches Coq) *)
lemma ctl_013_longjmp_safe: "\<forall> (jb : JmpBuf), longjmp_safe jb \<longrightarrow> jb_valid jb = True"
  by auto

(* ctl_014_got_plt_protected (matches Coq) *)
lemma ctl_014_got_plt_protected: "\<forall> (rs : RelocState), got_protected rs \<longrightarrow> ~ got_writable rs"
  by auto

(* ctl_015_thread_hijack_impossible (matches Coq) *)
lemma ctl_015_thread_hijack_impossible: "\<forall> (tc : ThreadContext) (attacker : nat), tc_owner tc \<noteq> attacker \<longrightarrow> ~ thread_accessible tc attacker"
  by auto

(* ctl_016_shadow_push_pop_identity (matches Coq) *)
lemma ctl_016_shadow_push_pop_identity: "\<forall> (ss : ShadowStack) (ret : InstrAddr) (caller : FuncId), shadow_pop (shadow_push ss ret caller) = Some (mkShadowEntry ret caller, ss)"
  by simp

(* ctl_017_valid_return_after_push (matches Coq) *)
lemma ctl_017_valid_return_after_push: "\<forall> (ss : ShadowStack) (ret : InstrAddr) (caller : FuncId), valid_return (shadow_push ss ret caller) ret"
  by simp

(* ctl_018_wxor_x_empty (matches Coq) *)
lemma ctl_018_wxor_x_empty: "w_xor_x nil"
  by auto

(* ctl_019_reloc_state_decidable (matches Coq) *)
lemma ctl_019_reloc_state_decidable: "\<forall> (rs : RelocState), got_writable rs \<or> got_protected rs"
  by simp

(* ctl_020_shadow_push_length (matches Coq) *)
lemma ctl_020_shadow_push_length: "\<forall> (ss : ShadowStack) (ret : InstrAddr) (caller : FuncId), length (shadow_push ss ret caller) = S (length ss)"
  by simp

(* ctl_021_valid_trace_prefix (matches Coq) *)
lemma ctl_021_valid_trace_prefix: "\<forall> (cfg : ValidCFG) (b : BasicBlock) (rest : Trace), valid_trace cfg (b :: rest) \<longrightarrow> valid_trace cfg rest"
  by auto

end
