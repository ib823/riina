(* Copyright (c) 2026 The RIINA Authors. All rights reserved. *)

(*
 * RIINA InterruptVirtualization - Isabelle/HOL Port
 *
 * Auto-generated port of 02_FORMAL/coq/domains/security_foundation/InterruptVirtualization.v (21 theorems).
 *
 * Generated by scripts/generate-multiprover.py
 *
 * Correspondence Table:
 *
 * | Coq Definition     | Isabelle Definition    | Status |
 * |--------------------|------------------------|--------|
 * | VMId               | vm_id                  | OK     |
 * | Interrupt          | interrupt              | OK     |
 * | InterruptSource    | interrupt_source       | OK     |
 * | VirtualMachine     | virtual_machine        | OK     |
 * | InterruptState     | interrupt_state        | OK     |
 * | InterruptPriority  | interrupt_priority     | OK     |
 * | InterruptController | interrupt_controller   | OK     |
 * | vm_owns_irq        | vm_owns_irq            | OK     |
 * | ipi_authorized     | ipi_authorized         | OK     |
 * | authorized_injection | authorized_injection   | OK     |
 * | can_inject         | can_inject             | OK     |
 * | irq_deliverable    | irq_deliverable        | OK     |
 * | interrupt_injection_authorized | interrupt_injection_authorized | OK     |
 * | interrupt_isolation | interrupt_isolation    | OK     |
 * | device_irq_unique_owner | device_irq_unique_owner | OK     |
 * | timer_interrupt_local | timer_interrupt_local  | OK     |
 * | ipi_requires_authorization | ipi_requires_authorization | OK     |
 * | unauthorized_ipi_blocked | unauthorized_ipi_blocked | OK     |
 * | self_injection_allowed | self_injection_allowed | OK     |
 * | masked_irq_not_deliverable | masked_irq_not_deliverable | OK     |
 * | disabled_irq_not_deliverable | disabled_irq_not_deliverable | OK     |
 * | non_pending_irq_not_deliverable | non_pending_irq_not_deliverable | OK     |
 * | unknown_irq_not_deliverable | unknown_irq_not_deliverable | OK     |
 * | no_auth_no_injection | no_auth_no_injection   | OK     |
 * | device_irq_requires_ownership | device_irq_requires_ownership | OK     |
 * | cross_vm_requires_ipi | cross_vm_requires_ipi  | OK     |
 * | ipi_authorization_directional | ipi_authorization_directional | OK     |
 * | empty_ipi_blocks_cross_vm | empty_ipi_blocks_cross_vm | OK     |
 * | empty_assignments_blocks_device_irqs | empty_assignments_blocks_device_irqs | OK     |
 * | irq_assignment_deterministic | irq_assignment_deterministic | OK     |
 * | timer_injection_always_succeeds | timer_injection_always_succeeds | OK     |
 * | self_ipi_possible  | self_ipi_possible      | OK     |
 * | injection_source_valid | injection_source_valid | OK     |
 *)

theory InterruptVirtualization
  imports Main
begin

(* VMId (matches Coq: Inductive VMId) *)
datatype vm_id =
    VM

(* Interrupt (matches Coq: Inductive Interrupt) *)
datatype interrupt =
    IRQ

(* InterruptSource (matches Coq: Inductive InterruptSource) *)
datatype interrupt_source =
    DeviceSource
  |     TimerSource
  |     IPISource

(* VirtualMachine (matches Coq: Record VirtualMachine) *)
record virtual_machine =
  vm_id :: VMId
  vm_assigned_irqs :: 'a list

(* InterruptState (matches Coq: Record InterruptState) *)
record interrupt_state =
  irq_assignments :: 'a list
  ipi_allowed :: 'a list

(* InterruptPriority (matches Coq: Record InterruptPriority) *)
record interrupt_priority =
  irq_number :: nat
  irq_priority :: nat
  irq_enabled :: bool
  irq_pending :: bool

(* InterruptController (matches Coq: Record InterruptController) *)
record interrupt_controller =
  ctrl_irqs :: 'a list
  ctrl_mask_threshold :: nat  (* IRQs below this priority are masked *)

(* vm_owns_irq (matches Coq: Definition vm_owns_irq) *)
definition vm_owns_irq :: "InterruptState \<Rightarrow> VirtualMachine \<Rightarrow> nat \<Rightarrow> bool" where
  "vm_owns_irq st vm irq \<equiv> In (irq, vm_id vm) (irq_assignments st)"

(* ipi_authorized (matches Coq: Definition ipi_authorized) *)
definition ipi_authorized :: "InterruptState \<Rightarrow> bool" where
  "ipi_authorized st \<equiv> In (source, target) (ipi_allowed st)"

(* authorized_injection (matches Coq: Definition authorized_injection) *)
fun authorized_injection :: "InterruptState \<Rightarrow> InterruptSource \<Rightarrow> VirtualMachine \<Rightarrow> bool" where
  "authorized_injection TimerSource = True"

(* can_inject (matches Coq: Definition can_inject) *)
definition can_inject :: "InterruptState \<Rightarrow> VirtualMachine \<Rightarrow> Interrupt \<Rightarrow> VirtualMachine \<Rightarrow> bool" where
  "can_inject st vm1 irq vm2 \<equiv> vm_id vm1 = vm_id vm2 \/  (* VM can inject to itself *)
  ipi_authorized st (vm_id vm1) (vm_id vm2)"

(* irq_deliverable (matches Coq: Definition irq_deliverable) *)
definition irq_deliverable :: "InterruptController \<Rightarrow> nat \<Rightarrow> bool" where
  "irq_deliverable ctrl irq \<equiv> exists ip, find_irq_prio irq (ctrl_irqs ctrl) = Some ip /\
    irq_enabled ip = true /\
    irq_pending ip = true /\
    irq_priority ip >= ctrl_mask_threshold ctrl"

(* Theorem: Any interrupt injection must be authorized by the hypervisor. *)
(* interrupt_injection_authorized (matches Coq) *)
lemma interrupt_injection_authorized: "\<forall> (st : InterruptState) (source : InterruptSource) (target : VirtualMachine), injects_interrupt st source target \<longrightarrow> authorized_injection st source target"
  by auto

(* Theorem: One VM cannot inject interrupts to another VM without explicit authorization. *)
(* interrupt_isolation (matches Coq) *)
lemma interrupt_isolation: "\<forall> (vm1 vm2 : VirtualMachine) (irq : Interrupt) (st : InterruptState), vm_id vm1 \<noteq> vm_id vm2 \<longrightarrow> ~ ipi_authorized st (vm_id vm1) (vm_id vm2) \<longrightarrow> ~ can_inject st vm1 irq vm2"
  by auto

(* IRQ ownership is unique when assignment exists *)
(* device_irq_unique_owner (matches Coq) *)
lemma device_irq_unique_owner: "\<forall> (st : InterruptState) (vm1 vm2 : VirtualMachine) (irq : nat), find_vm_for_irq (irq_assignments st) irq = Some (vm_id vm1) \<longrightarrow> find_vm_for_irq (irq_assignments st) irq = Some (vm_id vm2) \<longrightarrow> vm_id vm1 = vm_id vm2"
  by auto

(* Timer interrupts are always local *)
(* timer_interrupt_local (matches Coq) *)
lemma timer_interrupt_local: "\<forall> (st : InterruptState) (vm : VirtualMachine), authorized_injection st TimerSource vm"
  by auto

(* IPI requires explicit authorization *)
(* ipi_requires_authorization (matches Coq) *)
lemma ipi_requires_authorization: "\<forall> (st : InterruptState) (src tgt : VirtualMachine), authorized_injection st (IPISource (vm_id src)) tgt \<longrightarrow> ipi_authorized st (vm_id src) (vm_id tgt)"
  by auto

(* Unauthorized IPI blocked *)
(* unauthorized_ipi_blocked (matches Coq) *)
lemma unauthorized_ipi_blocked: "\<forall> (st : InterruptState) (src_vm tgt_vm : VirtualMachine), ~ ipi_authorized st (vm_id src_vm) (vm_id tgt_vm) \<longrightarrow> ~ injects_interrupt st (IPISource (vm_id src_vm)) tgt_vm"
  by auto

(* Self-injection always allowed *)
(* self_injection_allowed (matches Coq) *)
lemma self_injection_allowed: "\<forall> (st : InterruptState) (vm : VirtualMachine) (irq : Interrupt), can_inject st vm irq vm"
  by simp

(* Masked IRQ cannot fire *)
(* masked_irq_not_deliverable (matches Coq) *)
lemma masked_irq_not_deliverable: "\<forall> (ctrl : InterruptController) (irq : nat) (ip : InterruptPriority), find_irq_prio irq (ctrl_irqs ctrl) = Some ip \<longrightarrow> irq_priority ip < ctrl_mask_threshold ctrl \<longrightarrow> ~ irq_deliverable ctrl irq"
  by (cases rule: ‹_›.cases; simp)

(* Disabled IRQ cannot fire *)
(* disabled_irq_not_deliverable (matches Coq) *)
lemma disabled_irq_not_deliverable: "\<forall> (ctrl : InterruptController) (irq : nat) (ip : InterruptPriority), find_irq_prio irq (ctrl_irqs ctrl) = Some ip \<longrightarrow> irq_enabled ip = False \<longrightarrow> ~ irq_deliverable ctrl irq"
  by auto

(* Non-pending IRQ cannot fire *)
(* non_pending_irq_not_deliverable (matches Coq) *)
lemma non_pending_irq_not_deliverable: "\<forall> (ctrl : InterruptController) (irq : nat) (ip : InterruptPriority), find_irq_prio irq (ctrl_irqs ctrl) = Some ip \<longrightarrow> irq_pending ip = False \<longrightarrow> ~ irq_deliverable ctrl irq"
  by auto

(* Unknown IRQ cannot fire *)
(* unknown_irq_not_deliverable (matches Coq) *)
lemma unknown_irq_not_deliverable: "\<forall> (ctrl : InterruptController) (irq : nat), find_irq_prio irq (ctrl_irqs ctrl) = None \<longrightarrow> ~ irq_deliverable ctrl irq"
  by auto

(* Injection requires authorization — contrapositive *)
(* no_auth_no_injection (matches Coq) *)
lemma no_auth_no_injection: "\<forall> (st : InterruptState) (source : InterruptSource) (target : VirtualMachine), ~ authorized_injection st source target \<longrightarrow> ~ injects_interrupt st source target"
  by auto

(* Device IRQ injection requires ownership *)
(* device_irq_requires_ownership (matches Coq) *)
lemma device_irq_requires_ownership: "\<forall> (st : InterruptState) (irq : nat) (target : VirtualMachine), injects_interrupt st (DeviceSource irq) target \<longrightarrow> vm_owns_irq st target irq"
  by auto

(* VM cannot inject to different VM without IPI *)
(* cross_vm_requires_ipi (matches Coq) *)
lemma cross_vm_requires_ipi: "\<forall> (vm1 vm2 : VirtualMachine) (irq : Interrupt) (st : InterruptState), vm_id vm1 \<noteq> vm_id vm2 \<longrightarrow> can_inject st vm1 irq vm2 \<longrightarrow> ipi_authorized st (vm_id vm1) (vm_id vm2)"
  by auto

(* IPI authorization is directional *)
(* ipi_authorization_directional (matches Coq) *)
lemma ipi_authorization_directional: "\<forall> (st : InterruptState) (vm1 vm2 : VirtualMachine), ipi_authorized st (vm_id vm1) (vm_id vm2) \<longrightarrow> ~ ipi_authorized st (vm_id vm2) (vm_id vm1) \<longrightarrow> ~ can_inject st vm2 (IRQ 0) vm1 \<or> vm_id vm1 = vm_id vm2"
  by auto

(* Empty IPI list blocks all cross-VM injection *)
(* empty_ipi_blocks_cross_vm (matches Coq) *)
lemma empty_ipi_blocks_cross_vm: "\<forall> (st : InterruptState) (vm1 vm2 : VirtualMachine) (irq : Interrupt), ipi_allowed st = [] \<longrightarrow> vm_id vm1 \<noteq> vm_id vm2 \<longrightarrow> ~ can_inject st vm1 irq vm2"
  by auto

(* Empty assignment list blocks all device IRQ injection *)
(* empty_assignments_blocks_device_irqs (matches Coq) *)
lemma empty_assignments_blocks_device_irqs: "\<forall> (st : InterruptState) (irq : nat) (vm : VirtualMachine), irq_assignments st = [] \<longrightarrow> ~ injects_interrupt st (DeviceSource irq) vm"
  by auto

(* IRQ assignment deterministic *)
(* irq_assignment_deterministic (matches Coq) *)
lemma irq_assignment_deterministic: "\<forall> (st : InterruptState) (irq : nat) (vm1 vm2 : VMId), find_vm_for_irq (irq_assignments st) irq = Some vm1 \<longrightarrow> find_vm_for_irq (irq_assignments st) irq = Some vm2 \<longrightarrow> vm1 = vm2"
  by auto

(* Timer injection always succeeds *)
(* timer_injection_always_succeeds (matches Coq) *)
lemma timer_injection_always_succeeds: "\<forall> (st : InterruptState) (vm : VirtualMachine), injects_interrupt st TimerSource vm"
  by auto

(* Self injection via IPI is possible if authorized *)
(* self_ipi_possible (matches Coq) *)
lemma self_ipi_possible: "\<forall> (st : InterruptState) (vm : VirtualMachine), ipi_authorized st (vm_id vm) (vm_id vm) \<longrightarrow> injects_interrupt st (IPISource (vm_id vm)) vm"
  by auto

(* Injection implies source is valid *)
(* injection_source_valid (matches Coq) *)
lemma injection_source_valid: "\<forall> (st : InterruptState) (src : InterruptSource) (tgt : VirtualMachine), injects_interrupt st src tgt \<longrightarrow> match src with | DeviceSource irq => vm_owns_irq st tgt irq | TimerSource => True | IPISource vm => ipi_authorized st vm (vm_id tgt) end"
  by auto

end
