(* SPDX-License-Identifier: MPL-2.0 *)
(* Copyright (c) 2026 The RIINA Authors. See AUTHORS file. *)

(*
 * RIINA DisplayDriver - Isabelle/HOL Port
 *
 * Auto-generated port of 02_FORMAL/coq/domains/security_foundation/DisplayDriver.v (23 theorems).
 *
 * Generated by scripts/generate-multiprover.py
 *
 * Correspondence Table:
 *
 * | Coq Definition     | Isabelle Definition    | Status |
 * |--------------------|------------------------|--------|
 * | AppId              | app_id                 | OK     |
 * | FrameBufferId      | frame_buffer_id        | OK     |
 * | Application        | application            | OK     |
 * | FrameBuffer        | frame_buffer           | OK     |
 * | Frame              | frame                  | OK     |
 * | DisplayState       | display_state          | OK     |
 * | owns_buffer        | owns_buffer            | OK     |
 * | has_screen_capture_permission | has_screen_capture_permission | OK     |
 * | has_overlay_permission | has_overlay_permission | OK     |
 * | valid_framebuffer  | valid_framebuffer      | OK     |
 * | pixel_count        | pixel_count            | OK     |
 * | display_buffer_isolated | display_buffer_isolated | OK     |
 * | screen_capture_requires_permission | screen_capture_requires_permission | OK     |
 * | protected_buffer_access | protected_buffer_access | OK     |
 * | no_permission_no_capture | no_permission_no_capture | OK     |
 * | buffer_ownership_exclusive | buffer_ownership_exclusive | OK     |
 * | overlay_requires_permission | overlay_requires_permission | OK     |
 * | no_overlay_without_permission | no_overlay_without_permission | OK     |
 * | display_output_integrity | display_output_integrity | OK     |
 * | valid_fb_positive_pixels | valid_fb_positive_pixels | OK     |
 * | no_capture_perm_blocks_all_frames | no_capture_perm_blocks_all_frames | OK     |
 * | protected_buffer_blocks_non_owner | protected_buffer_blocks_non_owner | OK     |
 * | read_requires_ownership_or_capture | read_requires_ownership_or_capture | OK     |
 * | capture_perm_reads_all | capture_perm_reads_all | OK     |
 * | owner_reads_unprotected | owner_reads_unprotected | OK     |
 * | overlay_state_consistent | overlay_state_consistent | OK     |
 * | no_overlay_no_app  | no_overlay_no_app      | OK     |
 * | fb_id_determines_buffer | fb_id_determines_buffer | OK     |
 * | display_isolation_symmetric | display_isolation_symmetric | OK     |
 * | capture_overlay_independent | capture_overlay_independent | OK     |
 * | dual_perm_app      | dual_perm_app          | OK     |
 * | no_perm_app        | no_perm_app            | OK     |
 * | empty_display_no_read | empty_display_no_read  | OK     |
 * | frame_timestamp_order | frame_timestamp_order  | OK     |
 *)

theory DisplayDriver
  imports Main
begin

(* AppId (matches Coq: Inductive AppId) *)
datatype app_id =
    App

(* FrameBufferId (matches Coq: Inductive FrameBufferId) *)
datatype frame_buffer_id =
    FBId

(* Application (matches Coq: Record Application) *)
record application =
  app_id :: AppId
  app_screen_capture_perm :: bool
  app_overlay_perm :: bool

(* FrameBuffer (matches Coq: Record FrameBuffer) *)
record frame_buffer =
  fb_id :: FrameBufferId
  fb_owner :: AppId
  fb_width :: nat
  fb_height :: nat
  fb_protected :: bool

(* Frame (matches Coq: Record Frame) *)
record frame =
  frame_id :: nat
  frame_timestamp :: nat
  frame_source :: FrameBufferId

(* DisplayState (matches Coq: Record DisplayState) *)
record display_state =
  frame_buffers :: 'a list
  active_overlay :: option

(* owns_buffer (matches Coq: Definition owns_buffer) *)
definition owns_buffer :: "Application \<Rightarrow> FrameBuffer \<Rightarrow> bool" where
  "owns_buffer app fb \<equiv> fb_owner fb = app_id app"

(* has_screen_capture_permission (matches Coq: Definition has_screen_capture_permission) *)
definition has_screen_capture_permission :: "Application \<Rightarrow> bool" where
  "has_screen_capture_permission app \<equiv> app_screen_capture_perm app = true"

(* has_overlay_permission (matches Coq: Definition has_overlay_permission) *)
definition has_overlay_permission :: "Application \<Rightarrow> bool" where
  "has_overlay_permission app \<equiv> app_overlay_perm app = true"

(* valid_framebuffer (matches Coq: Definition valid_framebuffer) *)
definition valid_framebuffer :: "FrameBuffer \<Rightarrow> bool" where
  "valid_framebuffer fb \<equiv> fb_width fb > 0 /\ fb_height fb > 0"

(* pixel_count (matches Coq: Definition pixel_count) *)
definition pixel_count :: "FrameBuffer \<Rightarrow> nat" where
  "pixel_count fb \<equiv> fb_width fb * fb_height fb"

(* Theorem: An application cannot read another application's frame buffer
    without explicit permission. *)
(* display_buffer_isolated (matches Coq) *)
lemma display_buffer_isolated: "\<forall> (app1 app2 : Application) (buffer : FrameBuffer), app_id app1 \<noteq> app_id app2 \<longrightarrow> owns_buffer app1 buffer \<longrightarrow> app_screen_capture_perm app2 = False \<longrightarrow> ~ can_read_buffer app2 buffer"
  by auto

(* Theorem: Screen capture requires explicit permission. *)
(* screen_capture_requires_permission (matches Coq) *)
lemma screen_capture_requires_permission: "\<forall> (app : Application) (frame : Frame), captures_screen app frame \<longrightarrow> has_screen_capture_permission app"
  by auto

(* Protected buffers require special permission *)
(* protected_buffer_access (matches Coq) *)
lemma protected_buffer_access: "\<forall> (app : Application) (fb : FrameBuffer), fb_protected fb = True \<longrightarrow> owns_buffer app fb \<longrightarrow> ~ can_read_buffer app fb \<or> app_screen_capture_perm app = True"
  by simp

(* No permission implies no capture *)
(* no_permission_no_capture (matches Coq) *)
lemma no_permission_no_capture: "\<forall> (app : Application), app_screen_capture_perm app = False \<longrightarrow> \<forall> frame, ~ captures_screen app frame"
  by auto

(* Buffer ownership is exclusive *)
(* buffer_ownership_exclusive (matches Coq) *)
lemma buffer_ownership_exclusive: "\<forall> (app1 app2 : Application) (fb : FrameBuffer), owns_buffer app1 fb \<longrightarrow> owns_buffer app2 fb \<longrightarrow> app_id app1 = app_id app2"
  by auto

(* Overlay requires permission *)
(* overlay_requires_permission (matches Coq) *)
lemma overlay_requires_permission: "\<forall> (app : Application), creates_overlay app \<longrightarrow> has_overlay_permission app"
  by auto

(* No overlay without permission *)
(* no_overlay_without_permission (matches Coq) *)
lemma no_overlay_without_permission: "\<forall> (app : Application), app_overlay_perm app = False \<longrightarrow> ~ creates_overlay app"
  by auto

(* Display output integrity: frame is from a valid buffer *)
(* display_output_integrity (matches Coq) *)
lemma display_output_integrity: "\<forall> (app : Application) (fb : FrameBuffer) (frame : Frame), owns_buffer app fb \<longrightarrow> frame_source frame = fb_id fb \<longrightarrow> fb_owner fb = app_id app"
  by auto

(* Valid framebuffer has positive pixel count *)
(* valid_fb_positive_pixels (matches Coq) *)
lemma valid_fb_positive_pixels: "\<forall> (fb : FrameBuffer), valid_framebuffer fb \<longrightarrow> pixel_count fb > 0"
  by (cases rule: ‹_›.cases; simp)

(* Screen capture with no permission fails for all frames *)
(* no_capture_perm_blocks_all_frames (matches Coq) *)
lemma no_capture_perm_blocks_all_frames: "\<forall> (app : Application), app_screen_capture_perm app = False \<longrightarrow> \<forall> f, ~ captures_screen app f"
  by auto

(* Protected buffer blocks non-owner without capture perm *)
(* protected_buffer_blocks_non_owner (matches Coq) *)
lemma protected_buffer_blocks_non_owner: "\<forall> (app : Application) (fb : FrameBuffer), fb_protected fb = True \<longrightarrow> fb_owner fb \<noteq> app_id app \<longrightarrow> app_screen_capture_perm app = False \<longrightarrow> ~ can_read_buffer app fb"
  by auto

(* Buffer read requires either ownership or capture permission *)
(* read_requires_ownership_or_capture (matches Coq) *)
lemma read_requires_ownership_or_capture: "\<forall> (app : Application) (fb : FrameBuffer), can_read_buffer app fb \<longrightarrow> (owns_buffer app fb \<and> fb_protected fb = False) \<or> app_screen_capture_perm app = True"
  by auto

(* Capture permission implies can read any buffer *)
(* capture_perm_reads_all (matches Coq) *)
lemma capture_perm_reads_all: "\<forall> (app : Application) (fb : FrameBuffer), app_screen_capture_perm app = True \<longrightarrow> can_read_buffer app fb"
  by auto

(* Owner can read unprotected buffer *)
(* owner_reads_unprotected (matches Coq) *)
lemma owner_reads_unprotected: "\<forall> (app : Application) (fb : FrameBuffer), owns_buffer app fb \<longrightarrow> fb_protected fb = False \<longrightarrow> can_read_buffer app fb"
  by auto

(* Active overlay recorded in display state *)
(* overlay_state_consistent (matches Coq) *)
lemma overlay_state_consistent: "\<forall> (ds : DisplayState) (app_id : AppId), active_overlay ds = Some app_id \<longrightarrow> active_overlay ds \<noteq> None"
  by auto

(* No active overlay means no overlay app *)
(* no_overlay_no_app (matches Coq) *)
lemma no_overlay_no_app: "\<forall> (ds : DisplayState), active_overlay ds = None \<longrightarrow> \<forall> aid, active_overlay ds \<noteq> Some aid"
  by auto

(* Buffer identity via frame buffer id *)
(* fb_id_determines_buffer (matches Coq) *)
lemma fb_id_determines_buffer: "\<forall> (fb1 fb2 : FrameBuffer), fb_id fb1 = fb_id fb2 \<longrightarrow> fb_owner fb1 = fb_owner fb2 \<longrightarrow> fb_width fb1 = fb_width fb2 \<longrightarrow> fb_height fb1 = fb_height fb2 \<longrightarrow> fb_protected fb1 = fb_protected fb2 \<longrightarrow> fb1 = fb2"
  by (cases rule: ‹_›.cases; simp)

(* Display isolation symmetric: if app1 isolated from app2, vice versa *)
(* display_isolation_symmetric (matches Coq) *)
lemma display_isolation_symmetric: "\<forall> (app1 app2 : Application) (fb : FrameBuffer), app_id app1 \<noteq> app_id app2 \<longrightarrow> owns_buffer app2 fb \<longrightarrow> app_screen_capture_perm app1 = False \<longrightarrow> ~ can_read_buffer app1 fb"
  by auto

(* Capture permission for capture and overlay are independent *)
(* capture_overlay_independent (matches Coq) *)
lemma capture_overlay_independent: "\<forall> (app : Application), app_screen_capture_perm app = True \<longrightarrow> app_overlay_perm app = False \<longrightarrow> has_screen_capture_permission app \<and> ~ has_overlay_permission app"
  by auto

(* An app with both permissions can both capture and overlay *)
(* dual_perm_app (matches Coq) *)
lemma dual_perm_app: "\<forall> (app : Application), app_screen_capture_perm app = True \<longrightarrow> app_overlay_perm app = True \<longrightarrow> has_screen_capture_permission app \<and> has_overlay_permission app"
  by auto

(* An app with no permissions can neither capture nor overlay *)
(* no_perm_app (matches Coq) *)
lemma no_perm_app: "\<forall> (app : Application), app_screen_capture_perm app = False \<longrightarrow> app_overlay_perm app = False \<longrightarrow> ~ has_screen_capture_permission app \<and> ~ has_overlay_permission app"
  by auto

(* Display state with no buffers has no readable buffers *)
(* empty_display_no_read (matches Coq) *)
lemma empty_display_no_read: "\<forall> (ds : DisplayState) (app : Application) (fb : FrameBuffer), frame_buffers ds = [] \<longrightarrow> In fb (frame_buffers ds) \<longrightarrow> can_read_buffer app fb"
  by auto

(* Frame timestamps are comparable *)
(* frame_timestamp_order (matches Coq) *)
lemma frame_timestamp_order: "\<forall> (f1 f2 : Frame), frame_timestamp f1 \<le> frame_timestamp f2 \<or> frame_timestamp f2 < frame_timestamp f1"
  by auto

end
