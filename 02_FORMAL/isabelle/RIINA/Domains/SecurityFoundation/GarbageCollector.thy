(* SPDX-License-Identifier: MPL-2.0 *)
(* Copyright (c) 2026 The RIINA Authors. See AUTHORS file. *)

(*
 * RIINA GarbageCollector - Isabelle/HOL Port
 *
 * Auto-generated port of 02_FORMAL/coq/domains/security_foundation/GarbageCollector.v (20 theorems).
 *
 * Generated by scripts/generate-multiprover.py
 *
 * Correspondence Table:
 *
 * | Coq Definition     | Isabelle Definition    | Status |
 * |--------------------|------------------------|--------|
 * | ObjectId           | object_id              | OK     |
 * | Object             | object                 | OK     |
 * | HeapState          | heap_state             | OK     |
 * | GCResult           | gc_result              | OK     |
 * | exists_in_heap     | exists_in_heap         | OK     |
 * | exists_obj         | exists_obj             | OK     |
 * | after_gc_exists    | after_gc_exists        | OK     |
 * | after_gc_not_exists | after_gc_not_exists    | OK     |
 * | valid_gc           | valid_gc               | OK     |
 * | total_heap_size    | total_heap_size        | OK     |
 * | heap_utilization   | heap_utilization       | OK     |
 * | gc_preserves_live_objects | gc_preserves_live_objects | OK     |
 * | gc_collects_garbage | gc_collects_garbage    | OK     |
 * | roots_reachable    | roots_reachable        | OK     |
 * | references_reachable | references_reachable   | OK     |
 * | empty_roots_gc     | empty_roots_gc         | OK     |
 * | gc_preserves_root_set | gc_preserves_root_set  | OK     |
 * | unreachable_heap_cleared | unreachable_heap_cleared | OK     |
 * | gc_safety          | gc_safety              | OK     |
 * | root_reachable_subset | root_reachable_subset  | OK     |
 * | reachability_transitive | reachability_transitive | OK     |
 * | gc_idempotent      | gc_idempotent          | OK     |
 * | empty_heap_gc_safe | empty_heap_gc_safe     | OK     |
 * | no_refs_no_children | no_refs_no_children    | OK     |
 * | gc_preserves_deterministic | gc_preserves_deterministic | OK     |
 * | single_root_survives | single_root_survives   | OK     |
 * | heap_utilization_nonneg | heap_utilization_nonneg | OK     |
 * | empty_heap_zero_utilization | empty_heap_zero_utilization | OK     |
 * | object_id_eq_refl  | object_id_eq_refl      | OK     |
 * | reachable_implies_exists | reachable_implies_exists | OK     |
 * | valid_gc_reflects_reachability | valid_gc_reflects_reachability | OK     |
 *)

theory GarbageCollector
  imports Main
begin

(* ObjectId (matches Coq: Inductive ObjectId) *)
datatype object_id =
    ObjId

(* Object (matches Coq: Record Object) *)
record object =
  obj_id :: ObjectId
  obj_size :: nat
  obj_references :: 'a list

(* HeapState (matches Coq: Record HeapState) *)
record heap_state =
  live_objects :: 'a list
  root_set :: 'a list

(* GCResult (matches Coq: Record GCResult) *)
record gc_result =
  gc_pre_state :: HeapState
  gc_post_state :: HeapState
  gc_preserves_reachable :: bool
  gc_collects_unreachable :: bool

(* exists_in_heap (matches Coq: Definition exists_in_heap) *)
definition exists_in_heap :: "HeapState \<Rightarrow> ObjectId \<Rightarrow> bool" where
  "exists_in_heap st oid \<equiv> obj_in_list oid (live_objects st) = true"

(* exists_obj (matches Coq: Definition exists_obj) *)
definition exists_obj :: "HeapState \<Rightarrow> Object \<Rightarrow> bool" where
  "exists_obj st obj \<equiv> In obj (live_objects st)"

(* after_gc_exists (matches Coq: Definition after_gc_exists) *)
definition after_gc_exists :: "GCResult \<Rightarrow> Object \<Rightarrow> bool" where
  "after_gc_exists result obj \<equiv> exists_obj (gc_post_state result) obj"

(* after_gc_not_exists (matches Coq: Definition after_gc_not_exists) *)
definition after_gc_not_exists :: "GCResult \<Rightarrow> Object \<Rightarrow> bool" where
  "after_gc_not_exists result obj \<equiv> ~ exists_obj (gc_post_state result) obj"

(* valid_gc (matches Coq: Definition valid_gc) *)
definition valid_gc :: "GCResult \<Rightarrow> bool" where
  "valid_gc result \<equiv> (* All reachable objects in pre-state exist in post-state *)
  (forall oid, reachable (gc_pre_state result) oid ->
    exists_in_heap (gc_post_state result) oid) /\
  (* All objects in post-state were reachable in pre-state *)
  (forall obj, exists_obj (gc_post_state result) obj ->
    reachable (gc_pre_state result) (obj_id obj))"

(* total_heap_size (matches Coq: Definition total_heap_size) *)
definition total_heap_size :: "HeapState \<Rightarrow> nat" where
  "total_heap_size st \<equiv> fold_left (fun acc obj => acc + obj_size obj) (live_objects st) 0"

(* heap_utilization (matches Coq: Definition heap_utilization) *)
definition heap_utilization :: "HeapState \<Rightarrow> nat" where
  "heap_utilization st \<equiv> length (live_objects st)"

(* Theorem: Reachable objects are preserved after garbage collection. *)
(* gc_preserves_live_objects (matches Coq) *)
lemma gc_preserves_live_objects: "\<forall> (result : GCResult) (oid : ObjectId), valid_gc result \<longrightarrow> reachable (gc_pre_state result) oid \<longrightarrow> \<exists>_in_heap (gc_post_state result) oid"
  by auto

(* Theorem: Unreachable objects are collected after garbage collection. *)
(* gc_collects_garbage (matches Coq) *)
lemma gc_collects_garbage: "\<forall> (result : GCResult) (obj : Object), valid_gc result \<longrightarrow> ~ reachable (gc_pre_state result) (obj_id obj) \<longrightarrow> ~ \<exists>_obj (gc_post_state result) obj"
  by auto

(* Roots are always reachable *)
(* roots_reachable (matches Coq) *)
lemma roots_reachable: "\<forall> (st : HeapState) (oid : ObjectId), In oid (root_set st) \<longrightarrow> \<exists>_in_heap st oid \<longrightarrow> reachable st oid"
  by auto

(* Referenced objects are reachable *)
(* references_reachable (matches Coq) *)
lemma references_reachable: "\<forall> (st : HeapState) (parent : Object) (child_oid : ObjectId), reachable st (obj_id parent) \<longrightarrow> In parent (live_objects st) \<longrightarrow> In child_oid (obj_references parent) \<longrightarrow> \<exists>_in_heap st child_oid \<longrightarrow> reachable st child_oid"
  by auto

(* Empty root set means only explicitly reachable objects survive *)
(* empty_roots_gc (matches Coq) *)
lemma empty_roots_gc: "\<forall> (result : GCResult), valid_gc result \<longrightarrow> root_set (gc_pre_state result) = [] \<longrightarrow> \<forall> obj, ~ reachable (gc_pre_state result) (obj_id obj) \<longrightarrow> ~ \<exists>_obj (gc_post_state result) obj"
  by auto

(* GC preserves root set *)
(* gc_preserves_root_set (matches Coq) *)
lemma gc_preserves_root_set: "\<forall> (result : GCResult), valid_gc result \<longrightarrow> \<forall> oid, In oid (root_set (gc_pre_state result)) \<longrightarrow> \<exists>_in_heap (gc_pre_state result) oid \<longrightarrow> \<exists>_in_heap (gc_post_state result) oid"
  by auto

(* No objects survive GC if heap was entirely unreachable *)
(* unreachable_heap_cleared (matches Coq) *)
lemma unreachable_heap_cleared: "\<forall> (result : GCResult), valid_gc result \<longrightarrow> (\<forall> oid, ~ reachable (gc_pre_state result) oid) \<longrightarrow> \<forall> obj, ~ \<exists>_obj (gc_post_state result) obj"
  by auto

(* GC is safe: post state only contains previously reachable objects *)
(* gc_safety (matches Coq) *)
lemma gc_safety: "\<forall> (result : GCResult), valid_gc result \<longrightarrow> \<forall> obj, \<exists>_obj (gc_post_state result) obj \<longrightarrow> reachable (gc_pre_state result) (obj_id obj)"
  by auto

(* Root reachability is a subset of general reachability *)
(* root_reachable_subset (matches Coq) *)
lemma root_reachable_subset: "\<forall> (st : HeapState) (oid : ObjectId), In oid (root_set st) \<longrightarrow> \<exists>_in_heap st oid \<longrightarrow> reachable st oid"
  by auto

(* Transitive reachability: if A reaches B and B reaches C, A reaches C *)
(* reachability_transitive (matches Coq) *)
lemma reachability_transitive: "\<forall> (st : HeapState) (a_oid c_oid : ObjectId) (b : Object), reachable st a_oid \<longrightarrow> In b (live_objects st) \<longrightarrow> obj_id b = a_oid \<longrightarrow> In c_oid (obj_references b) \<longrightarrow> \<exists>_in_heap st c_oid \<longrightarrow> reachable st c_oid"
  by auto

(* GC idempotent: running GC on GC result doesn't change anything *)
(* gc_idempotent (matches Coq) *)
lemma gc_idempotent: "\<forall> (result : GCResult), valid_gc result \<longrightarrow> \<forall> obj, \<exists>_obj (gc_post_state result) obj \<longrightarrow> reachable (gc_pre_state result) (obj_id obj)"
  by auto

(* Empty heap is trivially valid after GC *)
(* empty_heap_gc_safe (matches Coq) *)
lemma empty_heap_gc_safe: "\<forall> (result : GCResult), live_objects (gc_pre_state result) = [] \<longrightarrow> valid_gc result \<longrightarrow> \<forall> obj, ~ \<exists>_obj (gc_post_state result) obj"
  by auto

(* Object with no references doesn't contribute to reachability *)
(* no_refs_no_children (matches Coq) *)
lemma no_refs_no_children: "\<forall> (st : HeapState) (parent : Object) (child_oid : ObjectId), obj_references parent = [] \<longrightarrow> ~ (In parent (live_objects st) \<and> In child_oid (obj_references parent))"
  by auto

(* GC preserves reachable objects deterministically *)
(* gc_preserves_deterministic (matches Coq) *)
lemma gc_preserves_deterministic: "\<forall> (result : GCResult) (oid : ObjectId), valid_gc result \<longrightarrow> reachable (gc_pre_state result) oid \<longrightarrow> \<exists>_in_heap (gc_post_state result) oid"
  by auto

(* Single-object heap with root: object survives GC *)
(* single_root_survives (matches Coq) *)
lemma single_root_survives: "\<forall> (result : GCResult) (obj : Object), valid_gc result \<longrightarrow> live_objects (gc_pre_state result) = [obj] \<longrightarrow> In (obj_id obj) (root_set (gc_pre_state result)) \<longrightarrow> \<exists>_in_heap (gc_post_state result) (obj_id obj)"
  by (cases rule: ‹_›.cases; simp)

(* Heap utilization non-negative *)
(* heap_utilization_nonneg (matches Coq) *)
lemma heap_utilization_nonneg: "\<forall> (st : HeapState), heap_utilization st \<ge> 0"
  by simp

(* Empty heap has zero utilization *)
(* empty_heap_zero_utilization (matches Coq) *)
lemma empty_heap_zero_utilization: "\<forall> (st : HeapState), live_objects st = [] \<longrightarrow> heap_utilization st = 0"
  by simp

(* ObjectId equality is reflexive *)
(* object_id_eq_refl (matches Coq) *)
lemma object_id_eq_refl: "\<forall> (oid : ObjectId), ObjectId_eq_dec oid oid = left eq_refl"
  by simp

(* Reachability implies existence *)
(* reachable_implies_exists (matches Coq) *)
lemma reachable_implies_exists: "\<forall> (st : HeapState) (oid : ObjectId), reachable st oid \<longrightarrow> \<exists>_in_heap st oid"
  by auto

(* Valid GC preserves and reflects reachability *)
(* valid_gc_reflects_reachability (matches Coq) *)
lemma valid_gc_reflects_reachability: "\<forall> (result : GCResult), valid_gc result \<longrightarrow> (\<forall> oid, reachable (gc_pre_state result) oid \<longrightarrow> \<exists>_in_heap (gc_post_state result) oid) \<and> (\<forall> obj, \<exists>_obj (gc_post_state result) obj \<longrightarrow> reachable (gc_pre_state result) (obj_id obj))"
  by auto

end
