(* SPDX-License-Identifier: MPL-2.0 *)
(* Copyright (c) 2026 The RIINA Authors. See AUTHORS file. *)

(*
 * RIINA LLMProofPipeline - Isabelle/HOL Port
 *
 * Auto-generated port of 02_FORMAL/coq/domains/LLMProofPipeline.v (20 theorems).
 *
 * Generated by scripts/generate-multiprover.py
 *
 * Correspondence Table:
 *
 * | Coq Definition     | Isabelle Definition    | Status |
 * |--------------------|------------------------|--------|
 * | formula            | formula                | OK     |
 * | proof_term         | proof_term             | OK     |
 * | valid              | valid                  | OK     |
 * | satisfies_ctx      | satisfies_ctx          | OK     |
 * | identity_proof     | identity_proof         | OK     |
 * | compose_proof      | compose_proof          | OK     |
 * | conj_intro_proof   | conj_intro_proof       | OK     |
 * | conj_elim_left     | conj_elim_left         | OK     |
 * | conj_elim_right    | conj_elim_right        | OK     |
 * | formula_eqb_refl   | formula_eqb_refl       | OK     |
 * | formula_eqb_eq     | formula_eqb_eq         | OK     |
 * | formula_eqb_neq    | formula_eqb_neq        | OK     |
 * | 1                  | 1                      | OK     |
 * | derives_sound      | derives_sound          | OK     |
 * | 2                  | 2                      | OK     |
 * | 3                  | 3                      | OK     |
 * | 4                  | 4                      | OK     |
 * | 5a                 | 5a                     | OK     |
 * | 5b                 | 5b                     | OK     |
 * | 6                  | 6                      | OK     |
 * | 7                  | 7                      | OK     |
 * | invalid_axiom_rejected | invalid_axiom_rejected | OK     |
 * | invalid_mismatch_rejected | invalid_mismatch_rejected | OK     |
 * | 8                  | 8                      | OK     |
 * | weakening_derives  | weakening_derives      | OK     |
 * | weakening          | weakening              | OK     |
 * | pipeline_soundness | pipeline_soundness     | OK     |
 * | identity_is_valid  | identity_is_valid      | OK     |
 * | 11                 | 11                     | OK     |
 *)

theory LLMProofPipeline
  imports Main
begin

(* Boolean conjunction helper (matches Coq: andb_true_iff) *)
lemma andb_true_iff: "(a \<and> b) = True \<longleftrightarrow> a = True \<and> b = True"
  by auto

(* formula (matches Coq: Inductive formula) *)
datatype formula =
    FVar
  |     FImpl
  |     FConj
  |     FDisj

(* proof_term (matches Coq: Inductive proof_term) *)
datatype proof_term =
    PAxiom  (* use hypothesis by index *)
  |     PImplIntro  (* lambda: assume A, prove B *)
  |     PImplElim  (* modus ponens *)
  |     PConjIntro
  |     PConjElimL
  |     PConjElimR

(* valid (matches Coq: Definition valid) *)
definition valid :: "formula \<Rightarrow> bool" where
  "valid f \<equiv> forall v, sem v f"

(* satisfies_ctx (matches Coq: Definition satisfies_ctx) *)
definition satisfies_ctx :: "valuation \<Rightarrow> context \<Rightarrow> bool" where
  "satisfies_ctx v ctx \<equiv> forall n f, nth_error ctx n = Some f -> sem v f"

(* identity_proof (matches Coq: Definition identity_proof) *)
definition identity_proof :: "formula \<Rightarrow> proof_term" where
  "identity_proof a \<equiv> PImplIntro a (PAxiom 0)"

(* compose_proof (matches Coq: Definition compose_proof) *)
definition compose_proof :: "proof_term" where
  "compose_proof \<equiv> (* In context [A->B, B->C], prove A->C *)
  (* We build a closed proof: assume A->B and B->C in context, then intro A *)
  PImplIntro a (PImplElim (PAxiom 2) (PImplElim (PAxiom 1) (PAxiom 0)))"

(* conj_intro_proof (matches Coq: Definition conj_intro_proof) *)
definition conj_intro_proof :: "proof_term" where
  "conj_intro_proof \<equiv> PConjIntro (PAxiom 0) (PAxiom 1)"

(* conj_elim_left (matches Coq: Definition conj_elim_left) *)
definition conj_elim_left :: "proof_term" where
  "conj_elim_left \<equiv> PConjElimL (PAxiom 0)"

(* conj_elim_right (matches Coq: Definition conj_elim_right) *)
definition conj_elim_right :: "proof_term" where
  "conj_elim_right \<equiv> PConjElimR (PAxiom 0)"

(* formula_eqb_refl (matches Coq) *)
lemma formula_eqb_refl: "\<forall> f, formula_eqb f f = True"
  by auto

(* formula_eqb_eq (matches Coq) *)
lemma formula_eqb_eq: "\<forall> f1 f2, formula_eqb f1 f2 = True \<longrightarrow> f1 = f2"
  by (cases rule: ‹_›.cases; simp)

(* formula_eqb_neq (matches Coq) *)
lemma formula_eqb_neq: "\<forall> f1 f2, formula_eqb f1 f2 = False \<longrightarrow> f1 \<noteq> f2"
  by auto

(* 1 (matches Coq) *)
lemma 1: "Proof checker soundness *) Theorem checker_soundness : \<forall> ctx p f, check ctx p = Some f \<longrightarrow> derives ctx f"
  by auto

(* derives_sound (matches Coq) *)
lemma derives_sound: "\<forall> ctx f, derives ctx f \<longrightarrow> \<forall> v, satisfies_ctx v ctx \<longrightarrow> sem v f"
  by auto

(* 2 (matches Coq) *)
lemma 2: "Identity proof A \<longrightarrow> A is valid *) (* ========================================================================= *) Definition identity_proof (a : formula) : proof_term := PImplIntro a (PAxiom 0). Theorem identity_proof_valid : \<forall> a, check [] (identity_proof a) = Some (FImpl a a)"
  by simp

(* 3 (matches Coq) *)
lemma 3: "Composition of proofs (A->B, B->C gives A->C) *) (* ========================================================================= *) Definition compose_proof (a b c : formula) : proof_term := (* In context [A->B, B->C], prove A->C *) (* We build a closed proof: assume A->B and B->C in context, then intro A *) PImplIntro a (PImplElim (PAxiom 2) (PImplElim (PAxiom 1) (PAxiom 0))). Theorem compose_proof_valid : \<forall> a b c, check [FImpl a b; FImpl b c] (compose_proof a b c) = Some (FImpl a c)"
  by simp

(* 4 (matches Coq) *)
lemma 4: "Conjunction introduction is valid *) (* ========================================================================= *) Definition conj_intro_proof (a b : formula) : proof_term := PConjIntro (PAxiom 0) (PAxiom 1). Theorem conj_intro_valid : \<forall> a b, check [a; b] (conj_intro_proof a b) = Some (FConj a b)"
  by simp

(* 5a (matches Coq) *)
lemma 5a: "Conjunction elimination left *) (* ========================================================================= *) Definition conj_elim_left (a b : formula) : proof_term := PConjElimL (PAxiom 0). Theorem conj_elim_left_valid : \<forall> a b, check [FConj a b] (conj_elim_left a b) = Some a"
  by simp

(* 5b (matches Coq) *)
lemma 5b: "Conjunction elimination right *) (* ========================================================================= *) Definition conj_elim_right (a b : formula) : proof_term := PConjElimR (PAxiom 0). Theorem conj_elim_right_valid : \<forall> a b, check [FConj a b] (conj_elim_right a b) = Some b"
  by simp

(* 6 (matches Coq) *)
lemma 6: "Proof checker is deterministic *) (* ========================================================================= *) Theorem checker_deterministic : \<forall> ctx p f1 f2, check ctx p = Some f1 \<longrightarrow> check ctx p = Some f2 \<longrightarrow> f1 = f2"
  by auto

(* 7 (matches Coq) *)
lemma 7: "Invalid proofs are rejected *) (* ========================================================================= *) (* Applying a non-implication fails *) Theorem invalid_modus_ponens_rejected : \<forall> ctx p1 p2 a, check ctx p1 = Some (FVar a) \<longrightarrow> check ctx (PImplElim p1 p2) = None"
  by simp

(* invalid_axiom_rejected (matches Coq) *)
lemma invalid_axiom_rejected: "\<forall> ctx n, nth_error ctx n = None \<longrightarrow> check ctx (PAxiom n) = None"
  by auto

(* invalid_mismatch_rejected (matches Coq) *)
lemma invalid_mismatch_rejected: "\<forall> ctx p1 p2 a a' b, check ctx p1 = Some (FImpl a b) \<longrightarrow> check ctx p2 = Some a' \<longrightarrow> formula_eqb a a' = False \<longrightarrow> check ctx (PImplElim p1 p2) = None"
  by simp

(* 8 (matches Coq) *)
lemma 8: "Weakening — valid proof in Γ is valid in Γ,A *) (* ========================================================================= *) (* We prove weakening for the derives relation (semantic level). *) Lemma nth_error_insert : \<forall> (ctx : context) (n pos : nat) (a : formula), pos \<le> n \<longrightarrow> nth_error ctx n = nth_error (firstn pos ctx ++ a :: skipn pos ctx) (S n)"
  by (cases rule: ‹_›.cases; simp)

(* weakening_derives (matches Coq) *)
lemma weakening_derives: "\<forall> ctx f, derives ctx f \<longrightarrow> \<forall> a, derives (ctx ++ [a]) f"
  by auto

(* weakening (matches Coq) *)
lemma weakening: "\<forall> ctx f a, derives ctx f \<longrightarrow> derives (ctx ++ [a]) f"
  by auto

(* pipeline_soundness (matches Coq) *)
lemma pipeline_soundness: "\<forall> p f, check [] p = Some f \<longrightarrow> valid f"
  by auto

(* identity_is_valid (matches Coq) *)
lemma identity_is_valid: "\<forall> a v, sem v (FImpl a a)"
  by auto

(* 11 (matches Coq) *)
lemma 11: "Conjunction is commutative under semantics *) Theorem conj_comm_sem : \<forall> a b v, sem v (FConj a b) \<longrightarrow> sem v (FConj b a)"
  by auto

end
