(* SPDX-License-Identifier: MPL-2.0 *)
(* Copyright (c) 2026 The RIINA Authors. See AUTHORS file. *)

(*
 * RIINA AlgebraicEffects - Isabelle/HOL Port
 *
 * Auto-generated port of 02_FORMAL/coq/domains/AlgebraicEffects.v (22 theorems).
 *
 * Generated by scripts/generate-multiprover.py
 *
 * Correspondence Table:
 *
 * | Coq Definition     | Isabelle Definition    | Status |
 * |--------------------|------------------------|--------|
 * | BaseTy             | base_ty                | OK     |
 * | EffectOp           | effect_op              | OK     |
 * | CompTy             | comp_ty                | OK     |
 * | Val                | val                    | OK     |
 * | Comp               | comp                   | OK     |
 * | EvalCtx            | eval_ctx               | OK     |
 * | OpSig              | op_sig                 | OK     |
 * | effectOp_eqb       | effectOp_eqb           | OK     |
 * | in_row             | in_row                 | OK     |
 * | row_subset         | row_subset             | OK     |
 * | row_union          | row_union              | OK     |
 * | row_nodup          | row_nodup              | OK     |
 * | empty_row          | empty_row              | OK     |
 * | getBaseTy          | getBaseTy              | OK     |
 * | getEffectRow       | getEffectRow           | OK     |
 * | opSignature        | opSignature            | OK     |
 * | sig_wellformed     | sig_wellformed         | OK     |
 * | row_minus          | row_minus              | OK     |
 * | effect_polymorphic_fn | effect_polymorphic_fn  | OK     |
 * | all_effects_handled | all_effects_handled    | OK     |
 * | respects_effects   | respects_effects       | OK     |
 * | effectOp_eqb_eq    | effectOp_eqb_eq        | OK     |
 * | effectOp_eqb_refl  | effectOp_eqb_refl      | OK     |
 * | in_row_In          | in_row_In              | OK     |
 * | row_subset_incl    | row_subset_incl        | OK     |
 * | row_minus_spec     | row_minus_spec         | OK     |
 * | EFF_001_01_effect_signature_wellformedness | EFF_001_01_effect_signature_wellformedness | OK     |
 * | EFF_001_02_operation_typing | EFF_001_02_operation_typing | OK     |
 * | EFF_001_03_handler_typing | EFF_001_03_handler_typing | OK     |
 * | EFF_001_04_effect_row_combination | EFF_001_04_effect_row_combination | OK     |
 * | EFF_001_05_effect_subsumption | EFF_001_05_effect_subsumption | OK     |
 * | EFF_001_06_pure_computation | EFF_001_06_pure_computation | OK     |
 * | compose_handlers_effects | compose_handlers_effects | OK     |
 * | EFF_001_07_handler_composition | EFF_001_07_handler_composition | OK     |
 * | EFF_001_08_effect_polymorphism | EFF_001_08_effect_polymorphism | OK     |
 * | EFF_001_09_deep_handler_semantics | EFF_001_09_deep_handler_semantics | OK     |
 * | EFF_001_10_shallow_handler_semantics | EFF_001_10_shallow_handler_semantics | OK     |
 * | EFF_001_11_effect_masking | EFF_001_11_effect_masking | OK     |
 * | EFF_001_12_resumption_linearity | EFF_001_12_resumption_linearity | OK     |
 * | EFF_001_13_effect_safety | EFF_001_13_effect_safety | OK     |
 * | EFF_001_14_effect_parametricity | EFF_001_14_effect_parametricity | OK     |
 * | eval_pure_deterministic | eval_pure_deterministic | OK     |
 * | EFF_001_15_effect_coherence | EFF_001_15_effect_coherence | OK     |
 *)

theory AlgebraicEffects
  imports Main
begin

(* BaseTy (matches Coq: Inductive BaseTy) *)
datatype base_ty =
    TUnit
  |     TBool
  |     TNat

(* EffectOp (matches Coq: Inductive EffectOp) *)
datatype effect_op =
    OpRead  (* State read *)
  |     OpWrite  (* State write *)
  |     OpRaise  (* Exception raise *)
  |     OpPrint  (* I/O print *)
  |     OpRandom  (* Non-determinism *)
  |     OpAsync  (* Async operation *)

(* CompTy (matches Coq: Inductive CompTy) *)
datatype comp_ty =
    CTyPure  (* A ! ∅ *)
  |     CTyEff  (* A ! Σ *)

(* Val (matches Coq: Inductive Val) *)
datatype val =
    VUnit
  |     VBool
  |     VNat

(* Comp (matches Coq: Inductive Comp) *)
datatype comp =
    CReturn  (* return v *)
  |     CPerform  (* perform op v *)
  |     CHandle  (* handle c with h *)
  |     CBind
  |     HReturn  (* return case *)
  |     HOp

(* EvalCtx (matches Coq: Inductive EvalCtx) *)
datatype eval_ctx =
    EHole
  |     EBind

(* OpSig (matches Coq: Record OpSig) *)
record op_sig =
  opInputTy :: BaseTy
  opOutputTy :: BaseTy

(* effectOp_eqb - complex match, manual review needed *)

(* in_row (matches Coq: Definition in_row) *)
definition in_row :: "EffectOp \<Rightarrow> EffectRow \<Rightarrow> bool" where
  "in_row op row \<equiv> existsb (fun o => effectOp_eqb op o) row"

(* row_subset (matches Coq: Definition row_subset) *)
definition row_subset :: "bool" where
  "row_subset \<equiv> forallb (fun op => in_row op r2) r1"

(* row_union (matches Coq: Definition row_union) *)
definition row_union :: "EffectRow" where
  "row_union \<equiv> r1 ++ r2"

(* row_nodup (matches Coq: Definition row_nodup) *)
definition row_nodup :: "EffectRow \<Rightarrow> bool" where
  "row_nodup r \<equiv> NoDup r"

(* empty_row (matches Coq: Definition empty_row) *)
definition empty_row :: "EffectRow" where
  "empty_row \<equiv> []"

(* getBaseTy (matches Coq: Definition getBaseTy) *)
fun getBaseTy :: "CompTy \<Rightarrow> BaseTy" where


(* getEffectRow (matches Coq: Definition getEffectRow) *)
fun getEffectRow :: "CompTy \<Rightarrow> EffectRow" where


(* opSignature (matches Coq: Definition opSignature) *)
fun opSignature :: "EffectOp \<Rightarrow> OpSig" where
  "opSignature OpRead = mkOpSig"
|   "opSignature OpWrite = mkOpSig"
|   "opSignature OpRaise = mkOpSig"
|   "opSignature OpPrint = mkOpSig"
|   "opSignature OpRandom = mkOpSig"
|   "opSignature OpAsync = mkOpSig"

(* sig_wellformed (matches Coq: Definition sig_wellformed) *)
definition sig_wellformed :: "EffectSig \<Rightarrow> bool" where
  "sig_wellformed sig \<equiv> NoDup sig"

(* row_minus (matches Coq: Definition row_minus) *)
definition row_minus :: "EffectRow \<Rightarrow> EffectRow \<Rightarrow> EffectRow" where
  "row_minus r handled \<equiv> filter (fun op => negb (in_row op handled)) r"

(* effect_polymorphic_fn (matches Coq: Definition effect_polymorphic_fn) *)
definition effect_polymorphic_fn :: "bool" where
  "effect_polymorphic_fn \<equiv> forall sig c t,
    comp_has_type c (CTyEff t sig) ->
    comp_has_type (f sig c) (CTyEff t sig)"

(* all_effects_handled (matches Coq: Definition all_effects_handled) *)
definition all_effects_handled :: "Comp \<Rightarrow> EffectRow \<Rightarrow> bool" where
  "all_effects_handled c handled \<equiv> forall op v,
    c = CPerform op v ->
    In op handled"

(* respects_effects (matches Coq: Definition respects_effects) *)
definition respects_effects :: "bool" where
  "respects_effects \<equiv> forall c t sig,
    comp_has_type c (CTyEff t sig) ->
    exists sig',
      comp_has_type (f c) (CTyEff t sig') /\
      incl sig' sig"

(* effectOp_eqb_eq (matches Coq) *)
lemma effectOp_eqb_eq: "\<forall> o1 o2, effectOp_eqb o1 o2 = True <-> o1 = o2"
  by (cases rule: ‹_›.cases; simp)

(* effectOp_eqb_refl (matches Coq) *)
lemma effectOp_eqb_refl: "\<forall> o, effectOp_eqb o o = True"
  by simp

(* in_row_In (matches Coq) *)
lemma in_row_In: "\<forall> op row, in_row op row = True <-> In op row"
  by auto

(* row_subset_incl (matches Coq) *)
lemma row_subset_incl: "\<forall> r1 r2, row_subset r1 r2 = True <-> incl r1 r2"
  by auto

(* row_minus_spec (matches Coq) *)
lemma row_minus_spec: "\<forall> r handled op, In op (row_minus r handled) <-> In op r \<and> ~In op handled"
  by auto

(* EFF_001_01_effect_signature_wellformedness (matches Coq) *)
lemma EFF_001_01_effect_signature_wellformedness: "\<forall> (sig : EffectSig), sig_wellformed sig \<longrightarrow> \<forall> op1 op2 i j, nth_error sig i = Some op1 \<longrightarrow> nth_error sig j = Some op2 \<longrightarrow> op1 = op2 \<longrightarrow> i = j"
  by simp

(* EFF_001_02_operation_typing (matches Coq) *)
lemma EFF_001_02_operation_typing: "\<forall> (op : EffectOp) (v : Val) (sig : EffectSig), val_has_type v (opInputTy (opSignature op)) \<longrightarrow> In op sig \<longrightarrow> comp_has_type (CPerform op v) (CTyEff (opOutputTy (opSignature op)) sig)"
  by auto

(* EFF_001_03_handler_typing (matches Coq) *)
lemma EFF_001_03_handler_typing: "\<forall> (h : Handler) (c : Comp) (t : BaseTy) (sig sig' : EffectRow), comp_has_type c (CTyEff t sig) \<longrightarrow> handler_has_type h sig t sig' \<longrightarrow> comp_has_type (CHandle c h) (CTyEff t sig')"
  by auto

(* EFF_001_04_effect_row_combination (matches Coq) *)
lemma EFF_001_04_effect_row_combination: "\<forall> (r1 r2 : EffectRow), sig_wellformed r1 \<longrightarrow> sig_wellformed r2 \<longrightarrow> (\<forall> op, In op r1 \<longrightarrow> ~In op r2) \<longrightarrow> sig_wellformed (row_union r1 r2)"
  by auto

(* EFF_001_05_effect_subsumption (matches Coq) *)
lemma EFF_001_05_effect_subsumption: "\<forall> (op : EffectOp) (v : Val) (sig sig' : EffectRow), comp_has_type (CPerform op v) (CTyEff (opOutputTy (opSignature op)) sig) \<longrightarrow> incl sig sig' \<longrightarrow> comp_has_type (CPerform op v) (CTyEff (opOutputTy (opSignature op)) sig')"
  by auto

(* EFF_001_06_pure_computation (matches Coq) *)
lemma EFF_001_06_pure_computation: "\<forall> (c : Comp) (t : BaseTy), comp_has_type c (CTyPure t) \<longrightarrow> is_pure c"
  by auto

(* compose_handlers_effects (matches Coq) *)
lemma compose_handlers_effects: "\<forall> h1 h2, handler_effects (compose_handlers h1 h2) = handler_effects h1 ++ handler_effects h2"
  by simp

(* EFF_001_07_handler_composition (matches Coq) *)
lemma EFF_001_07_handler_composition: "\<forall> (h1 h2 : Handler) (t : BaseTy) (sig : EffectRow), handler_has_type h1 (handler_effects h1) t sig \<longrightarrow> handler_has_type h2 (handler_effects h2) t sig \<longrightarrow> (\<forall> op, In op (handler_effects h1) \<longrightarrow> ~In op (handler_effects h2)) \<longrightarrow> handler_has_type (compose_handlers h1 h2) (handler_effects h1 ++ handler_effects h2) t sig"
  by auto

(* EFF_001_08_effect_polymorphism (matches Coq) *)
lemma EFF_001_08_effect_polymorphism: "\<forall> (f : \<forall> sig, Comp \<longrightarrow> Comp), (\<forall> sig c, f sig c = c) \<longrightarrow> effect_polymorphic_fn f"
  by auto

(* EFF_001_09_deep_handler_semantics (matches Coq) *)
lemma EFF_001_09_deep_handler_semantics: "\<forall> (op : EffectOp) (v : Val) (f : Val \<longrightarrow> (Val \<longrightarrow> Comp) \<longrightarrow> Comp) (h : Handler), deep_step (CHandle (CPerform op v) (HOp op f h)) (f v (fun r => CHandle (CReturn r) (HOp op f h)))"
  by auto

(* EFF_001_10_shallow_handler_semantics (matches Coq) *)
lemma EFF_001_10_shallow_handler_semantics: "\<forall> (op : EffectOp) (v : Val) (f : Val \<longrightarrow> (Val \<longrightarrow> Comp) \<longrightarrow> Comp) (h : Handler), shallow_step (CHandle (CPerform op v) (HOp op f h)) (f v (fun r => CReturn r))"
  by auto

(* EFF_001_11_effect_masking (matches Coq) *)
lemma EFF_001_11_effect_masking: "\<forall> (h : Handler) (sig : EffectRow) (op : EffectOp), In op (handler_effects h) \<longrightarrow> In op sig \<longrightarrow> ~In op (row_minus sig (handler_effects h))"
  by auto

(* EFF_001_12_resumption_linearity (matches Coq) *)
lemma EFF_001_12_resumption_linearity: "\<forall> (f : Val \<longrightarrow> (Val \<longrightarrow> Comp) \<longrightarrow> Comp) (v : Val) (k : Val \<longrightarrow> Comp), linear_handler_clause f \<longrightarrow> \<exists> r, f v k = k r"
  by auto

(* EFF_001_13_effect_safety (matches Coq) *)
lemma EFF_001_13_effect_safety: "\<forall> (c : Comp) (t : BaseTy), comp_has_type c (CTyEff t empty_row) \<longrightarrow> (\<forall> op v, c \<noteq> CPerform op v)"
  by auto

(* EFF_001_14_effect_parametricity (matches Coq) *)
lemma EFF_001_14_effect_parametricity: "\<forall> (f : Comp \<longrightarrow> Comp), (\<forall> c, f c = c) \<longrightarrow> respects_effects f"
  by auto

(* eval_pure_deterministic (matches Coq) *)
lemma eval_pure_deterministic: "\<forall> c v1 v2, eval_pure c v1 \<longrightarrow> eval_pure c v2 \<longrightarrow> v1 = v2"
  by simp

(* EFF_001_15_effect_coherence (matches Coq) *)
lemma EFF_001_15_effect_coherence: "\<forall> (c : Comp) (v1 v2 : Val), is_pure c \<longrightarrow> eval_pure c v1 \<longrightarrow> eval_pure c v2 \<longrightarrow> v1 = v2"
  by auto

end
