(* SPDX-License-Identifier: MPL-2.0 *)
(* Copyright (c) 2026 The RIINA Authors. See AUTHORS file. *)

(*
 * RIINA RefinementTypes - Isabelle/HOL Port
 *
 * Auto-generated port of 02_FORMAL/coq/domains/RefinementTypes.v (24 theorems).
 *
 * Generated by scripts/generate-multiprover.py
 *
 * Correspondence Table:
 *
 * | Coq Definition     | Isabelle Definition    | Status |
 * |--------------------|------------------------|--------|
 * | BaseTy             | base_ty                | OK     |
 * | Pred               | pred                   | OK     |
 * | RefTy              | ref_ty                 | OK     |
 * | Expr               | expr                   | OK     |
 * | pred_implies       | pred_implies           | OK     |
 * | inhabits_refinement | inhabits_refinement    | OK     |
 * | is_null            | is_null                | OK     |
 * | is_non_null        | is_non_null            | OK     |
 * | bounds_pred        | bounds_pred            | OK     |
 * | non_null_pred      | non_null_pred          | OK     |
 * | array_index_pred   | array_index_pred       | OK     |
 * | positive_pred      | positive_pred          | OK     |
 * | TYPE_004_01_refinement_subtyping | TYPE_004_01_refinement_subtyping | OK     |
 * | TYPE_004_02_refinement_introduction | TYPE_004_02_refinement_introduction | OK     |
 * | TYPE_004_03_refinement_elimination | TYPE_004_03_refinement_elimination | OK     |
 * | TYPE_004_04_refinement_conjunction | TYPE_004_04_refinement_conjunction | OK     |
 * | TYPE_004_05_dependent_function_refinement | TYPE_004_05_dependent_function_refinement | OK     |
 * | TYPE_004_06_refinement_substitution | TYPE_004_06_refinement_substitution | OK     |
 * | TYPE_004_07_smt_decidability | TYPE_004_07_smt_decidability | OK     |
 * | TYPE_004_08_bounds_checking | TYPE_004_08_bounds_checking | OK     |
 * | TYPE_004_09_non_null_refinement | TYPE_004_09_non_null_refinement | OK     |
 * | TYPE_004_10_array_bounds_safety | TYPE_004_10_array_bounds_safety | OK     |
 * | TYPE_004_11_positive_refinement | TYPE_004_11_positive_refinement | OK     |
 * | TYPE_004_12_refinement_preservation | TYPE_004_12_refinement_preservation | OK     |
 * | TYPE_004_13_pred_true_satisfied | TYPE_004_13_pred_true_satisfied | OK     |
 * | TYPE_004_14_pred_false_unsatisfied | TYPE_004_14_pred_false_unsatisfied | OK     |
 * | TYPE_004_15_pred_and_comm | TYPE_004_15_pred_and_comm | OK     |
 * | TYPE_004_16_pred_or_comm | TYPE_004_16_pred_or_comm | OK     |
 * | TYPE_004_17_pred_implies_ptrue | TYPE_004_17_pred_implies_ptrue | OK     |
 * | TYPE_004_18_pred_pfalse_implies | TYPE_004_18_pred_pfalse_implies | OK     |
 * | TYPE_004_19_subtype_refl | TYPE_004_19_subtype_refl | OK     |
 * | TYPE_004_20_pred_double_neg | TYPE_004_20_pred_double_neg | OK     |
 * | TYPE_004_21_eval_val | TYPE_004_21_eval_val   | OK     |
 * | TYPE_004_22_pred_impl_refl | TYPE_004_22_pred_impl_refl | OK     |
 * | TYPE_004_23_pred_and_assoc | TYPE_004_23_pred_and_assoc | OK     |
 * | TYPE_004_24_pred_or_assoc | TYPE_004_24_pred_or_assoc | OK     |
 *)

theory RefinementTypes
  imports Main
begin

(* BaseTy (matches Coq: Inductive BaseTy) *)
datatype base_ty =
    TyNat
  |     TyInt
  |     TyBool
  |     TyPtr

(* Pred (matches Coq: Inductive Pred) *)
datatype pred =
    PTrue
  |     PFalse
  |     PEqC
  |     PLtC
  |     PLeC
  |     PGtC
  |     PGeC
  |     PNeqC
  |     PAnd
  |     POr
  |     PNot
  |     PImpl

(* RefTy (matches Coq: Inductive RefTy) *)
datatype ref_ty =
    RBase
  |     RRefine
  |     RFun
  |     RDepFun

(* Expr (matches Coq: Inductive Expr) *)
datatype expr =
    EVal
  |     EVar
  |     EApp
  |     ELam
  |     EPlus
  |     EMult

(* pred_implies (matches Coq: Definition pred_implies) *)
definition pred_implies :: "bool" where
  "pred_implies \<equiv> forall v, sat_pred v p -> sat_pred v q"

(* inhabits_refinement (matches Coq: Definition inhabits_refinement) *)
definition inhabits_refinement :: "nat \<Rightarrow> BaseTy \<Rightarrow> Pred \<Rightarrow> bool" where
  "inhabits_refinement v b p \<equiv> sat_pred v p"

(* is_null (matches Coq: Definition is_null) *)
definition is_null :: "nat \<Rightarrow> bool" where
  "is_null p \<equiv> p = 0"

(* is_non_null (matches Coq: Definition is_non_null) *)
definition is_non_null :: "nat \<Rightarrow> bool" where
  "is_non_null p \<equiv> p <> 0"

(* bounds_pred (matches Coq: Definition bounds_pred) *)
definition bounds_pred :: "nat \<Rightarrow> Pred" where
  "bounds_pred len \<equiv> PAnd (PGeC 0) (PLtC len)"

(* non_null_pred (matches Coq: Definition non_null_pred) *)
definition non_null_pred :: "Pred" where
  "non_null_pred \<equiv> PNeqC 0"

(* array_index_pred (matches Coq: Definition array_index_pred) *)
definition array_index_pred :: "Array \<Rightarrow> Pred" where
  "array_index_pred arr \<equiv> PLtC (arr_len arr)"

(* positive_pred (matches Coq: Definition positive_pred) *)
definition positive_pred :: "Pred" where
  "positive_pred \<equiv> PGtC 0"

(* TYPE_004_01_refinement_subtyping (matches Coq) *)
lemma TYPE_004_01_refinement_subtyping: "\<forall> (b : BaseTy) (p q : Pred), pred_implies p q \<longrightarrow> refty_subtype (RRefine b p) (RRefine b q)"
  by auto

(* TYPE_004_02_refinement_introduction (matches Coq) *)
lemma TYPE_004_02_refinement_introduction: "\<forall> (v : nat) (b : BaseTy) (p : Pred), sat_pred v p \<longrightarrow> inhabits_refinement v b p"
  by auto

(* TYPE_004_03_refinement_elimination (matches Coq) *)
lemma TYPE_004_03_refinement_elimination: "\<forall> (b : BaseTy) (p : Pred), refty_subtype (RRefine b p) (RBase b)"
  by auto

(* TYPE_004_04_refinement_conjunction (matches Coq) *)
lemma TYPE_004_04_refinement_conjunction: "\<forall> (v : nat) (b : BaseTy) (p q : Pred), sat_pred v (PAnd p q) <-> (sat_pred v p \<and> sat_pred v q)"
  by auto

(* TYPE_004_05_dependent_function_refinement (matches Coq) *)
lemma TYPE_004_05_dependent_function_refinement: "\<forall> (b1 b2 : BaseTy) (p : Pred) (q : nat \<longrightarrow> Pred), (\<forall> x, sat_pred x p \<longrightarrow> \<exists> y, sat_pred y (q x)) \<longrightarrow> \<forall> (f : nat \<longrightarrow> nat) (arg : nat), sat_pred arg p \<longrightarrow> sat_pred (f arg) (q arg) \<longrightarrow> \<exists> result, sat_pred result (q arg)"
  by auto

(* TYPE_004_06_refinement_substitution (matches Coq) *)
lemma TYPE_004_06_refinement_substitution: "\<forall> (x : nat) (v : nat) (env : TyEnv) (e : Expr) (b : BaseTy) (p : Pred), has_type ((x, RRefine b p) :: env) e (RRefine b p) \<longrightarrow> sat_pred v p \<longrightarrow> \<forall> result, eval ((x, v) :: nil) e = Some result \<longrightarrow> sat_pred result p \<longrightarrow> inhabits_refinement result b p"
  by auto

(* TYPE_004_07_smt_decidability (matches Coq) *)
lemma TYPE_004_07_smt_decidability: "\<forall> (v : nat) (p : Pred), {sat_pred v p} + {~ sat_pred v p}"
  by auto

(* TYPE_004_08_bounds_checking (matches Coq) *)
lemma TYPE_004_08_bounds_checking: "\<forall> (len : nat) (idx : nat), sat_pred idx (bounds_pred len) \<longrightarrow> idx < len"
  by auto

(* TYPE_004_09_non_null_refinement (matches Coq) *)
lemma TYPE_004_09_non_null_refinement: "\<forall> (p : nat), sat_pred p non_null_pred \<longrightarrow> is_non_null p"
  by auto

(* TYPE_004_10_array_bounds_safety (matches Coq) *)
lemma TYPE_004_10_array_bounds_safety: "\<forall> (arr : Array) (i : nat), sat_pred i (array_index_pred arr) \<longrightarrow> i < length (arr_data arr)"
  by (cases rule: ‹_›.cases; simp)

(* TYPE_004_11_positive_refinement (matches Coq) *)
lemma TYPE_004_11_positive_refinement: "\<forall> (x y : nat), sat_pred x positive_pred \<longrightarrow> sat_pred y positive_pred \<longrightarrow> sat_pred (x * y) positive_pred"
  by (cases rule: ‹_›.cases; simp)

(* TYPE_004_12_refinement_preservation (matches Coq) *)
lemma TYPE_004_12_refinement_preservation: "\<forall> (e e' : Expr) (b : BaseTy) (p : Pred) (n : nat), step_clean e e' \<longrightarrow> e' = EVal n \<longrightarrow> sat_pred n p \<longrightarrow> has_type nil e' (RRefine b p)"
  by auto

(* TYPE_004_13_pred_true_satisfied (matches Coq) *)
lemma TYPE_004_13_pred_true_satisfied: "\<forall> v, sat_pred v PTrue"
  by auto

(* TYPE_004_14_pred_false_unsatisfied (matches Coq) *)
lemma TYPE_004_14_pred_false_unsatisfied: "\<forall> v, ~ sat_pred v PFalse"
  by auto

(* TYPE_004_15_pred_and_comm (matches Coq) *)
lemma TYPE_004_15_pred_and_comm: "\<forall> v p q, sat_pred v (PAnd p q) <-> sat_pred v (PAnd q p)"
  by auto

(* TYPE_004_16_pred_or_comm (matches Coq) *)
lemma TYPE_004_16_pred_or_comm: "\<forall> v p q, sat_pred v (POr p q) <-> sat_pred v (POr q p)"
  by auto

(* TYPE_004_17_pred_implies_ptrue (matches Coq) *)
lemma TYPE_004_17_pred_implies_ptrue: "\<forall> p, pred_implies p PTrue"
  by auto

(* TYPE_004_18_pred_pfalse_implies (matches Coq) *)
lemma TYPE_004_18_pred_pfalse_implies: "\<forall> p, pred_implies PFalse p"
  by auto

(* TYPE_004_19_subtype_refl (matches Coq) *)
lemma TYPE_004_19_subtype_refl: "\<forall> b, refty_subtype (RBase b) (RBase b)"
  by auto

(* TYPE_004_20_pred_double_neg (matches Coq) *)
lemma TYPE_004_20_pred_double_neg: "\<forall> v p, sat_pred v p \<longrightarrow> sat_pred v (PNot (PNot p))"
  by auto

(* TYPE_004_21_eval_val (matches Coq) *)
lemma TYPE_004_21_eval_val: "\<forall> env n, eval env (EVal n) = Some n"
  by simp

(* TYPE_004_22_pred_impl_refl (matches Coq) *)
lemma TYPE_004_22_pred_impl_refl: "\<forall> v p, sat_pred v (PImpl p p)"
  by auto

(* TYPE_004_23_pred_and_assoc (matches Coq) *)
lemma TYPE_004_23_pred_and_assoc: "\<forall> v p q r, sat_pred v (PAnd (PAnd p q) r) <-> sat_pred v (PAnd p (PAnd q r))"
  by auto

(* TYPE_004_24_pred_or_assoc (matches Coq) *)
lemma TYPE_004_24_pred_or_assoc: "\<forall> v p q r, sat_pred v (POr (POr p q) r) <-> sat_pred v (POr p (POr q r))"
  by auto

end
