(* Copyright (c) 2026 The RIINA Authors. All rights reserved. *)

(*
 * RIINA DependentTypes - Isabelle/HOL Port
 *
 * Auto-generated port of 02_FORMAL/coq/domains/DependentTypes.v (33 theorems).
 *
 * Generated by scripts/generate-multiprover.py
 *
 * Correspondence Table:
 *
 * | Coq Definition     | Isabelle Definition    | Status |
 * |--------------------|------------------------|--------|
 * | DTerm              | d_term                 | OK     |
 * | TYPE_005_01        | TYPE_005_01            | OK     |
 * | TYPE_005_02        | TYPE_005_02            | OK     |
 * | TYPE_005_03        | TYPE_005_03            | OK     |
 * | TYPE_005_04        | TYPE_005_04            | OK     |
 * | TYPE_005_05        | TYPE_005_05            | OK     |
 * | TYPE_005_06        | TYPE_005_06            | OK     |
 * | TYPE_005_07        | TYPE_005_07            | OK     |
 * | TYPE_005_08        | TYPE_005_08            | OK     |
 * | vec_cons_length_semantic | vec_cons_length_semantic | OK     |
 * | TYPE_005_09        | TYPE_005_09            | OK     |
 * | vec_head_nonempty_semantic | vec_head_nonempty_semantic | OK     |
 * | TYPE_005_10        | TYPE_005_10            | OK     |
 * | vec_dep_pattern_match | vec_dep_pattern_match  | OK     |
 * | TYPE_005_11        | TYPE_005_11            | OK     |
 * | transport_refl     | transport_refl         | OK     |
 * | transport_trans    | transport_trans        | OK     |
 * | TYPE_005_12        | TYPE_005_12            | OK     |
 * | dep_congruence     | dep_congruence         | OK     |
 * | congruence2        | congruence2            | OK     |
 * | lt_wf_aux          | lt_wf_aux              | OK     |
 * | lt_well_founded    | lt_well_founded        | OK     |
 * | TYPE_005_13        | TYPE_005_13            | OK     |
 * | nat_dep_ind        | nat_dep_ind            | OK     |
 * | strong_ind         | strong_ind             | OK     |
 * | TYPE_005_14        | TYPE_005_14            | OK     |
 * | dec_eq_nat         | dec_eq_nat             | OK     |
 * | dec_eq_bool        | dec_eq_bool            | OK     |
 * | dec_eq_prod        | dec_eq_prod            | OK     |
 * | dec_eq_option      | dec_eq_option          | OK     |
 * | dec_eq_list        | dec_eq_list            | OK     |
 * | dec_to_bool        | dec_to_bool            | OK     |
 * | nat_eq_reflect     | nat_eq_reflect         | OK     |
 * | uip_dec            | uip_dec                | OK     |
 *)

theory DependentTypes
  imports Main
begin

(* DTerm (matches Coq: Inductive DTerm) *)
datatype d_term =
    DVar
  |     DLam  (* λx:A.b *)
  |     DApp  (* f a *)
  |     DPair  (* (a, b) *)
  |     DFst  (* π₁ *)
  |     DSnd  (* π₂ *)
  |     DRefl  (* refl *)
  |     DJ  (* J eliminator *)
  |     DNil  (* nil : Vec A 0 *)
  |     DCons  (* cons : A → Vec A n → Vec A (S n) *)
  |     DHead  (* head : Vec A (S n) → A *)
  |     DTail  (* tail : Vec A (S n) → Vec A n *)

(* TYPE_005_01 (matches Coq) *)
lemma TYPE_005_01: "\<forall> (ctx : DCtx) (A : DTy 0) (B : nat \<longrightarrow> DTy 0), WfTy ctx A \<longrightarrow> (\<forall> n, WfTy (A :: ctx) (B n)) \<longrightarrow> WfTy ctx (DPi 0 A B)"
  by auto

(* TYPE_005_02 (matches Coq) *)
lemma TYPE_005_02: "\<forall> (ctx : DCtx) (A : DTy 0) (B : nat \<longrightarrow> DTy 0) (b : DTerm), WfTy ctx A \<longrightarrow> (\<forall> n, HasType (A :: ctx) b (B n)) \<longrightarrow> HasType ctx (DLam A b) (DPi 0 A B)"
  by auto

(* TYPE_005_03 (matches Coq) *)
lemma TYPE_005_03: "\<forall> (ctx : DCtx) (f a : DTerm) (A : DTy 0) (B : nat \<longrightarrow> DTy 0) (v : nat), HasType ctx f (DPi 0 A B) \<longrightarrow> HasType ctx a A \<longrightarrow> HasType ctx (DApp f a) (B v)"
  by auto

(* TYPE_005_04 (matches Coq) *)
lemma TYPE_005_04: "\<forall> (ctx : DCtx) (A : DTy 0) (B : nat \<longrightarrow> DTy 0), WfTy ctx A \<longrightarrow> (\<forall> n, WfTy (A :: ctx) (B n)) \<longrightarrow> WfTy ctx (DSigma 0 A B)"
  by auto

(* TYPE_005_05 (matches Coq) *)
lemma TYPE_005_05: "\<forall> (ctx : DCtx) (a b : DTerm) (A : DTy 0) (B : nat \<longrightarrow> DTy 0) (v : nat), HasType ctx a A \<longrightarrow> HasType ctx b (B v) \<longrightarrow> WfTy ctx (DSigma 0 A B) \<longrightarrow> HasType ctx (DPair a b) (DSigma 0 A B)"
  by auto

(* TYPE_005_06 (matches Coq) *)
lemma TYPE_005_06: "\<forall> (ctx : DCtx) (p : DTerm) (A : DTy 0) (B : nat \<longrightarrow> DTy 0), HasType ctx p (DSigma 0 A B) \<longrightarrow> HasType ctx (DFst p) A \<and> \<forall> v, HasType ctx (DSnd p) (B v)"
  by auto

(* TYPE_005_07 (matches Coq) *)
lemma TYPE_005_07: "\<forall> (ctx : DCtx) (A : DTy 0) (n : nat), WfTy ctx A \<longrightarrow> WfTy ctx (DVec 0 A n)"
  by auto

(* TYPE_005_08 (matches Coq) *)
lemma TYPE_005_08: "\<forall> (ctx : DCtx) (h t : DTerm) (A : DTy 0) (n : nat), HasType ctx h A \<longrightarrow> HasType ctx t (DVec 0 A n) \<longrightarrow> HasType ctx (DCons h t) (DVec 0 A (S n))"
  by auto

(* vec_cons_length_semantic (matches Coq) *)
lemma vec_cons_length_semantic: "\<forall> (A : Type) (n : nat) (h : A) (t : Vec A n), Vector.cons A h n t = Vector.cons A h n t \<and> \<exists> (v : Vec A (S n)), v = Vector.cons A h n t"
  by simp

(* TYPE_005_09 (matches Coq) *)
lemma TYPE_005_09: "\<forall> (ctx : DCtx) (v : DTerm) (A : DTy 0) (n : nat), HasType ctx v (DVec 0 A (S n)) \<longrightarrow> HasType ctx (DHead v) A"
  by auto

(* vec_head_nonempty_semantic (matches Coq) *)
lemma vec_head_nonempty_semantic: "\<forall> (A : Type) (n : nat) (v : Vec A (S n)), \<exists> (h : A), Vector.hd v = h"
  by simp

(* TYPE_005_10 (matches Coq) *)
lemma TYPE_005_10: "\<forall> (P : nat_motive) (base : P 0) (step : \<forall> n, P n \<longrightarrow> P (S n)) (m : nat), \<exists> (result : P m), result = nat_rect_dep P base step m"
  by simp

(* vec_dep_pattern_match (matches Coq) *)
lemma vec_dep_pattern_match: "\<forall> (A : Type) (P : \<forall> n, Vec A n \<longrightarrow> Type) (base : P 0 (Vector.nil A)) (step : \<forall> h n t, P n t \<longrightarrow> P (S n) (Vector.cons A h n t)) (n : nat) (v : Vec A n), \<exists> (result : P n v), result = Vector.t_rect A P base (fun h n t IH => step h n t IH) n v"
  by simp

(* TYPE_005_11 (matches Coq) *)
lemma TYPE_005_11: "\<forall> (A : Type) (P : A \<longrightarrow> Type) (x y : A) (eq : x = y) (px : P x), \<exists> (py : P y), py = transport P eq px"
  by simp

(* transport_refl (matches Coq) *)
lemma transport_refl: "\<forall> (A : Type) (P : A \<longrightarrow> Type) (x : A) (px : P x), transport P eq_refl px = px"
  by simp

(* transport_trans (matches Coq) *)
lemma transport_trans: "\<forall> (A : Type) (P : A \<longrightarrow> Type) (x y z : A) (eq1 : x = y) (eq2 : y = z) (px : P x), transport P eq2 (transport P eq1 px) = transport P (eq_trans eq1 eq2) px"
  by simp

(* TYPE_005_12 (matches Coq) *)
lemma TYPE_005_12: "\<forall> (A B : Type) (f : A \<longrightarrow> B) (x y : A), x = y \<longrightarrow> f x = f y"
  by simp

(* dep_congruence (matches Coq) *)
lemma dep_congruence: "\<forall> (A : Type) (B : A \<longrightarrow> Type) (f : \<forall> a, B a) (x y : A) (eq : x = y), transport B eq (f x) = f y"
  by simp

(* congruence2 (matches Coq) *)
lemma congruence2: "\<forall> (A B C : Type) (f : A \<longrightarrow> B \<longrightarrow> C) (x1 x2 : A) (y1 y2 : B), x1 = x2 \<longrightarrow> y1 = y2 \<longrightarrow> f x1 y1 = f x2 y2"
  by simp

(* lt_wf_aux (matches Coq) *)
lemma lt_wf_aux: "\<forall> n m, m < n \<longrightarrow> Acc lt m"
  by auto

(* lt_well_founded (matches Coq) *)
lemma lt_well_founded: "well_founded lt"
  by auto

(* TYPE_005_13 (matches Coq) *)
lemma TYPE_005_13: "\<forall> (A : Type) (R : A \<longrightarrow> A \<longrightarrow> Prop) (P : A \<longrightarrow> Type), well_founded R \<longrightarrow> (\<forall> x, (\<forall> y, R y x \<longrightarrow> P y) \<longrightarrow> P x) \<longrightarrow> \<forall> x, P x"
  by auto

(* nat_dep_ind (matches Coq) *)
lemma nat_dep_ind: "\<forall> (P : nat \<longrightarrow> Type), P 0 \<longrightarrow> (\<forall> n, P n \<longrightarrow> P (S n)) \<longrightarrow> \<forall> n, P n"
  by auto

(* strong_ind (matches Coq) *)
lemma strong_ind: "\<forall> (P : nat \<longrightarrow> Prop), (\<forall> n, (\<forall> m, m < n \<longrightarrow> P m) \<longrightarrow> P n) \<longrightarrow> \<forall> n, P n"
  by auto

(* TYPE_005_14 (matches Coq) *)
lemma TYPE_005_14: "\<forall> (A : Type), (\<forall> x y : A, {x = y} + {x \<noteq> y}) \<longrightarrow> \<forall> (x y : A), Dec (x = y)"
  by auto

(* dec_eq_nat (matches Coq) *)
lemma dec_eq_nat: "\<forall> (x y : nat), Dec (x = y)"
  by auto

(* dec_eq_bool (matches Coq) *)
lemma dec_eq_bool: "\<forall> (x y : bool), Dec (x = y)"
  by simp

(* dec_eq_prod (matches Coq) *)
lemma dec_eq_prod: "\<forall> (A B : Type), (\<forall> x y : A, Dec (x = y)) \<longrightarrow> (\<forall> x y : B, Dec (x = y)) \<longrightarrow> \<forall> (p1 p2 : A * B), Dec (p1 = p2)"
  by auto

(* dec_eq_option (matches Coq) *)
lemma dec_eq_option: "\<forall> (A : Type), (\<forall> x y : A, Dec (x = y)) \<longrightarrow> \<forall> (o1 o2 : option A), Dec (o1 = o2)"
  by auto

(* dec_eq_list (matches Coq) *)
lemma dec_eq_list: "\<forall> (A : Type), (\<forall> x y : A, Dec (x = y)) \<longrightarrow> \<forall> (l1 l2 : list A), Dec (l1 = l2)"
  by auto

(* dec_to_bool (matches Coq) *)
lemma dec_to_bool: "\<forall> (P : Prop), Dec P \<longrightarrow> {P} + {~P}"
  by auto

(* nat_eq_reflect (matches Coq) *)
lemma nat_eq_reflect: "\<forall> (x y : nat), Nat.eqb x y = True <-> x = y"
  by auto

(* uip_dec (matches Coq) *)
lemma uip_dec: "\<forall> (A : Type), (\<forall> x y : A, Dec (x = y)) \<longrightarrow> \<forall> (x : A) (p : x = x), p = eq_refl"
  by auto

end
