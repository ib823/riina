(* Copyright (c) 2026 The RIINA Authors. All rights reserved. *)

(*
 * RIINA LexOrder - Isabelle/HOL Port
 *
 * Auto-generated port of 02_FORMAL/coq/properties/LexOrder.v (16 theorems).
 *
 * Generated by scripts/generate-multiprover.py
 *
 * Correspondence Table:
 *
 * | Coq Definition     | Isabelle Definition    | Status |
 * |--------------------|------------------------|--------|
 * | lex_lt             | lex_lt                 | OK     |
 * | step_ty_lt         | step_ty_lt             | OK     |
 * | triple_lt          | triple_lt              | OK     |
 * | lex_lt_wf          | lex_lt_wf              | OK     |
 * | lex_induction      | lex_induction          | OK     |
 * | lex_lt_left        | lex_lt_left            | OK     |
 * | lex_lt_right       | lex_lt_right           | OK     |
 * | step_ty_lt_wf      | step_ty_lt_wf          | OK     |
 * | step_ty_induction  | step_ty_induction      | OK     |
 * | step_ty_lt_step    | step_ty_lt_step        | OK     |
 * | step_ty_lt_ty      | step_ty_lt_ty          | OK     |
 * | step_ty_lt_fn_arg  | step_ty_lt_fn_arg      | OK     |
 * | step_ty_lt_fn_res  | step_ty_lt_fn_res      | OK     |
 * | step_ty_lt_prod_left | step_ty_lt_prod_left   | OK     |
 * | step_ty_lt_prod_right | step_ty_lt_prod_right  | OK     |
 * | step_ty_lt_sum_left | step_ty_lt_sum_left    | OK     |
 * | step_ty_lt_sum_right | step_ty_lt_sum_right   | OK     |
 * | step_ty_lt_step_any | step_ty_lt_step_any    | OK     |
 * | triple_lt_wf       | triple_lt_wf           | OK     |
 *)

theory LexOrder
  imports Main
begin

(* lex_lt (matches Coq: Definition lex_lt) *)
definition lex_lt :: "bool" where
  "lex_lt \<equiv> let (m1, m2) := p1 in
  let (n1, n2) := p2 in
  m1 < n1 \/ (m1 = n1 /\ m2 < n2)"

(* step_ty_lt (matches Coq: Definition step_ty_lt) *)
definition step_ty_lt :: "bool" where
  "step_ty_lt \<equiv> let (n1, T1) := p1 in
  let (n2, T2) := p2 in
  n1 < n2 \/ (n1 = n2 /\ ty_size T1 < ty_size T2)"

(* triple_lt (matches Coq: Definition triple_lt) *)
definition triple_lt :: "bool" where
  "triple_lt \<equiv> let '(a1, b1, c1) := p1 in
  let '(a2, b2, c2) := p2 in
  a1 < a2 \/
  (a1 = a2 /\ b1 < b2) \/
  (a1 = a2 /\ b1 = b2 /\ c1 < c2)"

(* Direct proof using nested well-founded induction *)
(* lex_lt_wf (matches Coq) *)
lemma lex_lt_wf: "well_founded lex_lt"
  by auto

(* lex_induction (matches Coq) *)
lemma lex_induction: "\<forall> (P : nat \<longrightarrow> nat \<longrightarrow> Prop), (\<forall> n m, (\<forall> n' m', lex_lt (n', m') (n, m) \<longrightarrow> P n' m') \<longrightarrow> P n m) \<longrightarrow> \<forall> n m, P n m"
  by auto

(* lex_lt_left (matches Coq) *)
lemma lex_lt_left: "\<forall> n m n' m', n' < n \<longrightarrow> lex_lt (n', m') (n, m)"
  by auto

(* lex_lt_right (matches Coq) *)
lemma lex_lt_right: "\<forall> n m m', m' < m \<longrightarrow> lex_lt (n, m') (n, m)"
  by auto

(* step_ty_lt is well-founded *)
(* step_ty_lt_wf (matches Coq) *)
lemma step_ty_lt_wf: "well_founded step_ty_lt"
  by auto

(* Induction principle for step-type pairs *)
(* step_ty_induction (matches Coq) *)
lemma step_ty_induction: "\<forall> (P : nat \<longrightarrow> ty \<longrightarrow> Prop), (\<forall> n T, (\<forall> n' T', step_ty_lt (n', T') (n, T) \<longrightarrow> P n' T') \<longrightarrow> P n T) \<longrightarrow> \<forall> n T, P n T"
  by auto

(* Decreasing step index (the primary decrease for TFn) *)
(* step_ty_lt_step (matches Coq) *)
lemma step_ty_lt_step: "\<forall> n T T', step_ty_lt (n, T') (S n, T)"
  by simp

(* Decreasing type size at same step (for recursive types) *)
(* step_ty_lt_ty (matches Coq) *)
lemma step_ty_lt_ty: "\<forall> n T T', ty_size T' < ty_size T \<longrightarrow> step_ty_lt (n, T') (n, T)"
  by auto

(* TFn argument is smaller *)
(* step_ty_lt_fn_arg (matches Coq) *)
lemma step_ty_lt_fn_arg: "\<forall> n T1 T2 eff, step_ty_lt (n, T1) (n, TFn T1 T2 eff)"
  by auto

(* TFn result is smaller *)
(* step_ty_lt_fn_res (matches Coq) *)
lemma step_ty_lt_fn_res: "\<forall> n T1 T2 eff, step_ty_lt (n, T2) (n, TFn T1 T2 eff)"
  by auto

(* TProd components are smaller *)
(* step_ty_lt_prod_left (matches Coq) *)
lemma step_ty_lt_prod_left: "\<forall> n T1 T2, step_ty_lt (n, T1) (n, TProd T1 T2)"
  by auto

(* step_ty_lt_prod_right (matches Coq) *)
lemma step_ty_lt_prod_right: "\<forall> n T1 T2, step_ty_lt (n, T2) (n, TProd T1 T2)"
  by auto

(* TSum components are smaller *)
(* step_ty_lt_sum_left (matches Coq) *)
lemma step_ty_lt_sum_left: "\<forall> n T1 T2, step_ty_lt (n, T1) (n, TSum T1 T2)"
  by auto

(* step_ty_lt_sum_right (matches Coq) *)
lemma step_ty_lt_sum_right: "\<forall> n T1 T2, step_ty_lt (n, T2) (n, TSum T1 T2)"
  by auto

(* Step decrease combined with type *)
(* step_ty_lt_step_any (matches Coq) *)
lemma step_ty_lt_step_any: "\<forall> n n' T T', n' < n \<longrightarrow> step_ty_lt (n', T') (n, T)"
  by auto

(* triple_lt_wf (matches Coq) *)
lemma triple_lt_wf: "well_founded triple_lt"
  by auto

end
