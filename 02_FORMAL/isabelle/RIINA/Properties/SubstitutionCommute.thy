(* SPDX-License-Identifier: MPL-2.0 *)
(* Copyright (c) 2026 The RIINA Authors. See AUTHORS file. *)

(*
 * RIINA SubstitutionCommute - Isabelle/HOL Port
 *
 * Auto-generated port of 02_FORMAL/coq/properties/SubstitutionCommute.v (11 theorems).
 *
 * Generated by scripts/generate-multiprover.py
 *
 * Correspondence Table:
 *
 * | Coq Definition     | Isabelle Definition    | Status |
 * |--------------------|------------------------|--------|
 * | id_rho_sc          | id_rho_sc              | OK     |
 * | extend_rho_sc      | extend_rho_sc          | OK     |
 * | closed_expr_sc     | closed_expr_sc         | OK     |
 * | closed_rho_sc      | closed_rho_sc          | OK     |
 * | extend_rho_sc_same | extend_rho_sc_same     | OK     |
 * | extend_rho_sc_diff | extend_rho_sc_diff     | OK     |
 * | extend_rho_sc_shadow | extend_rho_sc_shadow   | OK     |
 * | extend_rho_sc_comm | extend_rho_sc_comm     | OK     |
 * | subst_not_free_sc  | subst_not_free_sc      | OK     |
 * | subst_closed_sc    | subst_closed_sc        | OK     |
 * | closed_unit_sub    | closed_unit_sub        | OK     |
 * | closed_bool_sub    | closed_bool_sub        | OK     |
 * | closed_int_sub     | closed_int_sub         | OK     |
 * | closed_string_sub  | closed_string_sub      | OK     |
 * | closed_loc_sub     | closed_loc_sub         | OK     |
 *)

theory SubstitutionCommute
  imports Main
begin

(* id_rho_sc (matches Coq: Definition id_rho_sc) *)
definition id_rho_sc :: "subst_rho_sc" where
  "id_rho_sc \<equiv> fun x => EVar x"

(* extend_rho_sc (matches Coq: Definition extend_rho_sc) *)
definition extend_rho_sc :: "subst_rho_sc \<Rightarrow> ident \<Rightarrow> expr \<Rightarrow> subst_rho_sc" where
  "extend_rho_sc ρ x v \<equiv> fun y => if String"

(* closed_expr_sc (matches Coq: Definition closed_expr_sc) *)
definition closed_expr_sc :: "expr \<Rightarrow> bool" where
  "closed_expr_sc e \<equiv> forall x, ~ free_in x e"

(* closed_rho_sc (matches Coq: Definition closed_rho_sc) *)
definition closed_rho_sc :: "subst_rho_sc \<Rightarrow> bool" where
  "closed_rho_sc ρ \<equiv> forall x, closed_expr_sc (ρ x)"

(* ----------------------------------------------------------------- *)
(* extend_rho_sc_same (matches Coq) *)
lemma extend_rho_sc_same: "\<forall> ρ x v, extend_rho_sc ρ x v x = v"
  by simp

(* extend_rho_sc_diff (matches Coq) *)
lemma extend_rho_sc_diff: "\<forall> ρ x y v, x \<noteq> y \<longrightarrow> extend_rho_sc ρ x v y = ρ y"
  by simp

(* extend_rho_sc_shadow (matches Coq) *)
lemma extend_rho_sc_shadow: "\<forall> ρ x v1 v2, extend_rho_sc (extend_rho_sc ρ x v1) x v2 = extend_rho_sc ρ x v2"
  by simp

(* extend_rho_sc_comm (matches Coq) *)
lemma extend_rho_sc_comm: "\<forall> ρ x y vx vy, x \<noteq> y \<longrightarrow> extend_rho_sc (extend_rho_sc ρ x vx) y vy = extend_rho_sc (extend_rho_sc ρ y vy) x vx"
  by simp

(* ----------------------------------------------------------------- *)
(* subst_not_free_sc (matches Coq) *)
lemma subst_not_free_sc: "\<forall> x v e, ~ free_in x e \<longrightarrow> [x := v] e = e"
  by (cases rule: ‹_›.cases; simp)

(* subst_closed_sc (matches Coq) *)
lemma subst_closed_sc: "\<forall> x v e, closed_expr_sc e \<longrightarrow> [x := v] e = e"
  by auto

(* Base type closed lemmas *)
(* closed_unit_sub (matches Coq) *)
lemma closed_unit_sub: "closed_expr_sc EUnit"
  by auto

(* closed_bool_sub (matches Coq) *)
lemma closed_bool_sub: "\<forall> b, closed_expr_sc (EBool b)"
  by auto

(* closed_int_sub (matches Coq) *)
lemma closed_int_sub: "\<forall> n, closed_expr_sc (EInt n)"
  by auto

(* closed_string_sub (matches Coq) *)
lemma closed_string_sub: "\<forall> s, closed_expr_sc (EString s)"
  by auto

(* closed_loc_sub (matches Coq) *)
lemma closed_loc_sub: "\<forall> l, closed_expr_sc (ELoc l)"
  by auto

end
