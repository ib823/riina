(* Copyright (c) 2026 The RIINA Authors. All rights reserved. *)

(*
 * RIINA TypeMeasure - Isabelle/HOL Port
 *
 * Auto-generated port of 02_FORMAL/coq/properties/TypeMeasure.v (29 theorems).
 *
 * Generated by scripts/generate-multiprover.py
 *
 * Correspondence Table:
 *
 * | Coq Definition     | Isabelle Definition    | Status |
 * |--------------------|------------------------|--------|
 * | ty_size_lt         | ty_size_lt             | OK     |
 * | ty_size_pos        | ty_size_pos            | OK     |
 * | ty_size_fn_arg     | ty_size_fn_arg         | OK     |
 * | ty_size_fn_res     | ty_size_fn_res         | OK     |
 * | ty_size_prod_left  | ty_size_prod_left      | OK     |
 * | ty_size_prod_right | ty_size_prod_right     | OK     |
 * | ty_size_sum_left   | ty_size_sum_left       | OK     |
 * | ty_size_sum_right  | ty_size_sum_right      | OK     |
 * | ty_size_ref_content | ty_size_ref_content    | OK     |
 * | ty_size_secret_content | ty_size_secret_content | OK     |
 * | ty_size_proof_content | ty_size_proof_content  | OK     |
 * | ty_size_lt_wf      | ty_size_lt_wf          | OK     |
 * | ty_size_induction  | ty_size_induction      | OK     |
 * | first_order_no_fn  | first_order_no_fn      | OK     |
 * | first_order_decidable | first_order_decidable  | OK     |
 * | first_order_prod_inv | first_order_prod_inv   | OK     |
 * | first_order_sum_inv | first_order_sum_inv    | OK     |
 * | first_order_ref_inv | first_order_ref_inv    | OK     |
 * | first_order_secret_inv | first_order_secret_inv | OK     |
 * | first_order_proof_inv | first_order_proof_inv  | OK     |
 * | fo_compound_depth_prod | fo_compound_depth_prod | OK     |
 * | fo_compound_depth_sum | fo_compound_depth_sum  | OK     |
 * | fo_compound_depth_prod_left | fo_compound_depth_prod_left | OK     |
 * | fo_compound_depth_prod_right | fo_compound_depth_prod_right | OK     |
 * | fo_compound_depth_sum_left | fo_compound_depth_sum_left | OK     |
 * | fo_compound_depth_sum_right | fo_compound_depth_sum_right | OK     |
 * | fo_compound_depth_primitive | fo_compound_depth_primitive | OK     |
 * | ty_depth_fn_arg    | ty_depth_fn_arg        | OK     |
 * | ty_depth_fn_res    | ty_depth_fn_res        | OK     |
 * | first_order_base_depth | first_order_base_depth | OK     |
 *)

theory TypeMeasure
  imports Main
begin

(* Boolean conjunction helper (matches Coq: andb_true_iff) *)
lemma andb_true_iff: "(a \<and> b) = True \<longleftrightarrow> a = True \<and> b = True"
  by auto

(* ty_size_lt (matches Coq: Definition ty_size_lt) *)
definition ty_size_lt :: "bool" where
  "ty_size_lt \<equiv> ty_size T1 < ty_size T2"

(* ty_size_pos (matches Coq) *)
lemma ty_size_pos: "\<forall> T, ty_size T > 0"
  by simp

(* TFn argument is strictly smaller *)
(* ty_size_fn_arg (matches Coq) *)
lemma ty_size_fn_arg: "\<forall> T1 T2 eff, ty_size T1 < ty_size (TFn T1 T2 eff)"
  by simp

(* TFn result is strictly smaller *)
(* ty_size_fn_res (matches Coq) *)
lemma ty_size_fn_res: "\<forall> T1 T2 eff, ty_size T2 < ty_size (TFn T1 T2 eff)"
  by simp

(* TProd left is strictly smaller *)
(* ty_size_prod_left (matches Coq) *)
lemma ty_size_prod_left: "\<forall> T1 T2, ty_size T1 < ty_size (TProd T1 T2)"
  by simp

(* TProd right is strictly smaller *)
(* ty_size_prod_right (matches Coq) *)
lemma ty_size_prod_right: "\<forall> T1 T2, ty_size T2 < ty_size (TProd T1 T2)"
  by simp

(* TSum left is strictly smaller *)
(* ty_size_sum_left (matches Coq) *)
lemma ty_size_sum_left: "\<forall> T1 T2, ty_size T1 < ty_size (TSum T1 T2)"
  by simp

(* TSum right is strictly smaller *)
(* ty_size_sum_right (matches Coq) *)
lemma ty_size_sum_right: "\<forall> T1 T2, ty_size T2 < ty_size (TSum T1 T2)"
  by simp

(* TRef content is strictly smaller *)
(* ty_size_ref_content (matches Coq) *)
lemma ty_size_ref_content: "\<forall> T sl, ty_size T < ty_size (TRef T sl)"
  by simp

(* TSecret content is strictly smaller *)
(* ty_size_secret_content (matches Coq) *)
lemma ty_size_secret_content: "\<forall> T, ty_size T < ty_size (TSecret T)"
  by simp

(* TProof content is strictly smaller *)
(* ty_size_proof_content (matches Coq) *)
lemma ty_size_proof_content: "\<forall> T, ty_size T < ty_size (TProof T)"
  by simp

(* ty_size_lt is well-founded (inherits from lt on nat) *)
(* ty_size_lt_wf (matches Coq) *)
lemma ty_size_lt_wf: "well_founded ty_size_lt"
  by auto

(* Induction principle based on type size *)
(* ty_size_induction (matches Coq) *)
lemma ty_size_induction: "\<forall> (P : ty \<longrightarrow> Prop), (\<forall> T, (\<forall> T', ty_size T' < ty_size T \<longrightarrow> P T') \<longrightarrow> P T) \<longrightarrow> \<forall> T, P T"
  by auto

(* First-order types contain no TFn *)
(* first_order_no_fn (matches Coq) *)
lemma first_order_no_fn: "\<forall> T T1 T2 eff, first_order_type T = True \<longrightarrow> T \<noteq> TFn T1 T2 eff"
  by auto

(* First-order is decidable *)
(* first_order_decidable (matches Coq) *)
lemma first_order_decidable: "\<forall> T, {first_order_type T = True} + {first_order_type T = False}"
  by auto

(* First-order subtypes of first-order types *)
(* first_order_prod_inv (matches Coq) *)
lemma first_order_prod_inv: "\<forall> T1 T2, first_order_type (TProd T1 T2) = True \<longrightarrow> first_order_type T1 = True \<and> first_order_type T2 = True"
  by auto

(* first_order_sum_inv (matches Coq) *)
lemma first_order_sum_inv: "\<forall> T1 T2, first_order_type (TSum T1 T2) = True \<longrightarrow> first_order_type T1 = True \<and> first_order_type T2 = True"
  by auto

(* first_order_ref_inv (matches Coq) *)
lemma first_order_ref_inv: "\<forall> T sl, first_order_type (TRef T sl) = True \<longrightarrow> first_order_type T = True"
  by auto

(* first_order_secret_inv (matches Coq) *)
lemma first_order_secret_inv: "\<forall> T, first_order_type (TSecret T) = True \<longrightarrow> first_order_type T = True"
  by auto

(* first_order_proof_inv (matches Coq) *)
lemma first_order_proof_inv: "\<forall> T, first_order_type (TProof T) = True \<longrightarrow> first_order_type T = True"
  by auto

(* fo_compound_depth for TProd *)
(* fo_compound_depth_prod (matches Coq) *)
lemma fo_compound_depth_prod: "\<forall> T1 T2, fo_compound_depth (TProd T1 T2) = 1 + Nat.max (fo_compound_depth T1) (fo_compound_depth T2)"
  by simp

(* fo_compound_depth for TSum *)
(* fo_compound_depth_sum (matches Coq) *)
lemma fo_compound_depth_sum: "\<forall> T1 T2, fo_compound_depth (TSum T1 T2) = 1 + Nat.max (fo_compound_depth T1) (fo_compound_depth T2)"
  by simp

(* Component depths are less than parent *)
(* fo_compound_depth_prod_left (matches Coq) *)
lemma fo_compound_depth_prod_left: "\<forall> T1 T2, fo_compound_depth T1 < fo_compound_depth (TProd T1 T2)"
  by simp

(* fo_compound_depth_prod_right (matches Coq) *)
lemma fo_compound_depth_prod_right: "\<forall> T1 T2, fo_compound_depth T2 < fo_compound_depth (TProd T1 T2)"
  by simp

(* fo_compound_depth_sum_left (matches Coq) *)
lemma fo_compound_depth_sum_left: "\<forall> T1 T2, fo_compound_depth T1 < fo_compound_depth (TSum T1 T2)"
  by simp

(* fo_compound_depth_sum_right (matches Coq) *)
lemma fo_compound_depth_sum_right: "\<forall> T1 T2, fo_compound_depth T2 < fo_compound_depth (TSum T1 T2)"
  by simp

(* Primitive and simple types have depth 0 *)
(* fo_compound_depth_primitive (matches Coq) *)
lemma fo_compound_depth_primitive: "\<forall> T, match T with | TProd _ _ | TSum _ _ => False | _ => True end \<longrightarrow> fo_compound_depth T = 0"
  by (cases rule: ‹_›.cases; simp)

(* Depth subtype lemmas *)
(* ty_depth_fn_arg (matches Coq) *)
lemma ty_depth_fn_arg: "\<forall> T1 T2 eff, ty_depth T1 < ty_depth (TFn T1 T2 eff)"
  by simp

(* ty_depth_fn_res (matches Coq) *)
lemma ty_depth_fn_res: "\<forall> T1 T2 eff, ty_depth T2 < ty_depth (TFn T1 T2 eff)"
  by simp

(* First-order types have depth 0 for base types *)
(* first_order_base_depth (matches Coq) *)
lemma first_order_base_depth: "\<forall> T, first_order_type T = True \<longrightarrow> ty_depth T \<ge> 0"
  by simp

end
