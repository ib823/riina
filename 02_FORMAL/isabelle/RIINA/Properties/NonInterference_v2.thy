(* SPDX-License-Identifier: MPL-2.0 *)
(* Copyright (c) 2026 The RIINA Authors. See AUTHORS file. *)

(*
 * RIINA NonInterference_v2 - Isabelle/HOL Port
 *
 * Auto-generated port of 02_FORMAL/coq/properties/NonInterference_v2.v (50 theorems).
 *
 * Generated by scripts/generate-multiprover.py
 *
 * Correspondence Table:
 *
 * | Coq Definition     | Isabelle Definition    | Status |
 * |--------------------|------------------------|--------|
 * | is_low             | is_low                 | OK     |
 * | is_low_dec         | is_low_dec             | OK     |
 * | closed_expr        | closed_expr            | OK     |
 * | stores_agree_low_fo | stores_agree_low_fo    | OK     |
 * | val_rel_at_type_n  | val_rel_at_type_n      | OK     |
 * | store_vals_rel     | store_vals_rel         | OK     |
 * | combined_step_up   | combined_step_up       | OK     |
 * | val_rel            | val_rel                | OK     |
 * | store_rel          | store_rel              | OK     |
 * | exp_rel            | exp_rel                | OK     |
 * | is_low_dec_correct | is_low_dec_correct     | OK     |
 * | typing_nil_implies_closed | typing_nil_implies_closed | OK     |
 * | val_rel_at_type_fo_refl | val_rel_at_type_fo_refl | OK     |
 * | val_rel_at_type_fo_trivial | val_rel_at_type_fo_trivial | OK     |
 * | val_rel_at_type_n_S | val_rel_at_type_n_S    | OK     |
 * | val_rel_n_0_unfold | val_rel_n_0_unfold     | OK     |
 * | val_rel_n_S_unfold | val_rel_n_S_unfold     | OK     |
 * | val_rel_n_SS_unfold | val_rel_n_SS_unfold    | OK     |
 * | store_rel_n_0_unfold | store_rel_n_0_unfold   | OK     |
 * | store_rel_n_S_unfold | store_rel_n_S_unfold   | OK     |
 * | val_rel_at_type_fo_equiv | val_rel_at_type_fo_equiv | OK     |
 * | val_rel_n_to_0     | val_rel_n_to_0         | OK     |
 * | val_rel_n_step_up_fo | val_rel_n_step_up_fo   | OK     |
 * | val_rel_n_mono_fo  | val_rel_n_mono_fo      | OK     |
 * | val_rel_n_fo_equiv | val_rel_n_fo_equiv     | OK     |
 * | val_rel_n_value    | val_rel_n_value        | OK     |
 * | val_rel_n_closed   | val_rel_n_closed       | OK     |
 * | val_rel_n_typing   | val_rel_n_typing       | OK     |
 * | val_rel_n_prod_structure | val_rel_n_prod_structure | OK     |
 * | val_rel_n_bool_structure | val_rel_n_bool_structure | OK     |
 * | val_rel_n_sum_structure | val_rel_n_sum_structure | OK     |
 * | val_rel_n_mono     | val_rel_n_mono         | OK     |
 * | store_rel_n_mono   | store_rel_n_mono       | OK     |
 * | pair_typing_pure_inv | pair_typing_pure_inv   | OK     |
 * | exp_rel_step1_fst  | exp_rel_step1_fst      | OK     |
 * | exp_rel_step1_snd  | exp_rel_step1_snd      | OK     |
 * | exp_rel_step1_if   | exp_rel_step1_if       | OK     |
 * | exp_rel_step1_case | exp_rel_step1_case     | OK     |
 * | exp_rel_step1_let  | exp_rel_step1_let      | OK     |
 * | exp_rel_step1_handle | exp_rel_step1_handle   | OK     |
 * | exp_rel_step1_app  | exp_rel_step1_app      | OK     |
 * | preservation_store_wf | preservation_store_wf  | OK     |
 * | store_wf_to_has_values | store_wf_to_has_values | OK     |
 * | preservation_store_has_values | preservation_store_has_values | OK     |
 * | val_rel_at_type_fo_step_invariant | val_rel_at_type_fo_step_invariant | OK     |
 * | val_rel_at_type_step_up_with_IH | val_rel_at_type_step_up_with_IH | OK     |
 * | combined_step_up_val_wrap | combined_step_up_val_wrap | OK     |
 * | store_rel_n_step_up_from_IH | store_rel_n_step_up_from_IH | OK     |
 * | store_rel_n_step_up_with_val_IH | store_rel_n_step_up_with_val_IH | OK     |
 * | combined_step_up_all | combined_step_up_all   | OK     |
 * | val_rel_n_step_up_by_type | val_rel_n_step_up_by_type | OK     |
 * | val_rel_n_step_up  | val_rel_n_step_up      | OK     |
 * | store_rel_n_step_up | store_rel_n_step_up    | OK     |
 * | store_vals_rel_mono | store_vals_rel_mono    | OK     |
 * | store_vals_rel_step_up | store_vals_rel_step_up | OK     |
 * | exp_rel_n_base     | exp_rel_n_base         | OK     |
 * | val_rel_n_0_unit   | val_rel_n_0_unit       | OK     |
 * | val_rel_n_unit     | val_rel_n_unit         | OK     |
 * | exp_rel_n_unit     | exp_rel_n_unit         | OK     |
 * | val_rel_at_type_TFn_step_0_bridge | val_rel_at_type_TFn_step_0_bridge | OK     |
 *)

theory NonInterference_v2
  imports Main
begin

(* Boolean conjunction helper (matches Coq: andb_true_iff) *)
lemma andb_true_iff: "(a \<and> b) = True \<longleftrightarrow> a = True \<and> b = True"
  by auto

(* is_low (matches Coq: Definition is_low) *)
definition is_low :: "security_level \<Rightarrow> bool" where
  "is_low l \<equiv> sec_leq l observer"

(* is_low_dec (matches Coq: Definition is_low_dec) *)
definition is_low_dec :: "security_level \<Rightarrow> bool" where
  "is_low_dec l \<equiv> sec_leq_dec l observer"

(* closed_expr (matches Coq: Definition closed_expr) *)
definition closed_expr :: "expr \<Rightarrow> bool" where
  "closed_expr e \<equiv> forall x, ~ free_in x e"

(* stores_agree_low_fo (matches Coq: Definition stores_agree_low_fo) *)
definition stores_agree_low_fo :: "store_ty \<Rightarrow> bool" where
  "stores_agree_low_fo Σ \<equiv> forall l T sl,
    store_ty_lookup l Σ = Some (T, sl) ->
    first_order_type T = true ->
    is_low sl ->
    forall v1 v2,
      store_lookup l st1 = Some v1 ->
      store_lookup l st2 = Some v2 ->
      val_rel_at_type_fo T v1 v2"

(* val_rel_at_type_n (matches Coq: Definition val_rel_at_type_n) *)
fun val_rel_at_type_n :: "nat \<Rightarrow> store_ty \<Rightarrow> ty \<Rightarrow> bool" where
  "val_rel_at_type_n 0 = True"

(* store_vals_rel (matches Coq: Definition store_vals_rel) *)
definition store_vals_rel :: "nat \<Rightarrow> store_ty \<Rightarrow> bool" where
  "store_vals_rel n Σ \<equiv> forall l T sl,
    store_ty_lookup l Σ = Some (T, sl) ->
    exists v1 v2,
      store_lookup l st1 = Some v1 /\
      store_lookup l st2 = Some v2 /\
      val_rel_n n Σ T v1 v2"

(* combined_step_up (matches Coq: Definition combined_step_up) *)
definition combined_step_up :: "nat \<Rightarrow> bool" where
  "combined_step_up n \<equiv> (forall T Σ v1 v2,
     val_rel_n n Σ T v1 v2 ->
     has_type nil Σ Public v1 T EffectPure ->
     has_type nil Σ Public v2 T EffectPure ->
     val_rel_n (S n) Σ T v1 v2) /\
  (forall Σ st1 st2,
     store_rel_n n Σ st1 st2 ->
     store_wf Σ st1 ->
     store_wf Σ st2 ->
     store_has_values st1 ->
     store_has_values st2 ->
     stores_agree_low_fo Σ st1 st2 ->  (* FO bootstrap precondition *)
     store_rel_n (S n) Σ st1 st2)"

(* val_rel (matches Coq: Definition val_rel) *)
definition val_rel :: "store_ty \<Rightarrow> ty \<Rightarrow> bool" where
  "val_rel Σ T \<equiv> forall n, val_rel_n n Σ T v1 v2"

(* store_rel (matches Coq: Definition store_rel) *)
definition store_rel :: "store_ty \<Rightarrow> bool" where
  "store_rel Σ \<equiv> forall n, store_rel_n n Σ st1 st2"

(* exp_rel (matches Coq: Definition exp_rel) *)
definition exp_rel :: "store_ty \<Rightarrow> ty \<Rightarrow> bool" where
  "exp_rel Σ T \<equiv> forall n, exp_rel_n n Σ T e1 e2"

(* is_low and is_low_dec equivalence *)
(* is_low_dec_correct (matches Coq) *)
lemma is_low_dec_correct: "\<forall> l, is_low_dec l = True <-> is_low l"
  by auto

(* Helper: typing in nil context implies closed.
    Uses free_in_context from Preservation.v *)
(* typing_nil_implies_closed (matches Coq) *)
lemma typing_nil_implies_closed: "\<forall> Σ Δ e T ε, has_type nil Σ Δ e T ε \<longrightarrow> closed_expr e"
  by auto

(* val_rel_at_type_fo is reflexive for well-typed values.
    This is used when v1 = v2 (from stores_agree_low_fo).
    Requires typing to ensure the value matches the type structure. *)
(* val_rel_at_type_fo_refl (matches Coq) *)
lemma val_rel_at_type_fo_refl: "\<forall> T Σ v, first_order_type T = True \<longrightarrow> value v \<longrightarrow> has_type nil Σ Public v T EffectPure \<longrightarrow> val_rel_at_type_fo T v v"
  by (cases rule: ‹_›.cases; simp)

(* For trivial FO types, any two well-typed values are related.
    Requires typing to use canonical forms for TProd/TSum decomposition.

    STATUS: UNUSED LEMMA with known issues.
    - TSum with trivial components fails when v1=EInl, v2=EInr
    - fo_type_has_trivial_rel incorrectly returns true for TSum
    - The admits are justified dead code until this lemma is actually needed

    TODO: Fix by either:
    1. Remove TSum from fo_type_has_trivial_rel (TSum requires matching constructors)
    2. Weaken val_rel_at_type_fo for TSum to return True when components are trivial *)
(* val_rel_at_type_fo_trivial (matches Coq) *)
lemma val_rel_at_type_fo_trivial: "\<forall> T Σ v1 v2, first_order_type T = True \<longrightarrow> fo_type_has_trivial_rel T = True \<longrightarrow> value v1 \<longrightarrow> value v2 \<longrightarrow> has_type nil Σ Public v1 T EffectPure \<longrightarrow> has_type nil Σ Public v2 T EffectPure \<longrightarrow> val_rel_at_type_fo T v1 v2"
  by (cases rule: ‹_›.cases; simp)

(* Unfold lemma for val_rel_at_type_n at successor step.
    At S n, val_rel_at_type_n reduces to val_rel_at_type. *)
(* val_rel_at_type_n_S (matches Coq) *)
lemma val_rel_at_type_n_S: "\<forall> n Σ sp vl sl svp T v1 v2, val_rel_at_type_n (S n) Σ sp vl sl svp T v1 v2 = val_rel_at_type Σ sp vl sl svp T v1 v2"
  by simp

(* Unfolding lemmas for val_rel_n - needed because simpl doesn't work well
    on mutual fixpoints with abstract arguments *)
(* val_rel_n_0_unfold (matches Coq) *)
lemma val_rel_n_0_unfold: "\<forall> Σ T v1 v2, val_rel_n 0 Σ T v1 v2 = (value v1 \<and> value v2 \<and> closed_expr v1 \<and> closed_expr v2 \<and> has_type nil Σ Public v1 T EffectPure \<and> has_type nil Σ Public v2 T EffectPure \<and> (if first_order_type T then val_rel_at_type_fo T v1 v2 else True))"
  by simp

(* val_rel_n_S_unfold (matches Coq) *)
lemma val_rel_n_S_unfold: "\<forall> n Σ T v1 v2, val_rel_n (S n) Σ T v1 v2 = (val_rel_n n Σ T v1 v2 \<and> value v1 \<and> value v2 \<and> closed_expr v1 \<and> closed_expr v2 \<and> has_type nil Σ Public v1 T EffectPure \<and> has_type nil Σ Public v2 T EffectPure \<and> val_rel_at_type_n n Σ (store_rel_n n) (val_rel_n n) (store_rel_n n) (store_vals_rel n) T v1 v2)"
  by simp

(* Corollary: For n >= 1, val_rel_at_type_n n = val_rel_at_type.
    This recovers the old val_rel_n_S_unfold form at step >= 2. *)
(* val_rel_n_SS_unfold (matches Coq) *)
lemma val_rel_n_SS_unfold: "\<forall> n Σ T v1 v2, val_rel_n (S (S n)) Σ T v1 v2 = (val_rel_n (S n) Σ T v1 v2 \<and> value v1 \<and> value v2 \<and> closed_expr v1 \<and> closed_expr v2 \<and> has_type nil Σ Public v1 T EffectPure \<and> has_type nil Σ Public v2 T EffectPure \<and> val_rel_at_type Σ (store_rel_n (S n)) (val_rel_n (S n)) (store_rel_n (S n)) (store_vals_rel (S n)) T v1 v2)"
  by simp

(* store_rel_n_0_unfold (matches Coq) *)
lemma store_rel_n_0_unfold: "\<forall> Σ st1 st2, store_rel_n 0 Σ st1 st2 = (store_max st1 = store_max st2)"
  by simp

(* store_rel_n_S_unfold (matches Coq) *)
lemma store_rel_n_S_unfold: "\<forall> n Σ st1 st2, store_rel_n (S n) Σ st1 st2 = (store_rel_n n Σ st1 st2 \<and> store_max st1 = store_max st2 \<and> (\<forall> l T sl, store_ty_lookup l Σ = Some (T, sl) \<longrightarrow> \<exists> v1 v2, store_lookup l st1 = Some v1 \<and> store_lookup l st2 = Some v2 \<and> (if is_low_dec sl then val_rel_n n Σ T v1 v2 else (value v1 \<and> value v2 \<and> closed_expr v1 \<and> closed_expr v2 \<and> has_type nil Σ Public v1 T EffectPure \<and> has_type nil Σ Public v2 T EffectPure))))"
  by simp

(* ========================================================================
    SECTION 3.5: FIRST-ORDER EQUIVALENCE
    ========================================================================

    KEY THEOREM: For first-order types, val_rel_at_type equals val_rel_at_type_fo.

    This is because first-order types don't use the predicate parameters (sp, vl, sl).
    The predicates are only used for TFn types (function types). *)
(* val_rel_at_type_fo_equiv (matches Coq) *)
lemma val_rel_at_type_fo_equiv: "\<forall> T Σ sp vl sl svp v1 v2, first_order_type T = True \<longrightarrow> val_rel_at_type Σ sp vl sl svp T v1 v2 <-> val_rel_at_type_fo T v1 v2"
  by auto

(* Downward closure: val_rel_n n implies val_rel_n 0 (base case).
    This follows directly from the definition where S-case includes the predecessor. *)
(* val_rel_n_to_0 (matches Coq) *)
lemma val_rel_n_to_0: "\<forall> n Σ T v1 v2, val_rel_n n Σ T v1 v2 \<longrightarrow> val_rel_n 0 Σ T v1 v2"
  by auto

(* val_rel_n_step_up_fo (matches Coq) *)
lemma val_rel_n_step_up_fo: "\<forall> T n Σ v1 v2, first_order_type T = True \<longrightarrow> val_rel_n 0 Σ T v1 v2 \<longrightarrow> val_rel_n n Σ T v1 v2"
  by auto

(* CRITICAL: Downward monotonicity for first-order types.
    For FO types, val_rel_n at larger step index implies val_rel_n at smaller step index.
    This is the FO-specific version that avoids the Kripke complications of TFn.

    Proof strategy:
    - Induction on n with m generalized
    - For FO types, val_rel_at_type equals val_rel_at_type_fo at ALL steps
    - So the structural content is step-independent *)
(* val_rel_n_mono_fo (matches Coq) *)
lemma val_rel_n_mono_fo: "\<forall> m n Σ T v1 v2, first_order_type T = True \<longrightarrow> m \<le> n \<longrightarrow> val_rel_n n Σ T v1 v2 \<longrightarrow> val_rel_n m Σ T v1 v2"
  by (cases rule: ‹_›.cases; simp)

(* Corollary: For FO types, val_rel_n at any step index implies val_rel_n at any other.
    Now provable using val_rel_n_step_up_fo and val_rel_n_mono_fo. *)
(* val_rel_n_fo_equiv (matches Coq) *)
lemma val_rel_n_fo_equiv: "\<forall> m n Σ T v1 v2, first_order_type T = True \<longrightarrow> val_rel_n m Σ T v1 v2 \<longrightarrow> val_rel_n n Σ T v1 v2"
  by (cases rule: ‹_›.cases; simp)

(* Extract value property from val_rel_n *)
(* val_rel_n_value (matches Coq) *)
lemma val_rel_n_value: "\<forall> n Σ T v1 v2, val_rel_n n Σ T v1 v2 \<longrightarrow> value v1 \<and> value v2"
  by auto

(* Extract closed property from val_rel_n *)
(* val_rel_n_closed (matches Coq) *)
lemma val_rel_n_closed: "\<forall> n Σ T v1 v2, val_rel_n n Σ T v1 v2 \<longrightarrow> closed_expr v1 \<and> closed_expr v2"
  by auto

(* Extract typing from val_rel_n (unconditional since typing is always present) *)
(* val_rel_n_typing (matches Coq) *)
lemma val_rel_n_typing: "\<forall> n Σ T v1 v2, val_rel_n n Σ T v1 v2 \<longrightarrow> has_type nil Σ Public v1 T EffectPure \<and> has_type nil Σ Public v2 T EffectPure"
  by auto

(* Extract pair structure from val_rel_n for TProd - FIRST-ORDER TYPES ONLY *)
(* val_rel_n_prod_structure (matches Coq) *)
lemma val_rel_n_prod_structure: "\<forall> n Σ T1 T2 v1 v2, first_order_type T1 = True \<longrightarrow> first_order_type T2 = True \<longrightarrow> val_rel_n n Σ (TProd T1 T2) v1 v2 \<longrightarrow> \<exists> a1 b1 a2 b2, v1 = EPair a1 b1 \<and> v2 = EPair a2 b2 \<and> value a1 \<and> value b1 \<and> value a2 \<and> value b2"
  by auto

(* Extract boolean structure from val_rel_n for TBool *)
(* val_rel_n_bool_structure (matches Coq) *)
lemma val_rel_n_bool_structure: "\<forall> n Σ v1 v2, val_rel_n n Σ TBool v1 v2 \<longrightarrow> \<exists> b, v1 = EBool b \<and> v2 = EBool b"
  by auto

(* Extract sum structure from val_rel_n for TSum - FIRST-ORDER TYPES ONLY *)
(* val_rel_n_sum_structure (matches Coq) *)
lemma val_rel_n_sum_structure: "\<forall> n Σ T1 T2 v1 v2, first_order_type T1 = True \<longrightarrow> first_order_type T2 = True \<longrightarrow> val_rel_n n Σ (TSum T1 T2) v1 v2 \<longrightarrow> (\<exists> a1 a2, v1 = EInl a1 T2 \<and> v2 = EInl a2 T2 \<and> value a1 \<and> value a2) \<or> (\<exists> b1 b2, v1 = EInr b1 T1 \<and> v2 = EInr b2 T1 \<and> value b1 \<and> value b2)"
  by auto

(* Downward monotonicity for val_rel_n *)
(* val_rel_n_mono (matches Coq) *)
lemma val_rel_n_mono: "\<forall> m n Σ T v1 v2, m \<le> n \<longrightarrow> val_rel_n n Σ T v1 v2 \<longrightarrow> val_rel_n m Σ T v1 v2"
  by (cases rule: ‹_›.cases; simp)

(* Downward monotonicity for store_rel_n *)
(* store_rel_n_mono (matches Coq) *)
lemma store_rel_n_mono: "\<forall> m n Σ st1 st2, m \<le> n \<longrightarrow> store_rel_n n Σ st1 st2 \<longrightarrow> store_rel_n m Σ st1 st2"
  by (cases rule: ‹_›.cases; simp)

(* Helper: invert pair typing to get component typing at EffectPure *)
(* pair_typing_pure_inv (matches Coq) *)
lemma pair_typing_pure_inv: "\<forall> Γ Σ Δ e1 e2 T1 T2, has_type Γ Σ Δ (EPair e1 e2) (TProd T1 T2) EffectPure \<longrightarrow> has_type Γ Σ Δ e1 T1 EffectPure \<and> has_type Γ Σ Δ e2 T2 EffectPure"
  by auto

(* FORMER AXIOM 1: exp_rel_step1_fst - NOW PROVEN *)
(* exp_rel_step1_fst (matches Coq) *)
lemma exp_rel_step1_fst: "\<forall> Σ T1 T2 v v' st1 st2 ctx Σ', first_order_type T1 = True \<longrightarrow> first_order_type T2 = True \<longrightarrow> val_rel_n 0 Σ' (TProd T1 T2) v v' \<longrightarrow> store_rel_n 0 Σ' st1 st2 \<longrightarrow> store_ty_extends Σ Σ' \<longrightarrow> \<exists> a1 a2 st1' st2' ctx' Σ'', store_ty_extends Σ' Σ'' \<and> (EFst v, st1, ctx) -->* (a1, st1', ctx') \<and> (EFst v', st2, ctx) -->* (a2, st2', ctx') \<and> value a1 \<and> value a2 \<and> val_rel_n 0 Σ'' T1 a1 a2 \<and> store_rel_n 0 Σ'' st1' st2'"
  by (cases rule: ‹_›.cases; simp)

(* FORMER AXIOM 2: exp_rel_step1_snd - NOW PROVEN *)
(* exp_rel_step1_snd (matches Coq) *)
lemma exp_rel_step1_snd: "\<forall> Σ T1 T2 v v' st1 st2 ctx Σ', first_order_type T1 = True \<longrightarrow> first_order_type T2 = True \<longrightarrow> val_rel_n 0 Σ' (TProd T1 T2) v v' \<longrightarrow> store_rel_n 0 Σ' st1 st2 \<longrightarrow> store_ty_extends Σ Σ' \<longrightarrow> \<exists> b1 b2 st1' st2' ctx' Σ'', store_ty_extends Σ' Σ'' \<and> (ESnd v, st1, ctx) -->* (b1, st1', ctx') \<and> (ESnd v', st2, ctx) -->* (b2, st2', ctx') \<and> value b1 \<and> value b2 \<and> val_rel_n 0 Σ'' T2 b1 b2 \<and> store_rel_n 0 Σ'' st1' st2'"
  by (cases rule: ‹_›.cases; simp)

(* FORMER AXIOM 3: exp_rel_step1_if - NOW PROVEN - THE BIG WIN! *)
(* exp_rel_step1_if (matches Coq) *)
lemma exp_rel_step1_if: "\<forall> Σ (v v' e2 e2' e3 e3' : expr) st1 st2 ctx Σ', val_rel_n 0 Σ' TBool v v' \<longrightarrow> store_rel_n 0 Σ' st1 st2 \<longrightarrow> store_ty_extends Σ Σ' \<longrightarrow> \<exists> r1 r2 st1' st2' ctx' Σ'', store_ty_extends Σ' Σ'' \<and> (EIf v e2 e3, st1, ctx) -->* (r1, st1', ctx') \<and> (EIf v' e2' e3', st2, ctx) -->* (r2, st2', ctx')"
  by auto

(* FORMER AXIOM 4: exp_rel_step1_case - NOW PROVEN - THE BIG WIN! *)
(* exp_rel_step1_case (matches Coq) *)
lemma exp_rel_step1_case: "\<forall> Σ T1 T2 (v v' : expr) x1 e1 e1' x2 e2 e2' st1 st2 ctx Σ', first_order_type T1 = True \<longrightarrow> first_order_type T2 = True \<longrightarrow> val_rel_n 0 Σ' (TSum T1 T2) v v' \<longrightarrow> store_rel_n 0 Σ' st1 st2 \<longrightarrow> store_ty_extends Σ Σ' \<longrightarrow> \<exists> r1 r2 st1' st2' ctx' Σ'', store_ty_extends Σ' Σ'' \<and> (ECase v x1 e1 x2 e2, st1, ctx) -->* (r1, st1', ctx') \<and> (ECase v' x1 e1' x2 e2', st2, ctx) -->* (r2, st2', ctx')"
  by auto

(* FORMER AXIOM 5: exp_rel_step1_let - NOW PROVEN *)
(* exp_rel_step1_let (matches Coq) *)
lemma exp_rel_step1_let: "\<forall> Σ T v v' x e2 e2' st1 st2 ctx Σ', val_rel_n 0 Σ' T v v' \<longrightarrow> store_rel_n 0 Σ' st1 st2 \<longrightarrow> store_ty_extends Σ Σ' \<longrightarrow> \<exists> r1 r2 st1' st2' ctx' Σ'', store_ty_extends Σ' Σ'' \<and> (ELet x v e2, st1, ctx) -->* (r1, st1', ctx') \<and> (ELet x v' e2', st2, ctx) -->* (r2, st2', ctx')"
  by auto

(* FORMER AXIOM 6: exp_rel_step1_handle - NOW PROVEN *)
(* exp_rel_step1_handle (matches Coq) *)
lemma exp_rel_step1_handle: "\<forall> Σ T v v' x h h' st1 st2 ctx Σ', val_rel_n 0 Σ' T v v' \<longrightarrow> store_rel_n 0 Σ' st1 st2 \<longrightarrow> store_ty_extends Σ Σ' \<longrightarrow> \<exists> r1 r2 st1' st2' ctx' Σ'', store_ty_extends Σ' Σ'' \<and> (EHandle v x h, st1, ctx) -->* (r1, st1', ctx') \<and> (EHandle v' x h', st2, ctx) -->* (r2, st2', ctx')"
  by auto

(* exp_rel_step1_app - Needs typing to get lambda structure *)
(* exp_rel_step1_app (matches Coq) *)
lemma exp_rel_step1_app: "\<forall> Σ T1 T2 ε f f' a a' st1 st2 ctx Σ', val_rel_n 0 Σ' (TFn T1 T2 ε) f f' \<longrightarrow> val_rel_n 0 Σ' T1 a a' \<longrightarrow> store_rel_n 0 Σ' st1 st2 \<longrightarrow> store_ty_extends Σ Σ' \<longrightarrow> (* ADDITIONAL PREMISE: typing for f and f' *) has_type nil Σ' Public f (TFn T1 T2 ε) EffectPure \<longrightarrow> has_type nil Σ' Public f' (TFn T1 T2 ε) EffectPure \<longrightarrow> \<exists> r1 r2 st1' st2' ctx' Σ'', store_ty_extends Σ' Σ'' \<and> (EApp f a, st1, ctx) -->* (r1, st1', ctx') \<and> (EApp f' a', st2, ctx) -->* (r2, st2', ctx')"
  by auto

(* Extract just the store_wf part from preservation *)
(* preservation_store_wf (matches Coq) *)
lemma preservation_store_wf: "\<forall> e e' st st' ctx ctx' Σ T ε, has_type nil Σ Public e T ε \<longrightarrow> store_wf Σ st \<longrightarrow> (e, st, ctx) --> (e', st', ctx') \<longrightarrow> \<exists> Σ', store_ty_extends Σ Σ' \<and> store_wf Σ' st'"
  by auto

(* store_wf implies store_has_values - NOW TRIVIAL after store_wf strengthening *)
(* store_wf_to_has_values (matches Coq) *)
lemma store_wf_to_has_values: "\<forall> Σ st, store_wf Σ st \<longrightarrow> store_has_values st"
  by auto

(* Use preservation to show store_has_values is preserved *)
(* preservation_store_has_values (matches Coq) *)
lemma preservation_store_has_values: "\<forall> e e' st st' ctx ctx' Σ T ε, has_type nil Σ Public e T ε \<longrightarrow> store_wf Σ st \<longrightarrow> (e, st, ctx) --> (e', st', ctx') \<longrightarrow> store_has_values st'"
  by auto

(* val_rel_at_type step-up for FIRST-ORDER types.

    For FO types (first_order_type T = true), val_rel_at_type uses
    val_rel_at_type_fo which doesn't depend on predicates at all.
    This means step-up is trivial.

    For HO types (containing TFn), we need the combined IH and handle
    them directly in combined_step_up. *)
(* val_rel_at_type_fo_step_invariant (matches Coq) *)
lemma val_rel_at_type_fo_step_invariant: "\<forall> T n' m' Σ v1 v2, first_order_type T = True \<longrightarrow> @val_rel_at_type Σ (store_rel_n n') (val_rel_n n') (store_rel_n n') (store_vals_rel n') T v1 v2 \<longrightarrow> @val_rel_at_type Σ (store_rel_n m') (val_rel_n m') (store_rel_n m') (store_vals_rel m') T v1 v2"
  by auto

(* val_rel_at_type step-up using combined IH.

    This handles ALL type cases by induction on type structure:
    - FO types: predicate-independent (use val_rel_at_type_fo_equiv)
    - TFn: weaken preconditions to n', apply, then step-up results using IH
    - TProd/TSum: recurse on components

    Takes the val_rel step-up IH as a parameter. *)
(* val_rel_at_type_step_up_with_IH (matches Coq) *)
lemma val_rel_at_type_step_up_with_IH: "\<forall> T n' Σ v1 v2, (* IH: val_rel_n step-up for all types at level n' *) (\<forall> T' Σ' v1' v2', val_rel_n n' Σ' T' v1' v2' \<longrightarrow> (first_order_type T' = False \<longrightarrow> has_type nil Σ' Public v1' T' EffectPure) \<longrightarrow> (first_order_type T' = False \<longrightarrow> has_type nil Σ' Public v2' T' EffectPure) \<longrightarrow> val_rel_n (S n') Σ' T' v1' v2') \<longrightarrow> (* IH: store_rel_n step-up at level n' *) (\<forall> Σ' st1 st2, store_rel_n n' Σ' st1 st2 \<longrightarrow> store_wf Σ' st1 \<longrightarrow> store_wf Σ' st2 \<longrightarrow> store_has_values st1 \<longrightarrow> store_has_values st2 \<longrightarrow> stores_agree_low_fo Σ' st1 st2 \<longrightarrow> store_rel_n (S n') Σ' st1 st2) \<longrightarrow> @val_rel_at_type Σ (store_rel_n n') (val_rel_n n') (store_rel_n n') (store_vals_rel n') T v1 v2 \<longrightarrow> @val_rel_at_type Σ (store_rel_n (S n')) (val_rel_n (S n')) (store_rel_n (S n')) (store_vals_rel (S n')) T v1 v2"
  by (cases rule: ‹_›.cases; simp)

(* Wrap combined_step_up val component to match conditional typing IH *)
(* combined_step_up_val_wrap (matches Coq) *)
lemma combined_step_up_val_wrap: "\<forall> n, combined_step_up n \<longrightarrow> (\<forall> T' Σ' v1' v2', val_rel_n n Σ' T' v1' v2' \<longrightarrow> (first_order_type T' = False \<longrightarrow> has_type nil Σ' Public v1' T' EffectPure) \<longrightarrow> (first_order_type T' = False \<longrightarrow> has_type nil Σ' Public v2' T' EffectPure) \<longrightarrow> val_rel_n (S n) Σ' T' v1' v2')"
  by auto

(* Helper: store_rel step-up for n > 0 using val_rel step-up from IH *)
(* store_rel_n_step_up_from_IH (matches Coq) *)
lemma store_rel_n_step_up_from_IH: "\<forall> n' Σ st1 st2, (* IH: val_rel step-up at n' for all types *) (\<forall> T Σ' v1 v2, val_rel_n n' Σ' T v1 v2 \<longrightarrow> has_type nil Σ' Public v1 T EffectPure \<longrightarrow> has_type nil Σ' Public v2 T EffectPure \<longrightarrow> val_rel_n (S n') Σ' T v1 v2) \<longrightarrow> store_rel_n (S n') Σ st1 st2 \<longrightarrow> store_wf Σ st1 \<longrightarrow> store_wf Σ st2 \<longrightarrow> store_has_values st1 \<longrightarrow> store_has_values st2 \<longrightarrow> store_rel_n (S (S n')) Σ st1 st2"
  by auto

(* Helper: store_rel step-up from n to S n when n > 0, using val_rel step-up *)
(* store_rel_n_step_up_with_val_IH (matches Coq) *)
lemma store_rel_n_step_up_with_val_IH: "\<forall> m Σ st1 st2, (* Val_rel step-up at step m for all types *) (\<forall> T Σ' v1 v2, val_rel_n m Σ' T v1 v2 \<longrightarrow> has_type nil Σ' Public v1 T EffectPure \<longrightarrow> has_type nil Σ' Public v2 T EffectPure \<longrightarrow> val_rel_n (S m) Σ' T v1 v2) \<longrightarrow> store_rel_n (S m) Σ st1 st2 \<longrightarrow> store_wf Σ st1 \<longrightarrow> store_wf Σ st2 \<longrightarrow> store_has_values st1 \<longrightarrow> store_has_values st2 \<longrightarrow> store_rel_n (S (S m)) Σ st1 st2"
  by auto

(* Main theorem: combined_step_up holds for all n via strong induction *)
(* combined_step_up_all (matches Coq) *)
lemma combined_step_up_all: "\<forall> n, combined_step_up n"
  by (cases rule: ‹_›.cases; simp)

(* Auxiliary lemma: val_rel_n step-up with type-structural induction.
    The outer induction is on type size, enabling recursive calls on subtypes. *)
(* val_rel_n_step_up_by_type (matches Coq) *)
lemma val_rel_n_step_up_by_type: "\<forall> T n Σ v1 v2, val_rel_n n Σ T v1 v2 \<longrightarrow> has_type nil Σ Public v1 T EffectPure \<longrightarrow> has_type nil Σ Public v2 T EffectPure \<longrightarrow> val_rel_n (S n) Σ T v1 v2"
  by auto

(* Main step-up lemma - derives from type-structural version *)
(* val_rel_n_step_up (matches Coq) *)
lemma val_rel_n_step_up: "\<forall> n Σ T v1 v2, val_rel_n n Σ T v1 v2 \<longrightarrow> has_type nil Σ Public v1 T EffectPure \<longrightarrow> has_type nil Σ Public v2 T EffectPure \<longrightarrow> val_rel_n (S n) Σ T v1 v2"
  by auto

(* store_rel_n_step_up - Follows from val_rel_n_step_up
    Requires store_wf to establish value relations for store locations

    REVISED: The n=0 case for FO types at LOW security levels requires
    stores_agree_low_fo precondition. For HIGH security, we rely on
    the type having a trivial val_rel (TSecret, TLabeled, etc.).

    For n >= 1, this lemma is fully provable using val_rel_n_step_up. *)
(* store_rel_n_step_up (matches Coq) *)
lemma store_rel_n_step_up: "\<forall> n Σ st1 st2, store_rel_n n Σ st1 st2 \<longrightarrow> store_wf Σ st1 \<longrightarrow> store_wf Σ st2 \<longrightarrow> store_has_values st1 \<longrightarrow> store_has_values st2 \<longrightarrow> stores_agree_low_fo Σ st1 st2 \<longrightarrow> (* Required for n=0 LOW FO bootstrap *) store_rel_n (S n) Σ st1 st2"
  by auto

(* store_vals_rel monotonicity: step down *)
(* store_vals_rel_mono (matches Coq) *)
lemma store_vals_rel_mono: "\<forall> m n Σ st1 st2, m \<le> n \<longrightarrow> store_vals_rel n Σ st1 st2 \<longrightarrow> store_vals_rel m Σ st1 st2"
  by auto

(* store_vals_rel step-up: uses val_rel_n_step_up on each location *)
(* store_vals_rel_step_up (matches Coq) *)
lemma store_vals_rel_step_up: "\<forall> n Σ st1 st2, store_vals_rel n Σ st1 st2 \<longrightarrow> store_wf Σ st1 \<longrightarrow> store_wf Σ st2 \<longrightarrow> store_vals_rel (S n) Σ st1 st2"
  by auto

(* QUICK-WIN 1: exp_rel_n at step 0 is trivially true
    This follows from the definition: exp_rel_n 0 = True.
    Proves: Axiom exp_rel_n_base from LogicalRelationAssign_PROOF.v *)
(* exp_rel_n_base (matches Coq) *)
lemma exp_rel_n_base: "\<forall> Σ T e1 e2, exp_rel_n 0 Σ T e1 e2"
  by auto

(* Helper: val_rel_n 0 for TUnit with EUnit *)
(* val_rel_n_0_unit (matches Coq) *)
lemma val_rel_n_0_unit: "\<forall> Σ, val_rel_n 0 Σ TUnit EUnit EUnit"
  by auto

(* val_rel_n_unit (matches Coq) *)
lemma val_rel_n_unit: "\<forall> n Σ, n > 0 \<longrightarrow> val_rel_n n Σ TUnit EUnit EUnit"
  by (cases rule: ‹_›.cases; simp)

(* QUICK-WIN 3: exp_rel_n for EUnit at TUnit (all n)
    EUnit is already a value, so it terminates to itself immediately.
    Proves: Axiom exp_rel_n_unit from LogicalRelationAssign_PROOF.v *)
(* exp_rel_n_unit (matches Coq) *)
lemma exp_rel_n_unit: "\<forall> n Σ, exp_rel_n n Σ TUnit EUnit EUnit"
  by (cases rule: ‹_›.cases; simp)

(* Bridge lemma: well_typed TFn applications at step 0 produce related results.
    This captures what we need from the fundamental theorem for the TFn case.

    STATUS: Depends on well_typed_SN from ReducibilityFull.v
    PROOF APPROACH:
    1. Extract lambda structure via canonical_forms_fn
    2. Beta reduction: EApp (ELam x T body) arg --> [x := arg] body
    3. Apply well_typed_SN to show applications terminate in values
    4. Apply preservation to get typing for result values
    5. Build val_rel_n 0 from typing (HO) or structure (FO) *)
(* val_rel_at_type_TFn_step_0_bridge (matches Coq) *)
lemma val_rel_at_type_TFn_step_0_bridge: "\<forall> Σ T1 T2 eff v1 v2, has_type nil Σ Public v1 (TFn T1 T2 eff) EffectPure \<longrightarrow> has_type nil Σ Public v2 (TFn T1 T2 eff) EffectPure \<longrightarrow> value v1 \<longrightarrow> value v2 \<longrightarrow> closed_expr v1 \<longrightarrow> closed_expr v2 \<longrightarrow> \<forall> Σ', store_ty_extends Σ Σ' \<longrightarrow> \<forall> x y, value x \<longrightarrow> value y \<longrightarrow> closed_expr x \<longrightarrow> closed_expr y \<longrightarrow> val_rel_n 0 Σ' T1 x y \<longrightarrow> \<forall> st1 st2 ctx, store_rel_n 0 Σ' st1 st2 \<longrightarrow> store_wf Σ' st1 \<longrightarrow> store_wf Σ' st2 \<longrightarrow> stores_agree_low_fo Σ' st1 st2 \<longrightarrow> store_vals_rel 0 Σ' st1 st2 \<longrightarrow> \<exists> v1' v2' st1' st2' ctx' Σ'', store_ty_extends Σ' Σ'' \<and> (EApp v1 x, st1, ctx) -->* (v1', st1', ctx') \<and> (EApp v2 y, st2, ctx) -->* (v2', st2', ctx') \<and> val_rel_n 0 Σ'' T2 v1' v2' \<and> store_rel_n 0 Σ'' st1' st2' \<and> store_wf Σ'' st1' \<and> store_wf Σ'' st2' \<and> stores_agree_low_fo Σ'' st1' st2'"
  by auto

end
