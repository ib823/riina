(* Copyright (c) 2026 The RIINA Authors. All rights reserved. *)

(*
 * RIINA TerminationLemmas - Isabelle/HOL Port
 *
 * Auto-generated port of 02_FORMAL/coq/termination/TerminationLemmas.v (7 theorems).
 *
 * Generated by scripts/generate-multiprover.py
 *
 * Correspondence Table:
 *
 * | Coq Definition     | Isabelle Definition    | Status |
 * |--------------------|------------------------|--------|
 * | val_rel_0          | val_rel_0              | OK     |
 * | store_rel_0        | store_rel_0            | OK     |
 * | exp_rel_step1_fst_typed | exp_rel_step1_fst_typed | OK     |
 * | exp_rel_step1_snd_typed | exp_rel_step1_snd_typed | OK     |
 * | exp_rel_step1_case_typed | exp_rel_step1_case_typed | OK     |
 * | exp_rel_step1_if_typed | exp_rel_step1_if_typed | OK     |
 * | exp_rel_step1_let_typed | exp_rel_step1_let_typed | OK     |
 * | exp_rel_step1_handle_typed | exp_rel_step1_handle_typed | OK     |
 * | exp_rel_step1_app_typed | exp_rel_step1_app_typed | OK     |
 *)

theory TerminationLemmas
  imports Main
begin

(* val_rel_0 (matches Coq: Definition val_rel_0) *)
definition val_rel_0 :: "store_ty \<Rightarrow> ty \<Rightarrow> bool" where
  "val_rel_0 Σ T \<equiv> True"

(* store_rel_0 (matches Coq: Definition store_rel_0) *)
definition store_rel_0 :: "store_ty \<Rightarrow> bool" where
  "store_rel_0 Σ \<equiv> True"

(* exp_rel_step1_fst_typed (matches Coq) *)
lemma exp_rel_step1_fst_typed: "\<forall> Σ T1 T2 v v' st1 st2 ctx Σ' ε, has_type nil Σ' Public v (TProd T1 T2) ε \<longrightarrow> has_type nil Σ' Public v' (TProd T1 T2) ε \<longrightarrow> value v \<longrightarrow> value v' \<longrightarrow> store_rel_0 Σ' st1 st2 \<longrightarrow> store_ty_extends Σ Σ' \<longrightarrow> \<exists> a1 a2 st1' st2' ctx1' ctx2' Σ'', store_ty_extends Σ' Σ'' \<and> (EFst v, st1, ctx) -->* (a1, st1', ctx1') \<and> (EFst v', st2, ctx) -->* (a2, st2', ctx2') \<and> value a1 \<and> value a2 \<and> val_rel_0 Σ'' T1 a1 a2 \<and> store_rel_0 Σ'' st1' st2'"
  by auto

(* exp_rel_step1_snd_typed (matches Coq) *)
lemma exp_rel_step1_snd_typed: "\<forall> Σ T1 T2 v v' st1 st2 ctx Σ' ε, has_type nil Σ' Public v (TProd T1 T2) ε \<longrightarrow> has_type nil Σ' Public v' (TProd T1 T2) ε \<longrightarrow> value v \<longrightarrow> value v' \<longrightarrow> store_rel_0 Σ' st1 st2 \<longrightarrow> store_ty_extends Σ Σ' \<longrightarrow> \<exists> b1 b2 st1' st2' ctx1' ctx2' Σ'', store_ty_extends Σ' Σ'' \<and> (ESnd v, st1, ctx) -->* (b1, st1', ctx1') \<and> (ESnd v', st2, ctx) -->* (b2, st2', ctx2') \<and> value b1 \<and> value b2 \<and> val_rel_0 Σ'' T2 b1 b2 \<and> store_rel_0 Σ'' st1' st2'"
  by auto

(* exp_rel_step1_case_typed (matches Coq) *)
lemma exp_rel_step1_case_typed: "\<forall> Σ T T1 T2 v v' x1 e1 e1' x2 e2 e2' st1 st2 ctx Σ' ε, has_type nil Σ' Public v (TSum T1 T2) ε \<longrightarrow> has_type nil Σ' Public v' (TSum T1 T2) ε \<longrightarrow> value v \<longrightarrow> value v' \<longrightarrow> store_rel_0 Σ' st1 st2 \<longrightarrow> store_ty_extends Σ Σ' \<longrightarrow> (\<forall> v1, value v1 \<longrightarrow> terminates ([x1 := v1] e1) st1 ctx) \<longrightarrow> (\<forall> v2, value v2 \<longrightarrow> terminates ([x2 := v2] e2) st1 ctx) \<longrightarrow> (\<forall> v1', value v1' \<longrightarrow> terminates ([x1 := v1'] e1') st2 ctx) \<longrightarrow> (\<forall> v2', value v2' \<longrightarrow> terminates ([x2 := v2'] e2') st2 ctx) \<longrightarrow> \<exists> r1 r2 st1' st2' ctx1' ctx2' Σ'', store_ty_extends Σ' Σ'' \<and> (ECase v x1 e1 x2 e2, st1, ctx) -->* (r1, st1', ctx1') \<and> (ECase v' x1 e1' x2 e2', st2, ctx) -->* (r2, st2', ctx2') \<and> value r1 \<and> value r2 \<and> val_rel_0 Σ'' T r1 r2 \<and> store_rel_0 Σ'' st1' st2'"
  by auto

(* exp_rel_step1_if_typed (matches Coq) *)
lemma exp_rel_step1_if_typed: "\<forall> Σ T v v' e2 e2' e3 e3' st1 st2 ctx Σ' ε, has_type nil Σ' Public v TBool ε \<longrightarrow> has_type nil Σ' Public v' TBool ε \<longrightarrow> value v \<longrightarrow> value v' \<longrightarrow> store_rel_0 Σ' st1 st2 \<longrightarrow> store_ty_extends Σ Σ' \<longrightarrow> terminates e2 st1 ctx \<longrightarrow> terminates e3 st1 ctx \<longrightarrow> terminates e2' st2 ctx \<longrightarrow> terminates e3' st2 ctx \<longrightarrow> \<exists> r1 r2 st1' st2' ctx1' ctx2' Σ'', store_ty_extends Σ' Σ'' \<and> (EIf v e2 e3, st1, ctx) -->* (r1, st1', ctx1') \<and> (EIf v' e2' e3', st2, ctx) -->* (r2, st2', ctx2') \<and> value r1 \<and> value r2 \<and> val_rel_0 Σ'' T r1 r2 \<and> store_rel_0 Σ'' st1' st2'"
  by auto

(* exp_rel_step1_let_typed (matches Coq) *)
lemma exp_rel_step1_let_typed: "\<forall> Σ T v v' x e2 e2' st1 st2 ctx Σ', value v \<longrightarrow> value v' \<longrightarrow> store_rel_0 Σ' st1 st2 \<longrightarrow> store_ty_extends Σ Σ' \<longrightarrow> terminates ([x := v] e2) st1 ctx \<longrightarrow> terminates ([x := v'] e2') st2 ctx \<longrightarrow> \<exists> r1 r2 st1' st2' ctx1' ctx2' Σ'', store_ty_extends Σ' Σ'' \<and> (ELet x v e2, st1, ctx) -->* (r1, st1', ctx1') \<and> (ELet x v' e2', st2, ctx) -->* (r2, st2', ctx2') \<and> value r1 \<and> value r2 \<and> val_rel_0 Σ'' T r1 r2 \<and> store_rel_0 Σ'' st1' st2'"
  by auto

(* exp_rel_step1_handle_typed (matches Coq) *)
lemma exp_rel_step1_handle_typed: "\<forall> Σ T v v' x h h' st1 st2 ctx Σ', value v \<longrightarrow> value v' \<longrightarrow> store_rel_0 Σ' st1 st2 \<longrightarrow> store_ty_extends Σ Σ' \<longrightarrow> terminates ([x := v] h) st1 ctx \<longrightarrow> terminates ([x := v'] h') st2 ctx \<longrightarrow> \<exists> r1 r2 st1' st2' ctx1' ctx2' Σ'', store_ty_extends Σ' Σ'' \<and> (EHandle v x h, st1, ctx) -->* (r1, st1', ctx1') \<and> (EHandle v' x h', st2, ctx) -->* (r2, st2', ctx2') \<and> value r1 \<and> value r2 \<and> val_rel_0 Σ'' T r1 r2 \<and> store_rel_0 Σ'' st1' st2'"
  by auto

(* exp_rel_step1_app_typed (matches Coq) *)
lemma exp_rel_step1_app_typed: "\<forall> Σ T1 T2 f f' a a' st1 st2 ctx Σ' ε ε', has_type nil Σ' Public f (TFn T1 T2 ε) ε' \<longrightarrow> has_type nil Σ' Public f' (TFn T1 T2 ε) ε' \<longrightarrow> value f \<longrightarrow> value f' \<longrightarrow> value a \<longrightarrow> value a' \<longrightarrow> store_rel_0 Σ' st1 st2 \<longrightarrow> store_ty_extends Σ Σ' \<longrightarrow> (\<forall> x body, f = ELam x T1 body \<longrightarrow> terminates ([x := a] body) st1 ctx) \<longrightarrow> (\<forall> x body, f' = ELam x T1 body \<longrightarrow> terminates ([x := a'] body) st2 ctx) \<longrightarrow> \<exists> r1 r2 st1' st2' ctx1' ctx2' Σ'', store_ty_extends Σ' Σ'' \<and> (EApp f a, st1, ctx) -->* (r1, st1', ctx1') \<and> (EApp f' a', st2, ctx) -->* (r2, st2', ctx2') \<and> value r1 \<and> value r2 \<and> val_rel_0 Σ'' T2 r1 r2 \<and> store_rel_0 Σ'' st1' st2'"
  by auto

end
