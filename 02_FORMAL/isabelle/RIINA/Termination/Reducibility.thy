(* Copyright (c) 2026 The RIINA Authors. All rights reserved. *)

(*
 * RIINA Reducibility - Isabelle/HOL Port
 *
 * Auto-generated port of 02_FORMAL/coq/termination/Reducibility.v (9 theorems).
 *
 * Generated by scripts/generate-multiprover.py
 *
 * Correspondence Table:
 *
 * | Coq Definition     | Isabelle Definition    | Status |
 * |--------------------|------------------------|--------|
 * | strongly_normalizing | strongly_normalizing   | OK     |
 * | value_SN           | value_SN               | OK     |
 * | SN_step            | SN_step                | OK     |
 * | fst_typed_steps_to_value | fst_typed_steps_to_value | OK     |
 * | snd_typed_steps_to_value | snd_typed_steps_to_value | OK     |
 * | case_typed_steps_once | case_typed_steps_once  | OK     |
 * | if_typed_steps_once | if_typed_steps_once    | OK     |
 * | let_typed_steps_once | let_typed_steps_once   | OK     |
 * | handle_typed_steps_once | handle_typed_steps_once | OK     |
 * | app_typed_steps_once | app_typed_steps_once   | OK     |
 *)

theory Reducibility
  imports Main
begin

(* strongly_normalizing (matches Coq: Definition strongly_normalizing) *)
definition strongly_normalizing :: "expr \<Rightarrow> store \<Rightarrow> effect_ctx \<Rightarrow> bool" where
  "strongly_normalizing e st ctx \<equiv> SN st ctx e"

(* Values are strongly normalizing (no reduction possible) *)
(* value_SN (matches Coq) *)
lemma value_SN: "\<forall> v st ctx, value v \<longrightarrow> SN st ctx v"
  by auto

(* SN is closed under single-step reduction *)
(* SN_step (matches Coq) *)
lemma SN_step: "\<forall> e e' st st' ctx ctx', SN st ctx e \<longrightarrow> (e, st, ctx) --> (e', st', ctx') \<longrightarrow> SN st' ctx' e'"
  by auto

(* Fst on typed product value steps to a value in one step *)
(* fst_typed_steps_to_value (matches Coq) *)
lemma fst_typed_steps_to_value: "\<forall> v T1 T2 ε Σ st ctx, has_type nil Σ Public v (TProd T1 T2) ε \<longrightarrow> value v \<longrightarrow> \<exists> v1 st' ctx', (EFst v, st, ctx) --> (v1, st', ctx') \<and> value v1 \<and> st' = st \<and> ctx' = ctx"
  by auto

(* Snd on typed product value steps to a value in one step *)
(* snd_typed_steps_to_value (matches Coq) *)
lemma snd_typed_steps_to_value: "\<forall> v T1 T2 ε Σ st ctx, has_type nil Σ Public v (TProd T1 T2) ε \<longrightarrow> value v \<longrightarrow> \<exists> v2 st' ctx', (ESnd v, st, ctx) --> (v2, st', ctx') \<and> value v2 \<and> st' = st \<and> ctx' = ctx"
  by auto

(* Case on typed sum value steps in one step *)
(* case_typed_steps_once (matches Coq) *)
lemma case_typed_steps_once: "\<forall> v T1 T2 ε Σ x1 e1 x2 e2 st ctx, has_type nil Σ Public v (TSum T1 T2) ε \<longrightarrow> value v \<longrightarrow> \<exists> e' st' ctx', (ECase v x1 e1 x2 e2, st, ctx) --> (e', st', ctx') \<and> st' = st \<and> ctx' = ctx"
  by auto

(* If on typed bool value steps in one step *)
(* if_typed_steps_once (matches Coq) *)
lemma if_typed_steps_once: "\<forall> v ε Σ e2 e3 st ctx, has_type nil Σ Public v TBool ε \<longrightarrow> value v \<longrightarrow> \<exists> e' st' ctx', (EIf v e2 e3, st, ctx) --> (e', st', ctx') \<and> st' = st \<and> ctx' = ctx"
  by auto

(* Let with value steps in one step *)
(* let_typed_steps_once (matches Coq) *)
lemma let_typed_steps_once: "\<forall> v x e2 st ctx, value v \<longrightarrow> \<exists> e' st' ctx', (ELet x v e2, st, ctx) --> (e', st', ctx') \<and> st' = st \<and> ctx' = ctx"
  by auto

(* Handle with value steps in one step *)
(* handle_typed_steps_once (matches Coq) *)
lemma handle_typed_steps_once: "\<forall> v x h st ctx, value v \<longrightarrow> \<exists> e' st' ctx', (EHandle v x h, st, ctx) --> (e', st', ctx') \<and> st' = st \<and> ctx' = ctx"
  by auto

(* App with typed function value steps in one step *)
(* app_typed_steps_once (matches Coq) *)
lemma app_typed_steps_once: "\<forall> f T1 T2 ε ε' Σ a st ctx, has_type nil Σ Public f (TFn T1 T2 ε) ε' \<longrightarrow> value f \<longrightarrow> value a \<longrightarrow> \<exists> e' st' ctx', (EApp f a, st, ctx) --> (e', st', ctx') \<and> st' = st \<and> ctx' = ctx"
  by auto

end
