(* SPDX-License-Identifier: MPL-2.0 *)
(* Copyright (c) 2026 The RIINA Authors. See AUTHORS file. *)

(*
 * RIINA StrongNorm - Isabelle/HOL Port
 *
 * Auto-generated port of 02_FORMAL/coq/termination/StrongNorm.v (8 theorems).
 *
 * Generated by scripts/generate-multiprover.py
 *
 * Correspondence Table:
 *
 * | Coq Definition     | Isabelle Definition    | Status |
 * |--------------------|------------------------|--------|
 * | value_strongly_normalizing | value_strongly_normalizing | OK     |
 * | fst_terminates_to_value | fst_terminates_to_value | OK     |
 * | snd_terminates_to_value | snd_terminates_to_value | OK     |
 * | if_bool_terminates_once | if_bool_terminates_once | OK     |
 * | let_terminates_once | let_terminates_once    | OK     |
 * | handle_terminates_once | handle_terminates_once | OK     |
 * | app_lam_terminates_once | app_lam_terminates_once | OK     |
 * | store_ty_extends_refl | store_ty_extends_refl  | OK     |
 *)

theory StrongNorm
  imports Main
begin

(* value_strongly_normalizing (matches Coq) *)
lemma value_strongly_normalizing: "\<forall> v st ctx, value v \<longrightarrow> SN st ctx v"
  by auto

(* Fst on product value terminates in one step to a value *)
(* fst_terminates_to_value (matches Coq) *)
lemma fst_terminates_to_value: "\<forall> v1 v2 st ctx, value v1 \<longrightarrow> value v2 \<longrightarrow> \<exists> v st' ctx', (EFst (EPair v1 v2), st, ctx) -->* (v, st', ctx') \<and> value v \<and> v = v1"
  by auto

(* Snd on product value terminates in one step to a value *)
(* snd_terminates_to_value (matches Coq) *)
lemma snd_terminates_to_value: "\<forall> v1 v2 st ctx, value v1 \<longrightarrow> value v2 \<longrightarrow> \<exists> v st' ctx', (ESnd (EPair v1 v2), st, ctx) -->* (v, st', ctx') \<and> value v \<and> v = v2"
  by auto

(* If on bool terminates in one step to a branch *)
(* if_bool_terminates_once (matches Coq) *)
lemma if_bool_terminates_once: "\<forall> b e2 e3 st ctx, \<exists> e' st' ctx', (EIf (EBool b) e2 e3, st, ctx) -->* (e', st', ctx') \<and> st' = st \<and> ctx' = ctx \<and> (b = True \<longrightarrow> e' = e2) \<and> (b = False \<longrightarrow> e' = e3)"
  by auto

(* Let with value terminates in one step to a substitution *)
(* let_terminates_once (matches Coq) *)
lemma let_terminates_once: "\<forall> x v e2 st ctx, value v \<longrightarrow> \<exists> e' st' ctx', (ELet x v e2, st, ctx) -->* (e', st', ctx') \<and> st' = st \<and> ctx' = ctx"
  by auto

(* Handle with value terminates in one step to a substitution *)
(* handle_terminates_once (matches Coq) *)
lemma handle_terminates_once: "\<forall> x v h st ctx, value v \<longrightarrow> \<exists> e' st' ctx', (EHandle v x h, st, ctx) -->* (e', st', ctx') \<and> st' = st \<and> ctx' = ctx"
  by auto

(* App with lambda value terminates in one step to a substitution *)
(* app_lam_terminates_once (matches Coq) *)
lemma app_lam_terminates_once: "\<forall> x T body v st ctx, value v \<longrightarrow> \<exists> e' st' ctx', (EApp (ELam x T body) v, st, ctx) -->* (e', st', ctx') \<and> st' = st \<and> ctx' = ctx"
  by auto

(* store_ty_extends_refl (matches Coq) *)
lemma store_ty_extends_refl: "\<forall> Σ, store_ty_extends Σ Σ"
  by auto

end
