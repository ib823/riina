(* SPDX-License-Identifier: MPL-2.0 *)
(* Copyright (c) 2026 The RIINA Authors. See AUTHORS file. *)

(*
 * RIINA SizedTypes - Isabelle/HOL Port
 *
 * Auto-generated port of 02_FORMAL/coq/termination/SizedTypes.v (16 theorems).
 *
 * Generated by scripts/generate-multiprover.py
 *
 * Correspondence Table:
 *
 * | Coq Definition     | Isabelle Definition    | Status |
 * |--------------------|------------------------|--------|
 * | sized_ty           | sized_ty               | OK     |
 * | sized_ty_base      | sized_ty_base          | OK     |
 * | sized_ty_bound     | sized_ty_bound         | OK     |
 * | terminates         | terminates             | OK     |
 * | step_terminates    | step_terminates        | OK     |
 * | expr_size_pos      | expr_size_pos          | OK     |
 * | value_prod_decompose | value_prod_decompose   | OK     |
 * | value_sum_decompose | value_sum_decompose    | OK     |
 * | value_bool_decompose | value_bool_decompose   | OK     |
 * | value_fn_decompose | value_fn_decompose     | OK     |
 * | fst_steps_once     | fst_steps_once         | OK     |
 * | snd_steps_once     | snd_steps_once         | OK     |
 * | case_inl_steps_once | case_inl_steps_once    | OK     |
 * | case_inr_steps_once | case_inr_steps_once    | OK     |
 * | if_true_steps_once | if_true_steps_once     | OK     |
 * | if_false_steps_once | if_false_steps_once    | OK     |
 * | let_value_steps_once | let_value_steps_once   | OK     |
 * | handle_value_steps_once | handle_value_steps_once | OK     |
 * | app_lam_steps_once | app_lam_steps_once     | OK     |
 * | step_to_multi      | step_to_multi          | OK     |
 * | multi_step_trans   | multi_step_trans       | OK     |
 *)

theory SizedTypes
  imports Main
begin

(* sized_ty (matches Coq: Inductive sized_ty) *)
datatype sized_ty =
    STBase  (* Base type with implicit size *)
  |     STSized  (* Type with explicit size bound *)

(* sized_ty_base (matches Coq: Definition sized_ty_base) *)
fun sized_ty_base :: "sized_ty \<Rightarrow> ty" where


(* sized_ty_bound (matches Coq: Definition sized_ty_bound) *)
fun sized_ty_bound :: "sized_ty \<Rightarrow> nat" where


(* terminates (matches Coq: Definition terminates) *)
definition terminates :: "expr \<Rightarrow> store \<Rightarrow> effect_ctx \<Rightarrow> bool" where
  "terminates e st ctx \<equiv> exists v st' ctx', (e, st, ctx) -->* (v, st', ctx') /\ value v"

(* step_terminates (matches Coq: Definition step_terminates) *)
definition step_terminates :: "expr \<Rightarrow> store \<Rightarrow> effect_ctx \<Rightarrow> bool" where
  "step_terminates e st ctx \<equiv> exists e' st' ctx', (e, st, ctx) --> (e', st', ctx')"

(* Expression size is positive *)
(* expr_size_pos (matches Coq) *)
lemma expr_size_pos: "\<forall> e, expr_size e > 0"
  by simp

(* If v is a value of product type, it decomposes as a pair *)
(* value_prod_decompose (matches Coq) *)
lemma value_prod_decompose: "\<forall> v T1 T2 ε Σ, has_type nil Σ Public v (TProd T1 T2) ε \<longrightarrow> value v \<longrightarrow> \<exists> v1 v2, v = EPair v1 v2 \<and> value v1 \<and> value v2"
  by simp

(* If v is a value of sum type, it decomposes as Inl or Inr *)
(* value_sum_decompose (matches Coq) *)
lemma value_sum_decompose: "\<forall> v T1 T2 ε Σ, has_type nil Σ Public v (TSum T1 T2) ε \<longrightarrow> value v \<longrightarrow> (\<exists> v', v = EInl v' T2 \<and> value v') \<or> (\<exists> v', v = EInr v' T1 \<and> value v')"
  by simp

(* If v is a value of bool type, it decomposes as true or false *)
(* value_bool_decompose (matches Coq) *)
lemma value_bool_decompose: "\<forall> v ε Σ, has_type nil Σ Public v TBool ε \<longrightarrow> value v \<longrightarrow> \<exists> b, v = EBool b"
  by simp

(* If v is a value of function type, it decomposes as a lambda *)
(* value_fn_decompose (matches Coq) *)
lemma value_fn_decompose: "\<forall> v T1 T2 ε ε' Σ, has_type nil Σ Public v (TFn T1 T2 ε) ε' \<longrightarrow> value v \<longrightarrow> \<exists> x body, v = ELam x T1 body"
  by simp

(* Fst of a pair steps in one step *)
(* fst_steps_once (matches Coq) *)
lemma fst_steps_once: "\<forall> v1 v2 st ctx, value v1 \<longrightarrow> value v2 \<longrightarrow> (EFst (EPair v1 v2), st, ctx) --> (v1, st, ctx)"
  by auto

(* Snd of a pair steps in one step *)
(* snd_steps_once (matches Coq) *)
lemma snd_steps_once: "\<forall> v1 v2 st ctx, value v1 \<longrightarrow> value v2 \<longrightarrow> (ESnd (EPair v1 v2), st, ctx) --> (v2, st, ctx)"
  by auto

(* Case on Inl steps in one step *)
(* case_inl_steps_once (matches Coq) *)
lemma case_inl_steps_once: "\<forall> v T x1 e1 x2 e2 st ctx, value v \<longrightarrow> (ECase (EInl v T) x1 e1 x2 e2, st, ctx) --> ([x1 := v] e1, st, ctx)"
  by auto

(* Case on Inr steps in one step *)
(* case_inr_steps_once (matches Coq) *)
lemma case_inr_steps_once: "\<forall> v T x1 e1 x2 e2 st ctx, value v \<longrightarrow> (ECase (EInr v T) x1 e1 x2 e2, st, ctx) --> ([x2 := v] e2, st, ctx)"
  by auto

(* If true steps in one step *)
(* if_true_steps_once (matches Coq) *)
lemma if_true_steps_once: "\<forall> e2 e3 st ctx, (EIf (EBool true) e2 e3, st, ctx) --> (e2, st, ctx)"
  by auto

(* If false steps in one step *)
(* if_false_steps_once (matches Coq) *)
lemma if_false_steps_once: "\<forall> e2 e3 st ctx, (EIf (EBool false) e2 e3, st, ctx) --> (e3, st, ctx)"
  by auto

(* Let with value steps in one step *)
(* let_value_steps_once (matches Coq) *)
lemma let_value_steps_once: "\<forall> x v e2 st ctx, value v \<longrightarrow> (ELet x v e2, st, ctx) --> ([x := v] e2, st, ctx)"
  by auto

(* Handle with value steps in one step *)
(* handle_value_steps_once (matches Coq) *)
lemma handle_value_steps_once: "\<forall> v x h st ctx, value v \<longrightarrow> (EHandle v x h, st, ctx) --> ([x := v] h, st, ctx)"
  by auto

(* App with lambda and value steps in one step *)
(* app_lam_steps_once (matches Coq) *)
lemma app_lam_steps_once: "\<forall> x T body v st ctx, value v \<longrightarrow> (EApp (ELam x T body) v, st, ctx) --> ([x := v] body, st, ctx)"
  by auto

(* step_to_multi (matches Coq) *)
lemma step_to_multi: "\<forall> e st ctx e' st' ctx', (e, st, ctx) --> (e', st', ctx') \<longrightarrow> (e, st, ctx) -->* (e', st', ctx')"
  by auto

(* Multi-step is transitive *)
(* multi_step_trans (matches Coq) *)
lemma multi_step_trans: "\<forall> e1 st1 ctx1 e2 st2 ctx2 e3 st3 ctx3, (e1, st1, ctx1) -->* (e2, st2, ctx2) \<longrightarrow> (e2, st2, ctx2) -->* (e3, st3, ctx3) \<longrightarrow> (e1, st1, ctx1) -->* (e3, st3, ctx3)"
  by auto

end
