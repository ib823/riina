// Copyright (c) 2026 The RIINA Authors. All rights reserved.
// Auto-generated from 02_FORMAL/coq/termination/ReducibilityFull.v (40 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/reducibility_full

open util/boolean

// step_inv (matches Coq: Definition step_inv)
pred step_inv {}

// SN (matches Coq: Definition SN)
pred SN[cfg: config] {
  some cfg
}

// SN_expr (matches Coq: Definition SN_expr)
pred SN_expr[e: expr] {
  some e
}

// id_rho (matches Coq: Definition id_rho)
pred id_rho {}

// extend_rho (matches Coq: Definition extend_rho)
pred extend_rho[ρ: subst_rho, x: ident, v: expr] {
  some ρ
}

// closed_rho (matches Coq: Definition closed_rho)
pred closed_rho[ρ: subst_rho] {
  some ρ
}

// Reducible (matches Coq: Definition Reducible)
pred Reducible[T: ty, e: expr] {
  some T
}

// value_not_step (matches Coq: Lemma value_not_step)
assert value_not_step {
  #univ >= 0
}
check value_not_step for 5

// value_SN (matches Coq: Lemma value_SN)
assert value_SN {
  #univ >= 0
}
check value_SN for 5

// SN_step (matches Coq: Lemma SN_step)
assert SN_step {
  #univ >= 0
}
check SN_step for 5

// SN_classify_aux (matches Coq: Lemma SN_classify_aux)
assert SN_classify_aux {
  #univ >= 0
}
check SN_classify_aux for 5

// SN_classify (matches Coq: Lemma SN_classify)
assert SN_classify {
  #univ >= 0
}
check SN_classify for 5

// SN_prove_aux (matches Coq: Lemma SN_prove_aux)
assert SN_prove_aux {
  #univ >= 0
}
check SN_prove_aux for 5

// SN_prove (matches Coq: Lemma SN_prove)
assert SN_prove {
  #univ >= 0
}
check SN_prove for 5

// SN_perform_aux (matches Coq: Lemma SN_perform_aux)
assert SN_perform_aux {
  #univ >= 0
}
check SN_perform_aux for 5

// SN_perform (matches Coq: Lemma SN_perform)
assert SN_perform {
  #univ >= 0
}
check SN_perform for 5

// SN_require_aux (matches Coq: Lemma SN_require_aux)
assert SN_require_aux {
  #univ >= 0
}
check SN_require_aux for 5

// SN_require (matches Coq: Lemma SN_require)
assert SN_require {
  #univ >= 0
}
check SN_require for 5

// SN_grant_aux (matches Coq: Lemma SN_grant_aux)
assert SN_grant_aux {
  #univ >= 0
}
check SN_grant_aux for 5

// SN_grant (matches Coq: Lemma SN_grant)
assert SN_grant {
  #univ >= 0
}
check SN_grant for 5

// SN_declassify_value_left_aux (matches Coq: Lemma SN_declassify_value_left_aux)
assert SN_declassify_value_left_aux {
  #univ >= 0
}
check SN_declassify_value_left_aux for 5

// SN_declassify_value_left (matches Coq: Lemma SN_declassify_value_left)
assert SN_declassify_value_left {
  #univ >= 0
}
check SN_declassify_value_left for 5

// SN_declassify_aux (matches Coq: Lemma SN_declassify_aux)
assert SN_declassify_aux {
  #univ >= 0
}
check SN_declassify_aux for 5

// SN_declassify (matches Coq: Lemma SN_declassify)
assert SN_declassify {
  #univ >= 0
}
check SN_declassify for 5

// extend_rho_id (matches Coq: Lemma extend_rho_id)
assert extend_rho_id {
  #univ >= 0
}
check extend_rho_id for 5

// subst_env_id (matches Coq: Lemma subst_env_id)
assert subst_env_id {
  #univ >= 0
}
check subst_env_id for 5

// subst_not_free_in (matches Coq: Lemma subst_not_free_in)
assert subst_not_free_in {
  #univ >= 0
}
check subst_not_free_in for 5

// free_in_var (matches Coq: Lemma free_in_var)
assert free_in_var {
  #univ >= 0
}
check free_in_var for 5

// not_free_in_var_neq (matches Coq: Lemma not_free_in_var_neq)
assert not_free_in_var_neq {
  #univ >= 0
}
check not_free_in_var_neq for 5

// extend_rho_shadow (matches Coq: Lemma extend_rho_shadow)
assert extend_rho_shadow {
  #univ >= 0
}
check extend_rho_shadow for 5

// extend_rho_commute (matches Coq: Lemma extend_rho_commute)
assert extend_rho_commute {
  #univ >= 0
}
check extend_rho_commute for 5

// subst_env_ext (matches Coq: Lemma subst_env_ext)
assert subst_env_ext {
  #univ >= 0
}
check subst_env_ext for 5

// subst_subst_env_commute_gen (matches Coq: Lemma subst_subst_env_commute_gen)
assert subst_subst_env_commute_gen {
  #univ >= 0
}
check subst_subst_env_commute_gen for 5

// subst_subst_env_commute (matches Coq: Lemma subst_subst_env_commute)
assert subst_subst_env_commute {
  #univ >= 0
}
check subst_subst_env_commute for 5

// CR1 (matches Coq: Lemma CR1)
assert CR1 {
  #univ >= 0
}
check CR1 for 5

// CR3_base (matches Coq: Lemma CR3_base)
assert CR3_base {
  #univ >= 0
}
check CR3_base for 5

// unit_reducible (matches Coq: Lemma unit_reducible)
assert unit_reducible {
  #univ >= 0
}
check unit_reducible for 5

// bool_reducible (matches Coq: Lemma bool_reducible)
assert bool_reducible {
  #univ >= 0
}
check bool_reducible for 5

// int_reducible (matches Coq: Lemma int_reducible)
assert int_reducible {
  #univ >= 0
}
check int_reducible for 5

// string_reducible (matches Coq: Lemma string_reducible)
assert string_reducible {
  #univ >= 0
}
check string_reducible for 5

// env_reducible_nil (matches Coq: Lemma env_reducible_nil)
assert env_reducible_nil {
  #univ >= 0
}
check env_reducible_nil for 5

// env_reducible_cons (matches Coq: Lemma env_reducible_cons)
assert env_reducible_cons {
  #univ >= 0
}
check env_reducible_cons for 5

// fundamental_reducibility (matches Coq: Lemma fundamental_reducibility)
assert fundamental_reducibility {
  #univ >= 0
}
check fundamental_reducibility for 5

// well_typed_SN (matches Coq: Theorem well_typed_SN)
assert well_typed_SN {
  #univ >= 0
}
check well_typed_SN for 5

// SN_app (matches Coq: Theorem SN_app)
assert SN_app {
  #univ >= 0
}
check SN_app for 5

// SN_closed_step (matches Coq: Lemma SN_closed_step)
assert SN_closed_step {
  #univ >= 0
}
check SN_closed_step for 5

// SN_beta_value (matches Coq: Lemma SN_beta_value)
assert SN_beta_value {
  #univ >= 0
}
check SN_beta_value for 5
