// Copyright (c) 2026 The RIINA Authors. All rights reserved.
// Auto-generated from 02_FORMAL/coq/domains/LinearTypes.v (25 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/linear_types

open util/boolean

// Linearity (matches Coq: Inductive Linearity)
abstract sig Linearity {}
one sig Lin extends Linearity {} // Linear: exactly once
one sig Aff extends Linearity {} // Affine: at most once
one sig Rel extends Linearity {} // Relevant: at least once
one sig Unr extends Linearity {} // Unrestricted: any number

// LTy (matches Coq: Inductive LTy)
abstract sig LTy {}
one sig LUnit extends LTy {}
one sig LBool extends LTy {}
one sig LFun extends LTy {} // q A ⊸ B
one sig LPair extends LTy {} // A ⊗ B
one sig LBang extends LTy {} // !A

// Usage (matches Coq: Inductive Usage)
abstract sig Usage {}
one sig Zero extends Usage {}
one sig One extends Usage {}
one sig Many extends Usage {}

// LTerm (matches Coq: Inductive LTerm)
abstract sig LTerm {}
one sig LVar extends LTerm {}
one sig LUnitVal extends LTerm {}
one sig LTrue extends LTerm {}
one sig LFalse extends LTerm {}
one sig LLam extends LTerm {}
one sig LApp extends LTerm {}
one sig LPairVal extends LTerm {}
one sig LLetPair extends LTerm {}
one sig LBangVal extends LTerm {}
one sig LLetBang extends LTerm {}
one sig LLet extends LTerm {}

// ResourceState (matches Coq: Inductive ResourceState)
abstract sig ResourceState {}
one sig Available extends ResourceState {}
one sig Consumed extends ResourceState {}

// linearity_eqb (matches Coq: Definition linearity_eqb)
pred linearity_eqb {}

// subqual (matches Coq: Definition subqual)
pred subqual {}

// usage_add (matches Coq: Definition usage_add)
pred usage_add {}

// usage_compatible (matches Coq: Definition usage_compatible)
pred usage_compatible[q: Linearity, u: Usage] {
  some q
}

// empty_ctx (matches Coq: Definition empty_ctx)
pred empty_ctx {}

// extend (matches Coq: Definition extend)
pred extend[ctx: LCtx, x: Var, ty: LTy, q: Linearity] {
  some ctx
}

// ctx_split (matches Coq: Definition ctx_split)
pred ctx_split {}

// linear_var_exactly_once (matches Coq: Definition linear_var_exactly_once)
pred linear_var_exactly_once[ctx: LCtx, x: Var, ty: LTy] {
  some ctx
}

// unrestricted_usage_valid (matches Coq: Definition unrestricted_usage_valid)
pred unrestricted_usage_valid[u: Usage] {
  some u
}

// app_consumes_arg (matches Coq: Definition app_consumes_arg)
pred app_consumes_arg[q: Linearity] {
  some q
}

// affine_subsumes_linear (matches Coq: Definition affine_subsumes_linear)
pred affine_subsumes_linear {}

// relevant_subsumes_linear (matches Coq: Definition relevant_subsumes_linear)
pred relevant_subsumes_linear {}

// ctx_split_valid (matches Coq: Definition ctx_split_valid)
pred ctx_split_valid {}

// substitution_preserves_structure (matches Coq: Definition substitution_preserves_structure)
pred substitution_preserves_structure[x: Var] {
  some x
}

// weakening_invalid_for_linear (matches Coq: Definition weakening_invalid_for_linear)
pred weakening_invalid_for_linear {}

// weakening_violates_linear_semantics (matches Coq: Definition weakening_violates_linear_semantics)
pred weakening_violates_linear_semantics {}

// contraction_invalid_for_linear (matches Coq: Definition contraction_invalid_for_linear)
pred contraction_invalid_for_linear {}

// pair_consumes_both (matches Coq: Definition pair_consumes_both)
pred pair_consumes_both[q: Linearity] {
  some q
}

// let_transfers_ownership (matches Coq: Definition let_transfers_ownership)
pred let_transfers_ownership[x: Var] {
  some x
}

// use_after_consume_impossible (matches Coq: Definition use_after_consume_impossible)
pred use_after_consume_impossible[rm: ResourceMap, x: Var] {
  some rm
}

// no_double_consume (matches Coq: Definition no_double_consume)
pred no_double_consume {}

// linearity_eqb_eq (matches Coq: Lemma linearity_eqb_eq)
assert linearity_eqb_eq {
  #univ >= 0
}
check linearity_eqb_eq for 5

// get_update_same (matches Coq: Lemma get_update_same)
assert get_update_same {
  #univ >= 0
}
check get_update_same for 5

// TYPE_002_01 (matches Coq: Theorem TYPE_002_01)
assert TYPE_002_01 {
  #univ >= 0
}
check TYPE_002_01 for 5

// TYPE_002_02 (matches Coq: Theorem TYPE_002_02)
assert TYPE_002_02 {
  #univ >= 0
}
check TYPE_002_02 for 5

// TYPE_002_03 (matches Coq: Theorem TYPE_002_03)
assert TYPE_002_03 {
  #univ >= 0
}
check TYPE_002_03 for 5

// TYPE_002_04 (matches Coq: Theorem TYPE_002_04)
assert TYPE_002_04 {
  #univ >= 0
}
check TYPE_002_04 for 5

// TYPE_002_05 (matches Coq: Theorem TYPE_002_05)
assert TYPE_002_05 {
  #univ >= 0
}
check TYPE_002_05 for 5

// usage_add_zero_l (matches Coq: Lemma usage_add_zero_l)
assert usage_add_zero_l {
  #univ >= 0
}
check usage_add_zero_l for 5

// usage_add_zero_r (matches Coq: Lemma usage_add_zero_r)
assert usage_add_zero_r {
  #univ >= 0
}
check usage_add_zero_r for 5

// TYPE_002_06 (matches Coq: Theorem TYPE_002_06)
assert TYPE_002_06 {
  #univ >= 0
}
check TYPE_002_06 for 5

// TYPE_002_07 (matches Coq: Theorem TYPE_002_07)
assert TYPE_002_07 {
  #univ >= 0
}
check TYPE_002_07 for 5

// linear_must_be_used (matches Coq: Lemma linear_must_be_used)
assert linear_must_be_used {
  #univ >= 0
}
check linear_must_be_used for 5

// linear_zero_usage_invalid (matches Coq: Lemma linear_zero_usage_invalid)
assert linear_zero_usage_invalid {
  #univ >= 0
}
check linear_zero_usage_invalid for 5

// linear_many_usage_invalid (matches Coq: Lemma linear_many_usage_invalid)
assert linear_many_usage_invalid {
  #univ >= 0
}
check linear_many_usage_invalid for 5

// unused_linear_ill_formed (matches Coq: Lemma unused_linear_ill_formed)
assert unused_linear_ill_formed {
  #univ >= 0
}
check unused_linear_ill_formed for 5

// extend_preserves_lookup_none (matches Coq: Lemma extend_preserves_lookup_none)
assert extend_preserves_lookup_none {
  #univ >= 0
}
check extend_preserves_lookup_none for 5

// unit_typing_preserves_ctx (matches Coq: Lemma unit_typing_preserves_ctx)
assert unit_typing_preserves_ctx {
  #univ >= 0
}
check unit_typing_preserves_ctx for 5

// TYPE_002_08_direct (matches Coq: Theorem TYPE_002_08_direct)
assert TYPE_002_08_direct {
  #univ >= 0
}
check TYPE_002_08_direct for 5

// weakening_consequence (matches Coq: Lemma weakening_consequence)
assert weakening_consequence {
  #univ >= 0
}
check weakening_consequence for 5

// TYPE_002_08 (matches Coq: Theorem TYPE_002_08)
assert TYPE_002_08 {
  #univ >= 0
}
check TYPE_002_08 for 5

// TYPE_002_09 (matches Coq: Theorem TYPE_002_09)
assert TYPE_002_09 {
  #univ >= 0
}
check TYPE_002_09 for 5

// TYPE_002_10 (matches Coq: Theorem TYPE_002_10)
assert TYPE_002_10 {
  #univ >= 0
}
check TYPE_002_10 for 5

// TYPE_002_11 (matches Coq: Theorem TYPE_002_11)
assert TYPE_002_11 {
  #univ >= 0
}
check TYPE_002_11 for 5

// resource_stays_consumed (matches Coq: Lemma resource_stays_consumed)
assert resource_stays_consumed {
  #univ >= 0
}
check resource_stays_consumed for 5

// TYPE_002_12 (matches Coq: Theorem TYPE_002_12)
assert TYPE_002_12 {
  #univ >= 0
}
check TYPE_002_12 for 5
