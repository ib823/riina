// SPDX-License-Identifier: MPL-2.0
// Copyright (c) 2026 The RIINA Authors.
// Auto-generated from 02_FORMAL/coq/domains/DataRaceFreedom.v (35 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/data_race_freedom

open util/boolean

// AccessMode (matches Coq: Inductive AccessMode)
abstract sig AccessMode {}
one sig Exclusive extends AccessMode {} // &mut T - unique mutable access
one sig Shared extends AccessMode {} // &T - shared immutable access
one sig Owned extends AccessMode {} // Uniquely owned by thread
one sig MutBorrowed extends AccessMode {} // Mutably borrowed
one sig SharedBorrowed extends AccessMode {} // Shared borrowed by list
one sig Moved extends AccessMode {}

// MutexState (matches Coq: Record MutexState)
sig MutexState {
  mutex_locked: one Bool,
  mutex_owner: one option
}

// RWLockState (matches Coq: Record RWLockState)
sig RWLockState {
  rwlock_readers: one Int,
  rwlock_writer: one option
}

// well_formed_access (matches Coq: Definition well_formed_access)
pred well_formed_access[as_: AccessState] {
  some as_
}

// shared_compatible (matches Coq: Definition shared_compatible)
pred shared_compatible[as_: AccessState] {
  some as_
}

// no_mixed_access (matches Coq: Definition no_mixed_access)
pred no_mixed_access[as_: AccessState] {
  some as_
}

// well_formed_ownership (matches Coq: Definition well_formed_ownership)
pred well_formed_ownership[om: OwnershipMap] {
  some om
}

// data_race (matches Coq: Definition data_race)
pred data_race[as_: AccessState, l: Loc] {
  some as_
}

// race_free (matches Coq: Definition race_free)
pred race_free[as_: AccessState] {
  some as_
}

// init_mutex (matches Coq: Definition init_mutex)
pred init_mutex {}

// mutex_well_formed (matches Coq: Definition mutex_well_formed)
pred mutex_well_formed[m: MutexState] {
  some m
}

// init_rwlock (matches Coq: Definition init_rwlock)
pred init_rwlock {}

// rwlock_well_formed (matches Coq: Definition rwlock_well_formed)
pred rwlock_well_formed[rw: RWLockState] {
  some rw
}

// mut_borrow_exclusive (matches Coq: Definition mut_borrow_exclusive)
pred mut_borrow_exclusive[om: OwnershipMap, l: Loc, t: ThreadId] {
  some om
}

// DR_001_exclusive_is_exclusive (matches Coq: Theorem DR_001_exclusive_is_exclusive)
assert DR_001_exclusive_is_exclusive {
  all c: MutexState | some c.mutex_locked
}
check DR_001_exclusive_is_exclusive for 5

// DR_002_shared_compatible (matches Coq: Theorem DR_002_shared_compatible)
assert DR_002_shared_compatible {
  all c: MutexState | some c.mutex_locked
}
check DR_002_shared_compatible for 5

// DR_003_well_formed_prevents_race (matches Coq: Theorem DR_003_well_formed_prevents_race)
assert DR_003_well_formed_prevents_race {
  all c: MutexState | some c.mutex_locked
}
check DR_003_well_formed_prevents_race for 5

// DR_004_well_formed_race_free (matches Coq: Theorem DR_004_well_formed_race_free)
assert DR_004_well_formed_race_free {
  all c: MutexState | some c.mutex_locked
}
check DR_004_well_formed_race_free for 5

// DR_005_mutex_acquire_unlocked (matches Coq: Theorem DR_005_mutex_acquire_unlocked)
assert DR_005_mutex_acquire_unlocked {
  all c: MutexState | some c.mutex_locked
}
check DR_005_mutex_acquire_unlocked for 5

// DR_006_mutex_acquire_locked (matches Coq: Theorem DR_006_mutex_acquire_locked)
assert DR_006_mutex_acquire_locked {
  all c: MutexState | some c.mutex_locked
}
check DR_006_mutex_acquire_locked for 5

// DR_007_mutex_release_owner (matches Coq: Theorem DR_007_mutex_release_owner)
assert DR_007_mutex_release_owner {
  all c: MutexState | some c.mutex_locked
}
check DR_007_mutex_release_owner for 5

// DR_008_mutex_release_non_owner (matches Coq: Theorem DR_008_mutex_release_non_owner)
assert DR_008_mutex_release_non_owner {
  all c: MutexState | some c.mutex_locked
}
check DR_008_mutex_release_non_owner for 5

// DR_009_rwlock_read_no_writer (matches Coq: Theorem DR_009_rwlock_read_no_writer)
assert DR_009_rwlock_read_no_writer {
  all c: MutexState | some c.mutex_locked
}
check DR_009_rwlock_read_no_writer for 5

// DR_010_rwlock_read_increments (matches Coq: Theorem DR_010_rwlock_read_increments)
assert DR_010_rwlock_read_increments {
  all c: MutexState | some c.mutex_locked
}
check DR_010_rwlock_read_increments for 5

// DR_011_rwlock_read_blocked_by_writer (matches Coq: Theorem DR_011_rwlock_read_blocked_by_writer)
assert DR_011_rwlock_read_blocked_by_writer {
  all c: MutexState | some c.mutex_locked
}
check DR_011_rwlock_read_blocked_by_writer for 5

// DR_012_rwlock_write_no_readers (matches Coq: Theorem DR_012_rwlock_write_no_readers)
assert DR_012_rwlock_write_no_readers {
  all c: MutexState | some c.mutex_locked
}
check DR_012_rwlock_write_no_readers for 5

// DR_013_rwlock_write_blocked_by_readers (matches Coq: Theorem DR_013_rwlock_write_blocked_by_readers)
assert DR_013_rwlock_write_blocked_by_readers {
  all c: MutexState | some c.mutex_locked
}
check DR_013_rwlock_write_blocked_by_readers for 5

// DR_014_mut_borrow_owned (matches Coq: Theorem DR_014_mut_borrow_owned)
assert DR_014_mut_borrow_owned {
  all c: MutexState | some c.mutex_locked
}
check DR_014_mut_borrow_owned for 5

// DR_015_shared_borrow_owned (matches Coq: Theorem DR_015_shared_borrow_owned)
assert DR_015_shared_borrow_owned {
  all c: MutexState | some c.mutex_locked
}
check DR_015_shared_borrow_owned for 5

// DR_016_shared_borrow_extends (matches Coq: Theorem DR_016_shared_borrow_extends)
assert DR_016_shared_borrow_extends {
  all c: MutexState | some c.mutex_locked
}
check DR_016_shared_borrow_extends for 5

// DR_017_empty_well_formed (matches Coq: Theorem DR_017_empty_well_formed)
assert DR_017_empty_well_formed {
  all c: MutexState | some c.mutex_locked
}
check DR_017_empty_well_formed for 5

// DR_018_empty_race_free (matches Coq: Theorem DR_018_empty_race_free)
assert DR_018_empty_race_free {
  all c: MutexState | some c.mutex_locked
}
check DR_018_empty_race_free for 5

// DR_019_single_exclusive_well_formed (matches Coq: Theorem DR_019_single_exclusive_well_formed)
assert DR_019_single_exclusive_well_formed {
  all c: MutexState | some c.mutex_locked
}
check DR_019_single_exclusive_well_formed for 5

// DR_020_single_exclusive_race_free (matches Coq: Theorem DR_020_single_exclusive_race_free)
assert DR_020_single_exclusive_race_free {
  all c: MutexState | some c.mutex_locked
}
check DR_020_single_exclusive_race_free for 5

// DR_021_mutex_mutual_exclusion (matches Coq: Theorem DR_021_mutex_mutual_exclusion)
assert DR_021_mutex_mutual_exclusion {
  all c: MutexState | some c.mutex_locked
}
check DR_021_mutex_mutual_exclusion for 5

// DR_022_init_mutex_well_formed (matches Coq: Theorem DR_022_init_mutex_well_formed)
assert DR_022_init_mutex_well_formed {
  all c: MutexState | some c.mutex_locked
}
check DR_022_init_mutex_well_formed for 5

// DR_023_acquired_mutex_well_formed (matches Coq: Theorem DR_023_acquired_mutex_well_formed)
assert DR_023_acquired_mutex_well_formed {
  all c: MutexState | some c.mutex_locked
}
check DR_023_acquired_mutex_well_formed for 5

// DR_024_rwlock_init_well_formed (matches Coq: Theorem DR_024_rwlock_init_well_formed)
assert DR_024_rwlock_init_well_formed {
  all c: MutexState | some c.mutex_locked
}
check DR_024_rwlock_init_well_formed for 5

// DR_025_shared_no_race (matches Coq: Theorem DR_025_shared_no_race)
assert DR_025_shared_no_race {
  all c: MutexState | some c.mutex_locked
}
check DR_025_shared_no_race for 5

// DR_026_access_mode_dec (matches Coq: Theorem DR_026_access_mode_dec)
assert DR_026_access_mode_dec {
  all c: MutexState | some c.mutex_locked
}
check DR_026_access_mode_dec for 5

// DR_027_remove_preserves_wf (matches Coq: Theorem DR_027_remove_preserves_wf)
assert DR_027_remove_preserves_wf {
  all c: MutexState | some c.mutex_locked
}
check DR_027_remove_preserves_wf for 5

// DR_028_race_free_location (matches Coq: Theorem DR_028_race_free_location)
assert DR_028_race_free_location {
  all c: MutexState | some c.mutex_locked
}
check DR_028_race_free_location for 5

// DR_029_ownership_state_cases (matches Coq: Theorem DR_029_ownership_state_cases)
assert DR_029_ownership_state_cases {
  all c: MutexState | some c.mutex_locked
}
check DR_029_ownership_state_cases for 5

// DR_030_valid_borrow_respects_ownership (matches Coq: Theorem DR_030_valid_borrow_respects_ownership)
assert DR_030_valid_borrow_respects_ownership {
  all c: MutexState | some c.mutex_locked
}
check DR_030_valid_borrow_respects_ownership for 5

// DR_031_mutex_locked_dec (matches Coq: Theorem DR_031_mutex_locked_dec)
assert DR_031_mutex_locked_dec {
  all c: MutexState | some c.mutex_locked
}
check DR_031_mutex_locked_dec for 5

// DR_032_rwlock_readers_nonneg (matches Coq: Theorem DR_032_rwlock_readers_nonneg)
assert DR_032_rwlock_readers_nonneg {
  all c: MutexState | some c.mutex_locked
}
check DR_032_rwlock_readers_nonneg for 5

// DR_033_mutex_acquire_release_cycle (matches Coq: Theorem DR_033_mutex_acquire_release_cycle)
assert DR_033_mutex_acquire_release_cycle {
  all c: MutexState | some c.mutex_locked
}
check DR_033_mutex_acquire_release_cycle for 5

// DR_034_access_mode_cases (matches Coq: Theorem DR_034_access_mode_cases)
assert DR_034_access_mode_cases {
  all c: MutexState | some c.mutex_locked
}
check DR_034_access_mode_cases for 5

// DR_035_no_concurrent_exclusive (matches Coq: Theorem DR_035_no_concurrent_exclusive)
assert DR_035_no_concurrent_exclusive {
  all c: MutexState | some c.mutex_locked
}
check DR_035_no_concurrent_exclusive for 5
