// SPDX-License-Identifier: MPL-2.0
// Copyright (c) 2026 The RIINA Authors.
// Auto-generated from 02_FORMAL/coq/domains/security_foundation/MemoryVirtualization.v (21 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/memory_virtualization

open util/boolean

// VMId (matches Coq: Inductive VMId)
abstract sig VMId {}
one sig VM extends VMId {}

// ProcessId (matches Coq: Inductive ProcessId)
abstract sig ProcessId {}
one sig ProcId extends ProcessId {}

// Process (matches Coq: Record Process)
sig Process {
  proc_id: one ProcessId,
  proc_vm_create_cap: one Bool // capability to create VMs
}

// VirtualMachine (matches Coq: Record VirtualMachine)
sig VirtualMachine {
  vm_id: one VMId,
  vm_ept_base: one Int,
  vm_memory_size: one Int,
  vm_creator: one ProcessId
}

// EPTEntry (matches Coq: Record EPTEntry)
sig EPTEntry {
  ept_gpa: one Int // Guest Physical Address,
  ept_hpa: one Int // Host Physical Address,
  ept_permissions: one Int // read=1, write=2, exec=4,
  ept_valid: one Bool
}

// ExtendedPageTable (matches Coq: Record ExtendedPageTable)
sig ExtendedPageTable {
  ept_id: one Int,
  ept_owner: one VMId,
  ept_entries: one list,
  ept_locked: one Bool
}

// MemVirtState (matches Coq: Record MemVirtState)
sig MemVirtState {
  all_epts: one list,
  all_vms: one list
}

// hypervisor_owns_ept (matches Coq: Definition hypervisor_owns_ept)
pred hypervisor_owns_ept[ept: ExtendedPageTable] {
  some ept
}

// has_vm_creation_capability (matches Coq: Definition has_vm_creation_capability)
pred has_vm_creation_capability[p: Process] {
  some p
}

// gpa_in_ept (matches Coq: Definition gpa_in_ept)
pred gpa_in_ept[ept: ExtendedPageTable, gpa: nat] {
  some ept
}

// perm_read (matches Coq: Definition perm_read)
pred perm_read {}

// perm_write (matches Coq: Definition perm_write)
pred perm_write {}

// perm_exec (matches Coq: Definition perm_exec)
pred perm_exec {}

// has_permission (matches Coq: Definition has_permission)
pred has_permission[entry: EPTEntry, perm: nat] {
  some entry
}

// ept_integrity (matches Coq: Theorem ept_integrity)
assert ept_integrity {
  all c: Process | some c.proc_id
}
check ept_integrity for 5

// vm_creation_authorized (matches Coq: Theorem vm_creation_authorized)
assert vm_creation_authorized {
  all c: Process | some c.proc_id
}
check vm_creation_authorized for 5

// translation_deterministic (matches Coq: Theorem translation_deterministic)
assert translation_deterministic {
  all c: Process | some c.proc_id
}
check translation_deterministic for 5

// invalid_gpa_no_translation (matches Coq: Theorem invalid_gpa_no_translation)
assert invalid_gpa_no_translation {
  all c: Process | some c.proc_id
}
check invalid_gpa_no_translation for 5

// ept_vm_isolation (matches Coq: Theorem ept_vm_isolation)
assert ept_vm_isolation {
  all c: Process | some c.proc_id
}
check ept_vm_isolation for 5

// no_cap_no_vm_creation (matches Coq: Theorem no_cap_no_vm_creation)
assert no_cap_no_vm_creation {
  all c: Process | some c.proc_id
}
check no_cap_no_vm_creation for 5

// page_table_permission_enforced (matches Coq: Theorem page_table_permission_enforced)
assert page_table_permission_enforced {
  all c: Process | some c.proc_id
}
check page_table_permission_enforced for 5

// kernel_pages_non_writable_from_user (matches Coq: Theorem kernel_pages_non_writable_from_user)
assert kernel_pages_non_writable_from_user {
  all c: Process | some c.proc_id
}
check kernel_pages_non_writable_from_user for 5

// page_fault_handler_safe (matches Coq: Theorem page_fault_handler_safe)
assert page_fault_handler_safe {
  all c: Process | some c.proc_id
}
check page_fault_handler_safe for 5

// copy_on_write_correct (matches Coq: Theorem copy_on_write_correct)
assert copy_on_write_correct {
  all c: Process | some c.proc_id
}
check copy_on_write_correct for 5

// virtual_address_canonical (matches Coq: Theorem virtual_address_canonical)
assert virtual_address_canonical {
  all c: Process | some c.proc_id
}
check virtual_address_canonical for 5

// guest_cannot_modify_any_ept (matches Coq: Theorem guest_cannot_modify_any_ept)
assert guest_cannot_modify_any_ept {
  all c: Process | some c.proc_id
}
check guest_cannot_modify_any_ept for 5

// hypervisor_owns_all_epts (matches Coq: Theorem hypervisor_owns_all_epts)
assert hypervisor_owns_all_epts {
  all c: Process | some c.proc_id
}
check hypervisor_owns_all_epts for 5

// find_ept_deterministic (matches Coq: Theorem find_ept_deterministic)
assert find_ept_deterministic {
  all c: Process | some c.proc_id
}
check find_ept_deterministic for 5

// no_ept_no_mapping (matches Coq: Theorem no_ept_no_mapping)
assert no_ept_no_mapping {
  all c: Process | some c.proc_id
}
check no_ept_no_mapping for 5

// vm_creation_records_creator (matches Coq: Theorem vm_creation_records_creator)
assert vm_creation_records_creator {
  all c: Process | some c.proc_id
}
check vm_creation_records_creator for 5

// empty_ept_no_translations (matches Coq: Theorem empty_ept_no_translations)
assert empty_ept_no_translations {
  all c: Process | some c.proc_id
}
check empty_ept_no_translations for 5

// gpa_in_ept_translation_exists (matches Coq: Theorem gpa_in_ept_translation_exists)
assert gpa_in_ept_translation_exists {
  all c: Process | some c.proc_id
}
check gpa_in_ept_translation_exists for 5

// different_vms_different_epts (matches Coq: Theorem different_vms_different_epts)
assert different_vms_different_epts {
  all c: Process | some c.proc_id
}
check different_vms_different_epts for 5

// write_protect_enforced (matches Coq: Theorem write_protect_enforced)
assert write_protect_enforced {
  all c: Process | some c.proc_id
}
check write_protect_enforced for 5

// execute_disable_respected (matches Coq: Theorem execute_disable_respected)
assert execute_disable_respected {
  all c: Process | some c.proc_id
}
check execute_disable_respected for 5
