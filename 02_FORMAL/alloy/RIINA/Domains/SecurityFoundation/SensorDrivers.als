// Copyright (c) 2026 The RIINA Authors. All rights reserved.
// Auto-generated from 02_FORMAL/coq/domains/security_foundation/SensorDrivers.v (22 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/sensor_drivers

open util/boolean

// AppId (matches Coq: Inductive AppId)
abstract sig AppId {}
one sig App extends AppId {}

// SensorType (matches Coq: Inductive SensorType)
abstract sig SensorType {}
one sig Camera extends SensorType {}
one sig Microphone extends SensorType {}
one sig GPS extends SensorType {}
one sig Accelerometer extends SensorType {}
one sig Gyroscope extends SensorType {}

// Sensor (matches Coq: Record Sensor)
sig Sensor {
  sensor_type: one SensorType,
  sensor_id: one Int
}

// Application (matches Coq: Record Application)
sig Application {
  app_id: one AppId,
  app_camera_perm: one Bool,
  app_microphone_perm: one Bool,
  app_location_perm: one Bool,
  app_motion_perm: one Bool
}

// SystemState (matches Coq: Record SystemState)
sig SystemState {
  camera_indicator: one Bool,
  mic_indicator: one Bool,
  any_camera_active: one Bool,
  any_mic_active: one Bool
}

// SensorRateLimit (matches Coq: Record SensorRateLimit)
sig SensorRateLimit {
  rate_sensor_type: one SensorType,
  rate_max_reads_per_sec: one Int,
  rate_current_reads: one Int
}

// BoundedSensor (matches Coq: Record BoundedSensor)
sig BoundedSensor {
  bs_sensor: one Sensor,
  bs_max_rate: one Int,
  bs_current_rate: one Int,
  bs_rate_ok: one bs_current_rate
}

// has_sensor_permission (matches Coq: Definition has_sensor_permission)
pred has_sensor_permission[app: Application, sensor: Sensor] {
  some app
}

// uses_camera (matches Coq: Definition uses_camera)
pred uses_camera[app: Application] {
  some app
}

// uses_microphone (matches Coq: Definition uses_microphone)
pred uses_microphone[app: Application] {
  some app
}

// indicator_visible (matches Coq: Definition indicator_visible)
pred indicator_visible[st: SystemState] {
  some st
}

// rate_limit_ok (matches Coq: Definition rate_limit_ok)
pred rate_limit_ok[rl: SensorRateLimit] {
  some rl
}

// rate_limit_exceeded (matches Coq: Definition rate_limit_exceeded)
pred rate_limit_exceeded[rl: SensorRateLimit] {
  some rl
}

// sensor_access_controlled (matches Coq: Theorem sensor_access_controlled)
assert sensor_access_controlled {
  all c: Sensor | some c.sensor_type
}
check sensor_access_controlled for 5

// recording_indicator_mandatory (matches Coq: Theorem recording_indicator_mandatory)
assert recording_indicator_mandatory {
  all c: Sensor | some c.sensor_type
}
check recording_indicator_mandatory for 5

// no_permission_no_sensor (matches Coq: Theorem no_permission_no_sensor)
assert no_permission_no_sensor {
  all c: Sensor | some c.sensor_type
}
check no_permission_no_sensor for 5

// camera_requires_camera_perm (matches Coq: Theorem camera_requires_camera_perm)
assert camera_requires_camera_perm {
  all c: Sensor | some c.sensor_type
}
check camera_requires_camera_perm for 5

// gps_requires_location_perm (matches Coq: Theorem gps_requires_location_perm)
assert gps_requires_location_perm {
  all c: Sensor | some c.sensor_type
}
check gps_requires_location_perm for 5

// rate_limit_blocks_excess (matches Coq: Theorem rate_limit_blocks_excess)
assert rate_limit_blocks_excess {
  all c: Sensor | some c.sensor_type
}
check rate_limit_blocks_excess for 5

// microphone_requires_mic_perm (matches Coq: Theorem microphone_requires_mic_perm)
assert microphone_requires_mic_perm {
  all c: Sensor | some c.sensor_type
}
check microphone_requires_mic_perm for 5

// accelerometer_requires_motion_perm (matches Coq: Theorem accelerometer_requires_motion_perm)
assert accelerometer_requires_motion_perm {
  all c: Sensor | some c.sensor_type
}
check accelerometer_requires_motion_perm for 5

// gyroscope_requires_motion_perm (matches Coq: Theorem gyroscope_requires_motion_perm)
assert gyroscope_requires_motion_perm {
  all c: Sensor | some c.sensor_type
}
check gyroscope_requires_motion_perm for 5

// no_permissions_no_sensors (matches Coq: Theorem no_permissions_no_sensors)
assert no_permissions_no_sensors {
  all c: Sensor | some c.sensor_type
}
check no_permissions_no_sensors for 5

// indicators_independent (matches Coq: Theorem indicators_independent)
assert indicators_independent {
  all c: Sensor | some c.sensor_type
}
check indicators_independent for 5

// mic_indicator_when_active (matches Coq: Theorem mic_indicator_when_active)
assert mic_indicator_when_active {
  all c: Sensor | some c.sensor_type
}
check mic_indicator_when_active for 5

// cam_indicator_when_active (matches Coq: Theorem cam_indicator_when_active)
assert cam_indicator_when_active {
  all c: Sensor | some c.sensor_type
}
check cam_indicator_when_active for 5

// both_sensors_both_indicators (matches Coq: Theorem both_sensors_both_indicators)
assert both_sensors_both_indicators {
  all c: Sensor | some c.sensor_type
}
check both_sensors_both_indicators for 5

// no_active_no_indicator_required (matches Coq: Theorem no_active_no_indicator_required)
assert no_active_no_indicator_required {
  all c: Sensor | some c.sensor_type
}
check no_active_no_indicator_required for 5

// sensor_perm_type_specific (matches Coq: Theorem sensor_perm_type_specific)
assert sensor_perm_type_specific {
  all c: Sensor | some c.sensor_type
}
check sensor_perm_type_specific for 5

// camera_perm_not_mic (matches Coq: Theorem camera_perm_not_mic)
assert camera_perm_not_mic {
  all c: Sensor | some c.sensor_type
}
check camera_perm_not_mic for 5

// motion_perm_covers_both (matches Coq: Theorem motion_perm_covers_both)
assert motion_perm_covers_both {
  all c: Sensor | some c.sensor_type
}
check motion_perm_covers_both for 5

// sensor_reading_valid (matches Coq: Theorem sensor_reading_valid)
assert sensor_reading_valid {
  all c: Sensor | some c.sensor_type
}
check sensor_reading_valid for 5

// bounded_sensor_rate_valid (matches Coq: Theorem bounded_sensor_rate_valid)
assert bounded_sensor_rate_valid {
  all c: Sensor | some c.sensor_type
}
check bounded_sensor_rate_valid for 5

// revoke_all_blocks_all_types (matches Coq: Theorem revoke_all_blocks_all_types)
assert revoke_all_blocks_all_types {
  all c: Sensor | some c.sensor_type
}
check revoke_all_blocks_all_types for 5

// gps_independent_of_camera (matches Coq: Theorem gps_independent_of_camera)
assert gps_independent_of_camera {
  all c: Sensor | some c.sensor_type
}
check gps_independent_of_camera for 5
