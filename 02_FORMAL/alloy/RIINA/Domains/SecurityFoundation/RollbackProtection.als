// SPDX-License-Identifier: MPL-2.0
// Copyright (c) 2026 The RIINA Authors.
// Auto-generated from 02_FORMAL/coq/domains/security_foundation/RollbackProtection.v (21 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/rollback_protection

open util/boolean

// ComponentId (matches Coq: Inductive ComponentId)
abstract sig ComponentId {}
one sig CompId extends ComponentId {}

// Version (matches Coq: Record Version)
sig Version {
  major: one Int,
  minor: one Int,
  patch: one Int,
  build: one Int
}

// VersionedComponent (matches Coq: Record VersionedComponent)
sig VersionedComponent {
  comp_id: one ComponentId,
  comp_version: one Version,
  comp_hash: one Int
}

// MinVersionEntry (matches Coq: Record MinVersionEntry)
sig MinVersionEntry {
  min_comp_id: one ComponentId,
  min_version: one Version,
  stored_in_hardware: one Bool
}

// RollbackState (matches Coq: Record RollbackState)
sig RollbackState {
  minimum_versions: one list,
  current_versions: one list,
  anti_rollback_enabled: one Bool
}

// version_lt (matches Coq: Definition version_lt)
pred version_lt {}

// version_le (matches Coq: Definition version_le)
pred version_le {}

// initial_rollback_state (matches Coq: Definition initial_rollback_state)
pred initial_rollback_state {}

// version_allowed (matches Coq: Definition version_allowed)
pred version_allowed[st: RollbackState, comp: ComponentId, ver: Version] {
  some st
}

// can_boot_version (matches Coq: Definition can_boot_version)
pred can_boot_version[st: RollbackState, comp: VersionedComponent] {
  some st
}

// update_min_version (matches Coq: Definition update_min_version)
pred update_min_version[st: RollbackState, comp: ComponentId, ver: Version, hw: bool] {
  some st
}

// record_current_version (matches Coq: Definition record_current_version)
pred record_current_version[st: RollbackState, comp: VersionedComponent] {
  some st
}

// advance_min_to_current (matches Coq: Definition advance_min_to_current)
pred advance_min_to_current[st: RollbackState, comp: ComponentId] {
  some st
}

// is_rollback (matches Coq: Definition is_rollback)
pred is_rollback[st: RollbackState, comp: ComponentId, ver: Version] {
  some st
}

// can_boot_prop (matches Coq: Definition can_boot_prop)
pred can_boot_prop[st: RollbackState, comp: VersionedComponent] {
  some st
}

// rollback_enforced (matches Coq: Definition rollback_enforced)
pred rollback_enforced[st: RollbackState] {
  some st
}

// rollback_protection (matches Coq: Theorem rollback_protection)
assert rollback_protection {
  all c: Version | some c.major
}
check rollback_protection for 5

// old_version_cannot_boot (matches Coq: Theorem old_version_cannot_boot)
assert old_version_cannot_boot {
  all c: Version | some c.major
}
check old_version_cannot_boot for 5

// current_or_newer_allowed (matches Coq: Theorem current_or_newer_allowed)
assert current_or_newer_allowed {
  all c: Version | some c.major
}
check current_or_newer_allowed for 5

// min_version_monotonic (matches Coq: Theorem min_version_monotonic)
assert min_version_monotonic {
  all c: Version | some c.major
}
check min_version_monotonic for 5

// no_minimum_any_allowed (matches Coq: Theorem no_minimum_any_allowed)
assert no_minimum_any_allowed {
  all c: Version | some c.major
}
check no_minimum_any_allowed for 5

// disabled_rollback_allows_all (matches Coq: Theorem disabled_rollback_allows_all)
assert disabled_rollback_allows_all {
  all c: Version | some c.major
}
check disabled_rollback_allows_all for 5

// version_lt_irreflexive (matches Coq: Theorem version_lt_irreflexive)
assert version_lt_irreflexive {
  all c: Version | some c.major
}
check version_lt_irreflexive for 5

// same_version_always_allowed (matches Coq: Theorem same_version_always_allowed)
assert same_version_always_allowed {
  all c: Version | some c.major
}
check same_version_always_allowed for 5

// update_stores_new_min (matches Coq: Theorem update_stores_new_min)
assert update_stores_new_min {
  all c: Version | some c.major
}
check update_stores_new_min for 5

// record_preserves_anti_rollback (matches Coq: Theorem record_preserves_anti_rollback)
assert record_preserves_anti_rollback {
  all c: Version | some c.major
}
check record_preserves_anti_rollback for 5

// record_preserves_minimums (matches Coq: Theorem record_preserves_minimums)
assert record_preserves_minimums {
  all c: Version | some c.major
}
check record_preserves_minimums for 5

// update_preserves_anti_rollback (matches Coq: Theorem update_preserves_anti_rollback)
assert update_preserves_anti_rollback {
  all c: Version | some c.major
}
check update_preserves_anti_rollback for 5

// advance_preserves_anti_rollback (matches Coq: Theorem advance_preserves_anti_rollback)
assert advance_preserves_anti_rollback {
  all c: Version | some c.major
}
check advance_preserves_anti_rollback for 5

// equal_version_not_rollback (matches Coq: Theorem equal_version_not_rollback)
assert equal_version_not_rollback {
  all c: Version | some c.major
}
check equal_version_not_rollback for 5

// initial_state_allows_all (matches Coq: Theorem initial_state_allows_all)
assert initial_state_allows_all {
  all c: Version | some c.major
}
check initial_state_allows_all for 5

// initial_state_no_minimums (matches Coq: Theorem initial_state_no_minimums)
assert initial_state_no_minimums {
  all c: Version | some c.major
}
check initial_state_no_minimums for 5

// initial_state_no_current (matches Coq: Theorem initial_state_no_current)
assert initial_state_no_current {
  all c: Version | some c.major
}
check initial_state_no_current for 5

// enforced_detects_rollback (matches Coq: Theorem enforced_detects_rollback)
assert enforced_detects_rollback {
  all c: Version | some c.major
}
check enforced_detects_rollback for 5

// hardware_stored_minimum_recorded (matches Coq: Theorem hardware_stored_minimum_recorded)
assert hardware_stored_minimum_recorded {
  all c: Version | some c.major
}
check hardware_stored_minimum_recorded for 5

// advance_missing_current_identity (matches Coq: Theorem advance_missing_current_identity)
assert advance_missing_current_identity {
  all c: Version | some c.major
}
check advance_missing_current_identity for 5

// independent_component_minimums (matches Coq: Theorem independent_component_minimums)
assert independent_component_minimums {
  all c: Version | some c.major
}
check independent_component_minimums for 5
