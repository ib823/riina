// Copyright (c) 2026 The RIINA Authors. All rights reserved.
// Auto-generated from 02_FORMAL/coq/domains/security_foundation/InterruptVirtualization.v (21 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/interrupt_virtualization

open util/boolean

// VMId (matches Coq: Inductive VMId)
abstract sig VMId {}
one sig VM extends VMId {}

// Interrupt (matches Coq: Inductive Interrupt)
abstract sig Interrupt {}
one sig IRQ extends Interrupt {}

// InterruptSource (matches Coq: Inductive InterruptSource)
abstract sig InterruptSource {}
one sig DeviceSource extends InterruptSource {}
one sig TimerSource extends InterruptSource {}
one sig IPISource extends InterruptSource {}

// VirtualMachine (matches Coq: Record VirtualMachine)
sig VirtualMachine {
  vm_id: one VMId,
  vm_assigned_irqs: one list
}

// InterruptState (matches Coq: Record InterruptState)
sig InterruptState {
  irq_assignments: one list,
  ipi_allowed: one list
}

// InterruptPriority (matches Coq: Record InterruptPriority)
sig InterruptPriority {
  irq_number: one Int,
  irq_priority: one Int,
  irq_enabled: one Bool,
  irq_pending: one Bool
}

// InterruptController (matches Coq: Record InterruptController)
sig InterruptController {
  ctrl_irqs: one list,
  ctrl_mask_threshold: one Int // IRQs below this priority are masked
}

// vm_owns_irq (matches Coq: Definition vm_owns_irq)
pred vm_owns_irq[st: InterruptState, vm: VirtualMachine, irq: nat] {
  some st
}

// ipi_authorized (matches Coq: Definition ipi_authorized)
pred ipi_authorized[st: InterruptState] {
  some st
}

// authorized_injection (matches Coq: Definition authorized_injection)
pred authorized_injection[st: InterruptState, source: InterruptSource, target: VirtualMachine] {
  some st
}

// can_inject (matches Coq: Definition can_inject)
pred can_inject[st: InterruptState, vm1: VirtualMachine, irq: Interrupt, vm2: VirtualMachine] {
  some st
}

// irq_deliverable (matches Coq: Definition irq_deliverable)
pred irq_deliverable[ctrl: InterruptController, irq: nat] {
  some ctrl
}

// interrupt_injection_authorized (matches Coq: Theorem interrupt_injection_authorized)
assert interrupt_injection_authorized {
  all c: VirtualMachine | some c.vm_id
}
check interrupt_injection_authorized for 5

// interrupt_isolation (matches Coq: Theorem interrupt_isolation)
assert interrupt_isolation {
  all c: VirtualMachine | some c.vm_id
}
check interrupt_isolation for 5

// device_irq_unique_owner (matches Coq: Theorem device_irq_unique_owner)
assert device_irq_unique_owner {
  all c: VirtualMachine | some c.vm_id
}
check device_irq_unique_owner for 5

// timer_interrupt_local (matches Coq: Theorem timer_interrupt_local)
assert timer_interrupt_local {
  all c: VirtualMachine | some c.vm_id
}
check timer_interrupt_local for 5

// ipi_requires_authorization (matches Coq: Theorem ipi_requires_authorization)
assert ipi_requires_authorization {
  all c: VirtualMachine | some c.vm_id
}
check ipi_requires_authorization for 5

// unauthorized_ipi_blocked (matches Coq: Theorem unauthorized_ipi_blocked)
assert unauthorized_ipi_blocked {
  all c: VirtualMachine | some c.vm_id
}
check unauthorized_ipi_blocked for 5

// self_injection_allowed (matches Coq: Theorem self_injection_allowed)
assert self_injection_allowed {
  all c: VirtualMachine | some c.vm_id
}
check self_injection_allowed for 5

// masked_irq_not_deliverable (matches Coq: Theorem masked_irq_not_deliverable)
assert masked_irq_not_deliverable {
  all c: VirtualMachine | some c.vm_id
}
check masked_irq_not_deliverable for 5

// disabled_irq_not_deliverable (matches Coq: Theorem disabled_irq_not_deliverable)
assert disabled_irq_not_deliverable {
  all c: VirtualMachine | some c.vm_id
}
check disabled_irq_not_deliverable for 5

// non_pending_irq_not_deliverable (matches Coq: Theorem non_pending_irq_not_deliverable)
assert non_pending_irq_not_deliverable {
  all c: VirtualMachine | some c.vm_id
}
check non_pending_irq_not_deliverable for 5

// unknown_irq_not_deliverable (matches Coq: Theorem unknown_irq_not_deliverable)
assert unknown_irq_not_deliverable {
  all c: VirtualMachine | some c.vm_id
}
check unknown_irq_not_deliverable for 5

// no_auth_no_injection (matches Coq: Theorem no_auth_no_injection)
assert no_auth_no_injection {
  all c: VirtualMachine | some c.vm_id
}
check no_auth_no_injection for 5

// device_irq_requires_ownership (matches Coq: Theorem device_irq_requires_ownership)
assert device_irq_requires_ownership {
  all c: VirtualMachine | some c.vm_id
}
check device_irq_requires_ownership for 5

// cross_vm_requires_ipi (matches Coq: Theorem cross_vm_requires_ipi)
assert cross_vm_requires_ipi {
  all c: VirtualMachine | some c.vm_id
}
check cross_vm_requires_ipi for 5

// ipi_authorization_directional (matches Coq: Theorem ipi_authorization_directional)
assert ipi_authorization_directional {
  all c: VirtualMachine | some c.vm_id
}
check ipi_authorization_directional for 5

// empty_ipi_blocks_cross_vm (matches Coq: Theorem empty_ipi_blocks_cross_vm)
assert empty_ipi_blocks_cross_vm {
  all c: VirtualMachine | some c.vm_id
}
check empty_ipi_blocks_cross_vm for 5

// empty_assignments_blocks_device_irqs (matches Coq: Theorem empty_assignments_blocks_device_irqs)
assert empty_assignments_blocks_device_irqs {
  all c: VirtualMachine | some c.vm_id
}
check empty_assignments_blocks_device_irqs for 5

// irq_assignment_deterministic (matches Coq: Theorem irq_assignment_deterministic)
assert irq_assignment_deterministic {
  all c: VirtualMachine | some c.vm_id
}
check irq_assignment_deterministic for 5

// timer_injection_always_succeeds (matches Coq: Theorem timer_injection_always_succeeds)
assert timer_injection_always_succeeds {
  all c: VirtualMachine | some c.vm_id
}
check timer_injection_always_succeeds for 5

// self_ipi_possible (matches Coq: Theorem self_ipi_possible)
assert self_ipi_possible {
  all c: VirtualMachine | some c.vm_id
}
check self_ipi_possible for 5

// injection_source_valid (matches Coq: Theorem injection_source_valid)
assert injection_source_valid {
  all c: VirtualMachine | some c.vm_id
}
check injection_source_valid for 5
