// Copyright (c) 2026 The RIINA Authors. All rights reserved.
// Auto-generated from 02_FORMAL/coq/domains/security_foundation/IOMMUProtection.v (22 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/iommu_protection

open util/boolean

// DeviceId (matches Coq: Inductive DeviceId)
abstract sig DeviceId {}
one sig DevId extends DeviceId {}

// VMId (matches Coq: Inductive VMId)
abstract sig VMId {}
one sig VM extends VMId {}

// Address (matches Coq: Inductive Address)
abstract sig Address {}
one sig Addr extends Address {}

// Device (matches Coq: Record Device)
sig Device {
  dev_id: one DeviceId,
  dev_bus: one Int,
  dev_function: one Int
}

// VirtualMachine (matches Coq: Record VirtualMachine)
sig VirtualMachine {
  vm_id: one VMId,
  vm_dma_base: one Int,
  vm_dma_size: one Int
}

// IOMMUConfig (matches Coq: Record IOMMUConfig)
sig IOMMUConfig {
  config_device: one DeviceId,
  config_allowed_base: one Int,
  config_allowed_size: one Int,
  config_locked: one Bool
}

// IOMMU (matches Coq: Record IOMMU)
sig IOMMU {
  iommu_id: one Int,
  iommu_configs: one list,
  iommu_enabled: one Bool
}

// address_in_range (matches Coq: Definition address_in_range)
pred address_in_range[addr: nat, cfg: IOMMUConfig] {
  some addr
}

// iommu_permits_dma (matches Coq: Definition iommu_permits_dma)
pred iommu_permits_dma[iommu: IOMMU, dev: Device, addr: Address] {
  some iommu
}

// guest_isolated_from_iommu (matches Coq: Definition guest_isolated_from_iommu)
pred guest_isolated_from_iommu[vm: VirtualMachine, iommu: IOMMU] {
  some vm
}

// kernel_region_base (matches Coq: Definition kernel_region_base)
pred kernel_region_base {}

// kernel_region_size (matches Coq: Definition kernel_region_size)
pred kernel_region_size {}

// dma_isolation (matches Coq: Theorem dma_isolation)
assert dma_isolation {
  all c: Device | some c.dev_id
}
check dma_isolation for 5

// iommu_config_protected (matches Coq: Theorem iommu_config_protected)
assert iommu_config_protected {
  all c: Device | some c.dev_id
}
check iommu_config_protected for 5

// iommu_config_protected_v2 (matches Coq: Theorem iommu_config_protected_v2)
assert iommu_config_protected_v2 {
  all c: Device | some c.dev_id
}
check iommu_config_protected_v2 for 5

// dma_requires_iommu_enabled (matches Coq: Theorem dma_requires_iommu_enabled)
assert dma_requires_iommu_enabled {
  all c: Device | some c.dev_id
}
check dma_requires_iommu_enabled for 5

// unconfigured_device_no_dma (matches Coq: Theorem unconfigured_device_no_dma)
assert unconfigured_device_no_dma {
  all c: Device | some c.dev_id
}
check unconfigured_device_no_dma for 5

// out_of_range_dma_blocked (matches Coq: Theorem out_of_range_dma_blocked)
assert out_of_range_dma_blocked {
  all c: Device | some c.dev_id
}
check out_of_range_dma_blocked for 5

// iommu_lockdown_effective (matches Coq: Theorem iommu_lockdown_effective)
assert iommu_lockdown_effective {
  all c: Device | some c.dev_id
}
check iommu_lockdown_effective for 5

// dma_isolation_enforced (matches Coq: Theorem dma_isolation_enforced)
assert dma_isolation_enforced {
  all c: Device | some c.dev_id
}
check dma_isolation_enforced for 5

// device_address_bounded (matches Coq: Theorem device_address_bounded)
assert device_address_bounded {
  all c: Device | some c.dev_id
}
check device_address_bounded for 5

// mapping_table_consistent (matches Coq: Theorem mapping_table_consistent)
assert mapping_table_consistent {
  all c: Device | some c.dev_id
}
check mapping_table_consistent for 5

// no_dma_to_kernel (matches Coq: Theorem no_dma_to_kernel)
assert no_dma_to_kernel {
  all c: Device | some c.dev_id
}
check no_dma_to_kernel for 5

// iommu_bypass_impossible (matches Coq: Theorem iommu_bypass_impossible)
assert iommu_bypass_impossible {
  all c: Device | some c.dev_id
}
check iommu_bypass_impossible for 5

// address_range_lower_bound (matches Coq: Theorem address_range_lower_bound)
assert address_range_lower_bound {
  all c: Device | some c.dev_id
}
check address_range_lower_bound for 5

// address_range_upper_bound (matches Coq: Theorem address_range_upper_bound)
assert address_range_upper_bound {
  all c: Device | some c.dev_id
}
check address_range_upper_bound for 5

// device_identity_verified (matches Coq: Theorem device_identity_verified)
assert device_identity_verified {
  all c: Device | some c.dev_id
}
check device_identity_verified for 5

// empty_config_denies_all (matches Coq: Theorem empty_config_denies_all)
assert empty_config_denies_all {
  all c: Device | some c.dev_id
}
check empty_config_denies_all for 5

// disabled_iommu_denies_all (matches Coq: Theorem disabled_iommu_denies_all)
assert disabled_iommu_denies_all {
  all c: Device | some c.dev_id
}
check disabled_iommu_denies_all for 5

// locked_config_invariant (matches Coq: Theorem locked_config_invariant)
assert locked_config_invariant {
  all c: Device | some c.dev_id
}
check locked_config_invariant for 5

// zero_size_config_denies (matches Coq: Theorem zero_size_config_denies)
assert zero_size_config_denies {
  all c: Device | some c.dev_id
}
check zero_size_config_denies for 5

// find_device_config_none_not_in (matches Coq: Theorem find_device_config_none_not_in)
assert find_device_config_none_not_in {
  all c: Device | some c.dev_id
}
check find_device_config_none_not_in for 5

// find_device_config_some_matches (matches Coq: Theorem find_device_config_some_matches)
assert find_device_config_some_matches {
  all c: Device | some c.dev_id
}
check find_device_config_some_matches for 5

// independent_device_configs (matches Coq: Theorem independent_device_configs)
assert independent_device_configs {
  all c: Device | some c.dev_id
}
check independent_device_configs for 5
