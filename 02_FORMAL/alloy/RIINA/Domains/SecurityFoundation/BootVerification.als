// SPDX-License-Identifier: MPL-2.0
// Copyright (c) 2026 The RIINA Authors.
// Auto-generated from 02_FORMAL/coq/domains/security_foundation/BootVerification.v (22 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/boot_verification

open util/boolean

// BootStageId (matches Coq: Inductive BootStageId)
abstract sig BootStageId {}
one sig HardwareRoot extends BootStageId {} // Hardware root of trust
one sig Bootloader extends BootStageId {} // Primary bootloader
one sig SecondStage extends BootStageId {} // Secondary bootloader
one sig Kernel extends BootStageId {} // OS kernel
one sig InitRamFS extends BootStageId {}

// VerificationResult (matches Coq: Inductive VerificationResult)
abstract sig VerificationResult {}
one sig Verified extends VerificationResult {}
one sig HashMismatch extends VerificationResult {}
one sig SignatureInvalid extends VerificationResult {}
one sig VersionRollback extends VerificationResult {}

// BootImage (matches Coq: Record BootImage)
sig BootImage {
  image_stage: one BootStageId,
  image_hash: one Int,
  image_signature: one Int,
  image_version: one Int
}

// ExpectedHash (matches Coq: Record ExpectedHash)
sig ExpectedHash {
  expected_stage: one BootStageId,
  expected_hash_value: one Int,
  expected_public_key: one Int
}

// BootChainState (matches Coq: Record BootChainState)
sig BootChainState {
  verified_stages: one list,
  current_stage: one BootStageId,
  expected_hashes: one list,
  minimum_versions: one list,
  boot_successful: one Bool
}

// initial_boot_state (matches Coq: Definition initial_boot_state)
pred initial_boot_state {}

// previous_stage (matches Coq: Definition previous_stage)
pred previous_stage[stage: BootStageId] {
  some stage
}

// stage_verified (matches Coq: Definition stage_verified)
pred stage_verified[st: BootChainState, stage: BootStageId] {
  some st
}

// verify_image (matches Coq: Definition verify_image)
pred verify_image[st: BootChainState, img: BootImage] {
  some st
}

// image_tampered (matches Coq: Definition image_tampered)
pred image_tampered[st: BootChainState, img: BootImage] {
  some st
}

// boot_stage (matches Coq: Definition boot_stage)
pred boot_stage[st: BootChainState, img: BootImage] {
  some st
}

// complete_boot (matches Coq: Definition complete_boot)
pred complete_boot[st: BootChainState] {
  some st
}

// stage_boots (matches Coq: Definition stage_boots)
pred stage_boots[stage: BootStageId] {
  some stage
}

// verified_by_previous (matches Coq: Definition verified_by_previous)
pred verified_by_previous[st: BootChainState, stage: BootStageId] {
  some st
}

// is_tampered (matches Coq: Definition is_tampered)
pred is_tampered[st: BootChainState, img: BootImage] {
  some st
}

// can_boot (matches Coq: Definition can_boot)
pred can_boot[st: BootChainState, img: BootImage] {
  some st
}

// boot_chain_verified (matches Coq: Theorem boot_chain_verified)
assert boot_chain_verified {
  all c: BootImage | some c.image_stage
}
check boot_chain_verified for 5

// boot_tampering_detected (matches Coq: Theorem boot_tampering_detected)
assert boot_tampering_detected {
  all c: BootImage | some c.image_stage
}
check boot_tampering_detected for 5

// failed_verification_no_boot (matches Coq: Theorem failed_verification_no_boot)
assert failed_verification_no_boot {
  all c: BootImage | some c.image_stage
}
check failed_verification_no_boot for 5

// hardware_root_verified (matches Coq: Theorem hardware_root_verified)
assert hardware_root_verified {
  all c: BootImage | some c.image_stage
}
check hardware_root_verified for 5

// boot_requires_verification (matches Coq: Theorem boot_requires_verification)
assert boot_requires_verification {
  all c: BootImage | some c.image_stage
}
check boot_requires_verification for 5

// verification_preserves_previous (matches Coq: Theorem verification_preserves_previous)
assert verification_preserves_previous {
  all c: BootImage | some c.image_stage
}
check verification_preserves_previous for 5

// each_stage_verifies_next (matches Coq: Theorem each_stage_verifies_next)
assert each_stage_verifies_next {
  all c: BootImage | some c.image_stage
}
check each_stage_verifies_next for 5

// root_of_trust_immutable (matches Coq: Theorem root_of_trust_immutable)
assert root_of_trust_immutable {
  all c: BootImage | some c.image_stage
}
check root_of_trust_immutable for 5

// firmware_rollback_prevented (matches Coq: Theorem firmware_rollback_prevented)
assert firmware_rollback_prevented {
  all c: BootImage | some c.image_stage
}
check firmware_rollback_prevented for 5

// boot_log_only_grows (matches Coq: Theorem boot_log_only_grows)
assert boot_log_only_grows {
  all c: BootImage | some c.image_stage
}
check boot_log_only_grows for 5

// hash_mismatch_detected (matches Coq: Theorem hash_mismatch_detected)
assert hash_mismatch_detected {
  all c: BootImage | some c.image_stage
}
check hash_mismatch_detected for 5

// recovery_mode_requires_hash (matches Coq: Theorem recovery_mode_requires_hash)
assert recovery_mode_requires_hash {
  all c: BootImage | some c.image_stage
}
check recovery_mode_requires_hash for 5

// boot_stage_deterministic (matches Coq: Theorem boot_stage_deterministic)
assert boot_stage_deterministic {
  all c: BootImage | some c.image_stage
}
check boot_stage_deterministic for 5

// config_table_validated (matches Coq: Theorem config_table_validated)
assert config_table_validated {
  all c: BootImage | some c.image_stage
}
check config_table_validated for 5

// kernel_signature_checked (matches Coq: Theorem kernel_signature_checked)
assert kernel_signature_checked {
  all c: BootImage | some c.image_stage
}
check kernel_signature_checked for 5

// bootloader_follows_root (matches Coq: Theorem bootloader_follows_root)
assert bootloader_follows_root {
  all c: BootImage | some c.image_stage
}
check bootloader_follows_root for 5

// second_stage_follows_bootloader (matches Coq: Theorem second_stage_follows_bootloader)
assert second_stage_follows_bootloader {
  all c: BootImage | some c.image_stage
}
check second_stage_follows_bootloader for 5

// kernel_follows_second_stage (matches Coq: Theorem kernel_follows_second_stage)
assert kernel_follows_second_stage {
  all c: BootImage | some c.image_stage
}
check kernel_follows_second_stage for 5

// initramfs_follows_kernel (matches Coq: Theorem initramfs_follows_kernel)
assert initramfs_follows_kernel {
  all c: BootImage | some c.image_stage
}
check initramfs_follows_kernel for 5

// hardware_root_self_previous (matches Coq: Theorem hardware_root_self_previous)
assert hardware_root_self_previous {
  all c: BootImage | some c.image_stage
}
check hardware_root_self_previous for 5

// complete_boot_sets_success (matches Coq: Theorem complete_boot_sets_success)
assert complete_boot_sets_success {
  all c: BootImage | some c.image_stage
}
check complete_boot_sets_success for 5

// complete_boot_preserves_verified (matches Coq: Theorem complete_boot_preserves_verified)
assert complete_boot_preserves_verified {
  all c: BootImage | some c.image_stage
}
check complete_boot_preserves_verified for 5
