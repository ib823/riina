// SPDX-License-Identifier: MPL-2.0
// Copyright (c) 2026 The RIINA Authors.
// Auto-generated from 02_FORMAL/coq/domains/security_foundation/NetworkDriver.v (21 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/network_driver

open util/boolean

// AppId (matches Coq: Inductive AppId)
abstract sig AppId {}
one sig App extends AppId {}

// SocketId (matches Coq: Inductive SocketId)
abstract sig SocketId {}
one sig SockId extends SocketId {}

// Application (matches Coq: Record Application)
sig Application {
  app_id: one AppId,
  app_network_perm: one Bool
}

// Socket (matches Coq: Record Socket)
sig Socket {
  socket_id: one SocketId,
  socket_owner: one AppId,
  socket_port: one Int,
  socket_bound: one Bool
}

// NetworkState (matches Coq: Record NetworkState)
sig NetworkState {
  all_sockets: one list,
  firewall_enabled: one Bool
}

// FirewallRule (matches Coq: Record FirewallRule)
sig FirewallRule {
  fw_src_port: one Int,
  fw_dst_port: one Int,
  fw_allowed: one Bool
}

// ExtNetworkState (matches Coq: Record ExtNetworkState)
sig ExtNetworkState {
  ext_sockets: one list,
  ext_firewall_enabled: one Bool,
  ext_firewall_rules: one list
}

// owns_socket (matches Coq: Definition owns_socket)
pred owns_socket[app: Application, sock: Socket] {
  some app
}

// socket_usable (matches Coq: Definition socket_usable)
pred socket_usable[sock: Socket] {
  some sock
}

// has_network_permission (matches Coq: Definition has_network_permission)
pred has_network_permission[app: Application] {
  some app
}

// network_isolation (matches Coq: Theorem network_isolation)
assert network_isolation {
  all c: Application | some c.app_id
}
check network_isolation for 5

// socket_ownership_exclusive (matches Coq: Theorem socket_ownership_exclusive)
assert socket_ownership_exclusive {
  all c: Application | some c.app_id
}
check socket_ownership_exclusive for 5

// unbound_socket_not_usable (matches Coq: Theorem unbound_socket_not_usable)
assert unbound_socket_not_usable {
  all c: Application | some c.app_id
}
check unbound_socket_not_usable for 5

// send_requires_network_permission (matches Coq: Theorem send_requires_network_permission)
assert send_requires_network_permission {
  all c: Application | some c.app_id
}
check send_requires_network_permission for 5

// receive_requires_network_permission (matches Coq: Theorem receive_requires_network_permission)
assert receive_requires_network_permission {
  all c: Application | some c.app_id
}
check receive_requires_network_permission for 5

// no_perm_blocks_send (matches Coq: Theorem no_perm_blocks_send)
assert no_perm_blocks_send {
  all c: Application | some c.app_id
}
check no_perm_blocks_send for 5

// no_perm_blocks_receive (matches Coq: Theorem no_perm_blocks_receive)
assert no_perm_blocks_receive {
  all c: Application | some c.app_id
}
check no_perm_blocks_receive for 5

// unbound_blocks_send (matches Coq: Theorem unbound_blocks_send)
assert unbound_blocks_send {
  all c: Application | some c.app_id
}
check unbound_blocks_send for 5

// unbound_blocks_receive (matches Coq: Theorem unbound_blocks_receive)
assert unbound_blocks_receive {
  all c: Application | some c.app_id
}
check unbound_blocks_receive for 5

// default_deny_firewall (matches Coq: Theorem default_deny_firewall)
assert default_deny_firewall {
  all c: Application | some c.app_id
}
check default_deny_firewall for 5

// cross_app_socket_impossible (matches Coq: Theorem cross_app_socket_impossible)
assert cross_app_socket_impossible {
  all c: Application | some c.app_id
}
check cross_app_socket_impossible for 5

// cross_app_receive_impossible (matches Coq: Theorem cross_app_receive_impossible)
assert cross_app_receive_impossible {
  all c: Application | some c.app_id
}
check cross_app_receive_impossible for 5

// send_implies_bound (matches Coq: Theorem send_implies_bound)
assert send_implies_bound {
  all c: Application | some c.app_id
}
check send_implies_bound for 5

// receive_implies_bound (matches Coq: Theorem receive_implies_bound)
assert receive_implies_bound {
  all c: Application | some c.app_id
}
check receive_implies_bound for 5

// socket_isolation_by_owner (matches Coq: Theorem socket_isolation_by_owner)
assert socket_isolation_by_owner {
  all c: Application | some c.app_id
}
check socket_isolation_by_owner for 5

// access_control_consistent (matches Coq: Theorem access_control_consistent)
assert access_control_consistent {
  all c: Application | some c.app_id
}
check access_control_consistent for 5

// network_perm_required_both_directions (matches Coq: Theorem network_perm_required_both_directions)
assert network_perm_required_both_directions {
  all c: Application | some c.app_id
}
check network_perm_required_both_directions for 5

// full_network_isolation (matches Coq: Theorem full_network_isolation)
assert full_network_isolation {
  all c: Application | some c.app_id
}
check full_network_isolation for 5

// bound_implies_usable (matches Coq: Theorem bound_implies_usable)
assert bound_implies_usable {
  all c: Application | some c.app_id
}
check bound_implies_usable for 5

// firewall_protects (matches Coq: Theorem firewall_protects)
assert firewall_protects {
  all c: Application | some c.app_id
}
check firewall_protects for 5

// socket_port_nonneg (matches Coq: Theorem socket_port_nonneg)
assert socket_port_nonneg {
  all c: Application | some c.app_id
}
check socket_port_nonneg for 5
