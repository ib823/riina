// Copyright (c) 2026 The RIINA Authors. All rights reserved.
// Auto-generated from 02_FORMAL/coq/domains/mobile_os/TouchGestureSystem.v (21 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/touch_gesture_system

open util/boolean

// GestureType (matches Coq: Inductive GestureType)
abstract sig GestureType {}
one sig Tap extends GestureType {}
one sig DoubleTap extends GestureType {}
one sig LongPress extends GestureType {}
one sig Swipe extends GestureType {}
one sig Pinch extends GestureType {}
one sig Rotate extends GestureType {}
one sig Pan extends GestureType {}
one sig Unknown extends GestureType {}

// TouchEvent (matches Coq: Record TouchEvent)
sig TouchEvent {
  touch_id: one Int,
  touch_position: one Coordinate,
  touch_timestamp: one Int,
  touch_pressure: one Int,
  touch_is_physical: one Bool,
  touch_registered: one Bool,
  touch_display_latency: one Microseconds
}

// MultiTouchState (matches Coq: Record MultiTouchState)
sig MultiTouchState {
  active_touches: one list,
  max_simultaneous: one Int,
  coalesced_events: one list,
  predicted_events: one list
}

// Microseconds (matches Coq: Definition Microseconds)
pred Microseconds {}

// Coordinate (matches Coq: Definition Coordinate)
pred Coordinate {}

// TouchSequence (matches Coq: Definition TouchSequence)
pred TouchSequence {}

// physical_touch (matches Coq: Definition physical_touch)
pred physical_touch[t: TouchEvent] {
  some t
}

// registered (matches Coq: Definition registered)
pred registered[t: TouchEvent] {
  some t
}

// display_latency (matches Coq: Definition display_latency)
pred display_latency[t: TouchEvent] {
  some t
}

// latency_bound (matches Coq: Definition latency_bound)
pred latency_bound {}

// touch_system_correct (matches Coq: Definition touch_system_correct)
pred touch_system_correct[t: TouchEvent] {
  some t
}

// intended_gesture (matches Coq: Definition intended_gesture)
pred intended_gesture[seq: TouchSequence, g: GestureType] {
  some seq
}

// recognized_gesture (matches Coq: Definition recognized_gesture)
pred recognized_gesture[seq: TouchSequence] {
  some seq
}

// touch_area (matches Coq: Definition touch_area)
pred touch_area[t: TouchEvent] {
  some t
}

// touch_area_minimum (matches Coq: Definition touch_area_minimum)
pred touch_area_minimum {}

// touch_pressure_max (matches Coq: Definition touch_pressure_max)
pred touch_pressure_max {}

// touch_latency_max (matches Coq: Definition touch_latency_max)
pred touch_latency_max {}

// is_hover_event (matches Coq: Definition is_hover_event)
pred is_hover_event[t: TouchEvent] {
  some t
}

// is_stylus_event (matches Coq: Definition is_stylus_event)
pred is_stylus_event[t: TouchEvent] {
  some t
}

// edge_margin (matches Coq: Definition edge_margin)
pred edge_margin {}

// is_edge_touch (matches Coq: Definition is_edge_touch)
pred is_edge_touch[t: TouchEvent] {
  some t
}

// is_accidental_touch (matches Coq: Definition is_accidental_touch)
pred is_accidental_touch[t: TouchEvent] {
  some t
}

// gesture_priority (matches Coq: Definition gesture_priority)
pred gesture_priority[g: GestureType] {
  some g
}

// touch_cancelled (matches Coq: Definition touch_cancelled)
pred touch_cancelled[seq: TouchSequence] {
  some seq
}

// multi_touch_count (matches Coq: Definition multi_touch_count)
pred multi_touch_count[mt: MultiTouchState] {
  some mt
}

// well_formed_multi_touch (matches Coq: Definition well_formed_multi_touch)
pred well_formed_multi_touch[mt: MultiTouchState] {
  some mt
}

// touch_latency_bounded (matches Coq: Theorem touch_latency_bounded)
assert touch_latency_bounded {
  all c: TouchEvent | some c.touch_id
}
check touch_latency_bounded for 5

// touch_registration_complete (matches Coq: Theorem touch_registration_complete)
assert touch_registration_complete {
  all c: TouchEvent | some c.touch_id
}
check touch_registration_complete for 5

// no_ghost_touches (matches Coq: Theorem no_ghost_touches)
assert no_ghost_touches {
  all c: TouchEvent | some c.touch_id
}
check no_ghost_touches for 5

// gesture_recognition_tap (matches Coq: Theorem gesture_recognition_tap)
assert gesture_recognition_tap {
  all c: TouchEvent | some c.touch_id
}
check gesture_recognition_tap for 5

// touch_physical_registered_equiv (matches Coq: Theorem touch_physical_registered_equiv)
assert touch_physical_registered_equiv {
  all c: TouchEvent | some c.touch_id
}
check touch_physical_registered_equiv for 5

// touch_event_ordered (matches Coq: Theorem touch_event_ordered)
assert touch_event_ordered {
  all c: TouchEvent | some c.touch_id
}
check touch_event_ordered for 5

// multi_touch_tracked (matches Coq: Theorem multi_touch_tracked)
assert multi_touch_tracked {
  all c: TouchEvent | some c.touch_id
}
check multi_touch_tracked for 5

// touch_cancel_handled (matches Coq: Theorem touch_cancel_handled)
assert touch_cancel_handled {
  all c: TouchEvent | some c.touch_id
}
check touch_cancel_handled for 5

// gesture_priority_defined (matches Coq: Theorem gesture_priority_defined)
assert gesture_priority_defined {
  all c: TouchEvent | some c.touch_id
}
check gesture_priority_defined for 5

// touch_area_at_least_minimum (matches Coq: Theorem touch_area_at_least_minimum)
assert touch_area_at_least_minimum {
  all c: TouchEvent | some c.touch_id
}
check touch_area_at_least_minimum for 5

// touch_pressure_bounded (matches Coq: Theorem touch_pressure_bounded)
assert touch_pressure_bounded {
  all c: TouchEvent | some c.touch_id
}
check touch_pressure_bounded for 5

// touch_latency_bounded_16ms (matches Coq: Theorem touch_latency_bounded_16ms)
assert touch_latency_bounded_16ms {
  all c: TouchEvent | some c.touch_id
}
check touch_latency_bounded_16ms for 5

// hover_event_supported (matches Coq: Theorem hover_event_supported)
assert hover_event_supported {
  all c: TouchEvent | some c.touch_id
}
check hover_event_supported for 5

// stylus_pressure_sensitive (matches Coq: Theorem stylus_pressure_sensitive)
assert stylus_pressure_sensitive {
  all c: TouchEvent | some c.touch_id
}
check stylus_pressure_sensitive for 5

// touch_coalescing_correct (matches Coq: Theorem touch_coalescing_correct)
assert touch_coalescing_correct {
  all c: TouchEvent | some c.touch_id
}
check touch_coalescing_correct for 5

// touch_prediction_bounded (matches Coq: Theorem touch_prediction_bounded)
assert touch_prediction_bounded {
  all c: TouchEvent | some c.touch_id
}
check touch_prediction_bounded for 5

// edge_touch_distinguished (matches Coq: Theorem edge_touch_distinguished)
assert edge_touch_distinguished {
  all c: TouchEvent | some c.touch_id
}
check edge_touch_distinguished for 5

// accidental_touch_rejected (matches Coq: Theorem accidental_touch_rejected)
assert accidental_touch_rejected {
  all c: TouchEvent | some c.touch_id
}
check accidental_touch_rejected for 5

// touch_event_timestamp_monotonic_single (matches Coq: Theorem touch_event_timestamp_monotonic_single)
assert touch_event_timestamp_monotonic_single {
  all c: TouchEvent | some c.touch_id
}
check touch_event_timestamp_monotonic_single for 5

// simultaneous_gesture_resolution (matches Coq: Theorem simultaneous_gesture_resolution)
assert simultaneous_gesture_resolution {
  all c: TouchEvent | some c.touch_id
}
check simultaneous_gesture_resolution for 5

// unknown_gesture_lowest_priority (matches Coq: Theorem unknown_gesture_lowest_priority)
assert unknown_gesture_lowest_priority {
  all c: TouchEvent | some c.touch_id
}
check unknown_gesture_lowest_priority for 5
