// SPDX-License-Identifier: MPL-2.0
// Copyright (c) 2026 The RIINA Authors.
// Auto-generated from 02_FORMAL/coq/domains/mobile_os/LocationServices.v (22 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/location_services

open util/boolean

// LocationPermission (matches Coq: Inductive LocationPermission)
abstract sig LocationPermission {}
one sig PermNone extends LocationPermission {}
one sig PermWhenInUse extends LocationPermission {}
one sig PermAlways extends LocationPermission {}

// Location (matches Coq: Record Location)
sig Location {
  loc_coordinate: one Coordinate,
  loc_accuracy: one Meters,
  loc_timestamp: one Int,
  loc_source: one Int // 0=GPS, 1=WiFi, 2=Cell
}

// Position (matches Coq: Record Position)
sig Position {
  pos_coordinate: one Coordinate,
  pos_altitude: one Int
}

// Geofence (matches Coq: Record Geofence)
sig Geofence {
  fence_id: one Int,
  fence_center: one Coordinate,
  fence_radius: one Meters,
  fence_triggered: one Bool
}

// LocationConfig (matches Coq: Record LocationConfig)
sig LocationConfig {
  loc_permission: one LocationPermission,
  loc_precision_full: one Bool // true = full, false = approximate,
  loc_background_enabled: one Bool,
  loc_cache_ttl: one Int // seconds,
  loc_update_interval: one Int // milliseconds,
  loc_significant_change_meters: one Int,
  loc_mock_detection: one Bool
}

// LocationHistory (matches Coq: Record LocationHistory)
sig LocationHistory {
  history_entries: one list,
  history_max_entries: one Int,
  history_deletable: one Bool
}

// ExtendedLocation (matches Coq: Record ExtendedLocation)
sig ExtendedLocation {
  ext_location: one Location,
  ext_altitude: one Int // meters above sea level,
  ext_altitude_accuracy: one Int // meters,
  ext_heading: one Int // degrees 0-359,
  ext_heading_accuracy: one Int // degrees,
  ext_speed: one Int // meters per second
}

// Meters (matches Coq: Definition Meters)
pred Meters {}

// Coordinate (matches Coq: Definition Coordinate)
pred Coordinate {}

// gps_available (matches Coq: Definition gps_available)
pred gps_available {}

// error (matches Coq: Definition error)
pred error[l: Location] {
  some l
}

// distance (matches Coq: Definition distance)
pred distance {}

// inside (matches Coq: Definition inside)
pred inside[fence: Geofence, pos: Position] {
  some fence
}

// triggered (matches Coq: Definition triggered)
pred triggered[fence: Geofence] {
  some fence
}

// accurate_location_service (matches Coq: Definition accurate_location_service)
pred accurate_location_service[l: Location] {
  some l
}

// accurate_geofence_system (matches Coq: Definition accurate_geofence_system)
pred accurate_geofence_system[fence: Geofence, pos: Position] {
  some fence
}

// valid_coordinate (matches Coq: Definition valid_coordinate)
pred valid_coordinate[c: Coordinate] {
  some c
}

// cache_expired (matches Coq: Definition cache_expired)
pred cache_expired[config: LocationConfig] {
  some config
}

// well_formed_location_config (matches Coq: Definition well_formed_location_config)
pred well_formed_location_config[config: LocationConfig] {
  some config
}

// location_accuracy_bounded (matches Coq: Theorem location_accuracy_bounded)
assert location_accuracy_bounded {
  all c: Location | some c.loc_coordinate
}
check location_accuracy_bounded for 5

// geofence_accurate (matches Coq: Theorem geofence_accurate)
assert geofence_accurate {
  all c: Location | some c.loc_coordinate
}
check geofence_accurate for 5

// inside_within_radius (matches Coq: Theorem inside_within_radius)
assert inside_within_radius {
  all c: Location | some c.loc_coordinate
}
check inside_within_radius for 5

// distance_symmetric (matches Coq: Theorem distance_symmetric)
assert distance_symmetric {
  all c: Location | some c.loc_coordinate
}
check distance_symmetric for 5

// distance_self_zero (matches Coq: Theorem distance_self_zero)
assert distance_self_zero {
  all c: Location | some c.loc_coordinate
}
check distance_self_zero for 5

// at_center_always_inside (matches Coq: Theorem at_center_always_inside)
assert at_center_always_inside {
  all c: Location | some c.loc_coordinate
}
check at_center_always_inside for 5

// location_permission_explicit (matches Coq: Theorem location_permission_explicit)
assert location_permission_explicit {
  all c: Location | some c.loc_coordinate
}
check location_permission_explicit for 5

// location_precision_adjustable (matches Coq: Theorem location_precision_adjustable)
assert location_precision_adjustable {
  all c: Location | some c.loc_coordinate
}
check location_precision_adjustable for 5

// background_location_limited (matches Coq: Theorem background_location_limited)
assert background_location_limited {
  all c: Location | some c.loc_coordinate
}
check background_location_limited for 5

// geofence_battery_efficient (matches Coq: Theorem geofence_battery_efficient)
assert geofence_battery_efficient {
  all c: Location | some c.loc_coordinate
}
check geofence_battery_efficient for 5

// location_data_encrypted (matches Coq: Theorem location_data_encrypted)
assert location_data_encrypted {
  all c: Location | some c.loc_coordinate
}
check location_data_encrypted for 5

// no_location_tracking_without_consent (matches Coq: Theorem no_location_tracking_without_consent)
assert no_location_tracking_without_consent {
  all c: Location | some c.loc_coordinate
}
check no_location_tracking_without_consent for 5

// location_cache_expiry (matches Coq: Theorem location_cache_expiry)
assert location_cache_expiry {
  all c: Location | some c.loc_coordinate
}
check location_cache_expiry for 5

// altitude_accuracy_bounded (matches Coq: Theorem altitude_accuracy_bounded)
assert altitude_accuracy_bounded {
  all c: Location | some c.loc_coordinate
}
check altitude_accuracy_bounded for 5

// heading_accuracy_bounded (matches Coq: Theorem heading_accuracy_bounded)
assert heading_accuracy_bounded {
  all c: Location | some c.loc_coordinate
}
check heading_accuracy_bounded for 5

// speed_non_negative (matches Coq: Theorem speed_non_negative)
assert speed_non_negative {
  all c: Location | some c.loc_coordinate
}
check speed_non_negative for 5

// coordinate_range_valid (matches Coq: Theorem coordinate_range_valid)
assert coordinate_range_valid {
  all c: Location | some c.loc_coordinate
}
check coordinate_range_valid for 5

// location_update_frequency_bounded (matches Coq: Theorem location_update_frequency_bounded)
assert location_update_frequency_bounded {
  all c: Location | some c.loc_coordinate
}
check location_update_frequency_bounded for 5

// significant_change_threshold (matches Coq: Theorem significant_change_threshold)
assert significant_change_threshold {
  all c: Location | some c.loc_coordinate
}
check significant_change_threshold for 5

// location_history_deletable (matches Coq: Theorem location_history_deletable)
assert location_history_deletable {
  all c: Location | some c.loc_coordinate
}
check location_history_deletable for 5

// mock_location_detectable (matches Coq: Theorem mock_location_detectable)
assert mock_location_detectable {
  all c: Location | some c.loc_coordinate
}
check mock_location_detectable for 5

// distance_triangle_inequality (matches Coq: Theorem distance_triangle_inequality)
assert distance_triangle_inequality {
  all c: Location | some c.loc_coordinate
}
check distance_triangle_inequality for 5
