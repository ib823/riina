// Copyright (c) 2026 The RIINA Authors. All rights reserved.
// Auto-generated from 02_FORMAL/coq/domains/mobile_os/OnDeviceML.v (25 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/on_device_ml

open util/boolean

// ModelUpdateState (matches Coq: Inductive ModelUpdateState)
abstract sig ModelUpdateState {}
one sig UpdateIdle extends ModelUpdateState {}
one sig UpdateInProgress extends ModelUpdateState {}
one sig UpdateComplete extends ModelUpdateState {}
one sig UpdateFailed extends ModelUpdateState {}

// Tensor (matches Coq: Record Tensor)
sig Tensor {
  tensor_shape: one list,
  tensor_data: one TensorData
}

// MLModel (matches Coq: Record MLModel)
sig MLModel {
  model_id: one Int,
  model_weights: one list,
  model_version: one Int,
  model_deterministic: one Bool
}

// UserData (matches Coq: Record UserData)
sig UserData {
  data_id: one Int,
  data_content: one list,
  data_sensitive: one Bool
}

// InferenceRequest (matches Coq: Record InferenceRequest)
sig InferenceRequest {
  req_model: one MLModel,
  req_input: one Tensor,
  req_latency_ms: one Int,
  req_max_latency_ms: one Int
}

// MemoryBudget (matches Coq: Record MemoryBudget)
sig MemoryBudget {
  budget_max_bytes: one Int,
  model_size_bytes: one Int
}

// ModelUpdate (matches Coq: Record ModelUpdate)
sig ModelUpdate {
  update_old_model: one MLModel,
  update_new_model: one MLModel,
  update_state: one ModelUpdateState,
  update_version_increased: one Bool
}

// PrivacyBudget (matches Coq: Record PrivacyBudget)
sig PrivacyBudget {
  epsilon: one Int // scaled by 1000,
  delta: one Int // scaled by 1000000,
  max_epsilon: one Int,
  max_delta: one Int
}

// Prediction (matches Coq: Record Prediction)
sig Prediction {
  pred_class: one Int,
  pred_confidence: one Int // 0-100,
  pred_calibrated: one Bool
}

// ModelPolicy (matches Coq: Record ModelPolicy)
sig ModelPolicy {
  policy_model: one MLModel,
  policy_exportable: one Bool,
  policy_on_device_only: one Bool
}

// TrainingData (matches Coq: Record TrainingData)
sig TrainingData {
  td_records: one list,
  td_anonymized: one Bool,
  td_pii_removed: one Bool
}

// InputAnalysis (matches Coq: Record InputAnalysis)
sig InputAnalysis {
  ia_input: one Tensor,
  ia_perturbation_score: one Int // 0-100,
  ia_threshold: one Int,
  ia_flagged: one Bool
}

// ModelWithFallback (matches Coq: Record ModelWithFallback)
sig ModelWithFallback {
  primary_model: one MLModel,
  fallback_model: one MLModel,
  primary_available: one Bool
}

// BatchRequest (matches Coq: Record BatchRequest)
sig BatchRequest {
  batch_id: one Int,
  batch_inputs: one list,
  batch_sequence: one list
}

// QuantizedModel (matches Coq: Record QuantizedModel)
sig QuantizedModel {
  qm_original_weights: one list,
  qm_quantized_weights: one list,
  qm_max_error: one Int
}

// TensorData (matches Coq: Definition TensorData)
pred TensorData {}

// compute_inference (matches Coq: Definition compute_inference)
pred compute_inference[m: MLModel, input: Tensor] {
  some m
}

// infer (matches Coq: Definition infer)
pred infer[m: MLModel, input: Tensor] {
  some m
}

// transmitted (matches Coq: Definition transmitted)
pred transmitted[d: UserData] {
  some d
}

// used_for_inference (matches Coq: Definition used_for_inference)
pred used_for_inference[d: UserData, m: MLModel] {
  some d
}

// private_ml_system (matches Coq: Definition private_ml_system)
pred private_ml_system {}

// input_shape_valid (matches Coq: Definition input_shape_valid)
pred input_shape_valid[input: Tensor] {
  some input
}

// output_bounded (matches Coq: Definition output_bounded)
pred output_bounded[output: Tensor, bound: nat] {
  some output
}

// latency_within_bound (matches Coq: Definition latency_within_bound)
pred latency_within_bound[r: InferenceRequest] {
  some r
}

// model_fits_memory (matches Coq: Definition model_fits_memory)
pred model_fits_memory[b: MemoryBudget] {
  some b
}

// update_atomic (matches Coq: Definition update_atomic)
pred update_atomic[u: ModelUpdate] {
  some u
}

// within_privacy_budget (matches Coq: Definition within_privacy_budget)
pred within_privacy_budget[pb: PrivacyBudget] {
  some pb
}

// version_tracked (matches Coq: Definition version_tracked)
pred version_tracked[m: MLModel] {
  some m
}

// confidence_calibrated (matches Coq: Definition confidence_calibrated)
pred confidence_calibrated[p: Prediction] {
  some p
}

// model_not_exportable (matches Coq: Definition model_not_exportable)
pred model_not_exportable[mp: ModelPolicy] {
  some mp
}

// data_anonymized (matches Coq: Definition data_anonymized)
pred data_anonymized[td: TrainingData] {
  some td
}

// adversarial_detected (matches Coq: Definition adversarial_detected)
pred adversarial_detected[ia: InputAnalysis] {
  some ia
}

// fallback_ready (matches Coq: Definition fallback_ready)
pred fallback_ready[mf: ModelWithFallback] {
  some mf
}

// batch_ordered (matches Coq: Definition batch_ordered)
pred batch_ordered[br: BatchRequest] {
  some br
}

// quantization_bounded (matches Coq: Definition quantization_bounded)
pred quantization_bounded[qm: QuantizedModel] {
  some qm
}

// ml_inference_deterministic (matches Coq: Theorem ml_inference_deterministic)
assert ml_inference_deterministic {
  all c: Tensor | some c.tensor_shape
}
check ml_inference_deterministic for 5

// inference_same_input_same_output (matches Coq: Theorem inference_same_input_same_output)
assert inference_same_input_same_output {
  all c: Tensor | some c.tensor_shape
}
check inference_same_input_same_output for 5

// ml_data_private (matches Coq: Theorem ml_data_private)
assert ml_data_private {
  all c: Tensor | some c.tensor_shape
}
check ml_data_private for 5

// inference_preserves_shape (matches Coq: Theorem inference_preserves_shape)
assert inference_preserves_shape {
  all c: Tensor | some c.tensor_shape
}
check inference_preserves_shape for 5

// different_model_version_matters (matches Coq: Theorem different_model_version_matters)
assert different_model_version_matters {
  all c: Tensor | some c.tensor_shape
}
check different_model_version_matters for 5

// model_input_validated (matches Coq: Theorem model_input_validated)
assert model_input_validated {
  all c: Tensor | some c.tensor_shape
}
check model_input_validated for 5

// model_output_bounded (matches Coq: Theorem model_output_bounded)
assert model_output_bounded {
  all c: Tensor | some c.tensor_shape
}
check model_output_bounded for 5

// inference_latency_bounded (matches Coq: Theorem inference_latency_bounded)
assert inference_latency_bounded {
  all c: Tensor | some c.tensor_shape
}
check inference_latency_bounded for 5

// model_size_within_memory (matches Coq: Theorem model_size_within_memory)
assert model_size_within_memory {
  all c: Tensor | some c.tensor_shape
}
check model_size_within_memory for 5

// model_update_atomic (matches Coq: Theorem model_update_atomic)
assert model_update_atomic {
  all c: Tensor | some c.tensor_shape
}
check model_update_atomic for 5

// differential_privacy_guaranteed (matches Coq: Theorem differential_privacy_guaranteed)
assert differential_privacy_guaranteed {
  all c: Tensor | some c.tensor_shape
}
check differential_privacy_guaranteed for 5

// model_version_tracked (matches Coq: Theorem model_version_tracked)
assert model_version_tracked {
  all c: Tensor | some c.tensor_shape
}
check model_version_tracked for 5

// feature_extraction_deterministic (matches Coq: Theorem feature_extraction_deterministic)
assert feature_extraction_deterministic {
  all c: Tensor | some c.tensor_shape
}
check feature_extraction_deterministic for 5

// prediction_confidence_calibrated (matches Coq: Theorem prediction_confidence_calibrated)
assert prediction_confidence_calibrated {
  all c: Tensor | some c.tensor_shape
}
check prediction_confidence_calibrated for 5

// model_not_exported (matches Coq: Theorem model_not_exported)
assert model_not_exported {
  all c: Tensor | some c.tensor_shape
}
check model_not_exported for 5

// training_data_anonymized (matches Coq: Theorem training_data_anonymized)
assert training_data_anonymized {
  all c: Tensor | some c.tensor_shape
}
check training_data_anonymized for 5

// adversarial_input_detected (matches Coq: Theorem adversarial_input_detected)
assert adversarial_input_detected {
  all c: Tensor | some c.tensor_shape
}
check adversarial_input_detected for 5

// model_fallback_available (matches Coq: Theorem model_fallback_available)
assert model_fallback_available {
  all c: Tensor | some c.tensor_shape
}
check model_fallback_available for 5

// batch_inference_ordered (matches Coq: Theorem batch_inference_ordered)
assert batch_inference_ordered {
  all c: Tensor | some c.tensor_shape
}
check batch_inference_ordered for 5

// model_quantization_bounded_error (matches Coq: Theorem model_quantization_bounded_error)
assert model_quantization_bounded_error {
  all c: Tensor | some c.tensor_shape
}
check model_quantization_bounded_error for 5

// on_device_only_preserves_privacy (matches Coq: Theorem on_device_only_preserves_privacy)
assert on_device_only_preserves_privacy {
  all c: Tensor | some c.tensor_shape
}
check on_device_only_preserves_privacy for 5

// adversarial_implies_high_perturbation (matches Coq: Theorem adversarial_implies_high_perturbation)
assert adversarial_implies_high_perturbation {
  all c: Tensor | some c.tensor_shape
}
check adversarial_implies_high_perturbation for 5

// batch_length_consistency (matches Coq: Theorem batch_length_consistency)
assert batch_length_consistency {
  all c: Tensor | some c.tensor_shape
}
check batch_length_consistency for 5

// privacy_budget_epsilon_bounded (matches Coq: Theorem privacy_budget_epsilon_bounded)
assert privacy_budget_epsilon_bounded {
  all c: Tensor | some c.tensor_shape
}
check privacy_budget_epsilon_bounded for 5

// failed_update_preserves_version (matches Coq: Theorem failed_update_preserves_version)
assert failed_update_preserves_version {
  all c: Tensor | some c.tensor_shape
}
check failed_update_preserves_version for 5
