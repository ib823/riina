// Copyright (c) 2026 The RIINA Authors. All rights reserved.
// Auto-generated from 02_FORMAL/coq/domains/mobile_os/CameraAudioSystem.v (21 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/camera_audio_system

open util/boolean

// RecordingState (matches Coq: Inductive RecordingState)
abstract sig RecordingState {}
one sig NotRecording extends RecordingState {}
one sig Recording extends RecordingState {}
one sig Paused extends RecordingState {}

// Scene (matches Coq: Record Scene)
sig Scene {
  scene_id: one Int,
  scene_data: one SensorData,
  scene_timestamp: one Int
}

// RawPhoto (matches Coq: Record RawPhoto)
sig RawPhoto {
  photo_id: one Int,
  photo_pixels: one PixelData,
  photo_metadata: one Int,
  photo_timestamp: one Int
}

// VideoRecording (matches Coq: Record VideoRecording)
sig VideoRecording {
  video_id: one Int,
  video_frames: one list,
  video_duration_ms: one Int,
  video_fps: one Int
}

// AudioSample (matches Coq: Record AudioSample)
sig AudioSample {
  audio_id: one Int,
  audio_data: one list,
  audio_input_time: one Microseconds,
  audio_output_time: one Microseconds
}

// CameraPermission (matches Coq: Record CameraPermission)
sig CameraPermission {
  camera_granted: one Bool,
  mic_granted: one Bool,
  per_session_only: one Bool
}

// AccessIndicator (matches Coq: Record AccessIndicator)
sig AccessIndicator {
  indicator_visible: one Bool,
  indicator_persistent: one Bool // stays on while access continues,
  indicator_type: one Int // 0 = camera, 1 = microphone, 2 = both
}

// AudioConfig (matches Coq: Record AudioConfig)
sig AudioConfig {
  sample_rate: one Int // Hz - 8000, 22050, 44100, 48000,
  bit_depth: one Int // 8, 16, 24, 32,
  channels: one Int // 1 = mono, 2 = stereo,
  audio_level: one Int // 0-100 normalized
}

// VideoConfig (matches Coq: Record VideoConfig)
sig VideoConfig {
  video_width: one Int,
  video_height: one Int,
  video_frame_rate: one Int // fps,
  stabilization_offset: one Int // pixels max offset
}

// RecordingSession (matches Coq: Record RecordingSession)
sig RecordingSession {
  rec_state: one RecordingState,
  rec_indicator: one AccessIndicator,
  rec_background: one Bool,
  rec_permission: one CameraPermission
}

// PhotoCapture (matches Coq: Record PhotoCapture)
sig PhotoCapture {
  capture_photo: one RawPhoto,
  capture_has_metadata: one Bool,
  capture_metadata_stripped: one Bool,
  capture_resolution_w: one Int,
  capture_resolution_h: one Int
}

// Microseconds (matches Coq: Definition Microseconds)
pred Microseconds {}

// PixelData (matches Coq: Definition PixelData)
pred PixelData {}

// SensorData (matches Coq: Definition SensorData)
pred SensorData {}

// sensor_data (matches Coq: Definition sensor_data)
pred sensor_data[s: Scene] {
  some s
}

// pixel_data (matches Coq: Definition pixel_data)
pred pixel_data[p: RawPhoto] {
  some p
}

// captures (matches Coq: Definition captures)
pred captures[s: Scene, p: RawPhoto] {
  some s
}

// frames_captured (matches Coq: Definition frames_captured)
pred frames_captured[v: VideoRecording] {
  some v
}

// expected_frames (matches Coq: Definition expected_frames)
pred expected_frames[v: VideoRecording] {
  some v
}

// well_formed_video (matches Coq: Definition well_formed_video)
pred well_formed_video[v: VideoRecording] {
  some v
}

// input_to_output_latency (matches Coq: Definition input_to_output_latency)
pred input_to_output_latency[s: AudioSample] {
  some s
}

// low_latency_audio (matches Coq: Definition low_latency_audio)
pred low_latency_audio[s: AudioSample] {
  some s
}

// lossless_capture_system (matches Coq: Definition lossless_capture_system)
pred lossless_capture_system {}

// well_formed_recording (matches Coq: Definition well_formed_recording)
pred well_formed_recording[rs: RecordingSession] {
  some rs
}

// well_formed_audio (matches Coq: Definition well_formed_audio)
pred well_formed_audio[ac: AudioConfig] {
  some ac
}

// well_formed_video_config (matches Coq: Definition well_formed_video_config)
pred well_formed_video_config[vc: VideoConfig] {
  some vc
}

// raw_capture_lossless (matches Coq: Theorem raw_capture_lossless)
assert raw_capture_lossless {
  all c: Scene | some c.scene_id
}
check raw_capture_lossless for 5

// video_no_frame_drop (matches Coq: Theorem video_no_frame_drop)
assert video_no_frame_drop {
  all c: Scene | some c.scene_id
}
check video_no_frame_drop for 5

// audio_latency_bounded (matches Coq: Theorem audio_latency_bounded)
assert audio_latency_bounded {
  all c: Scene | some c.scene_id
}
check audio_latency_bounded for 5

// capture_preserves_identity (matches Coq: Theorem capture_preserves_identity)
assert capture_preserves_identity {
  all c: Scene | some c.scene_id
}
check capture_preserves_identity for 5

// empty_video_zero_frames (matches Coq: Theorem empty_video_zero_frames)
assert empty_video_zero_frames {
  all c: Scene | some c.scene_id
}
check empty_video_zero_frames for 5

// audio_latency_nonnegative (matches Coq: Theorem audio_latency_nonnegative)
assert audio_latency_nonnegative {
  all c: Scene | some c.scene_id
}
check audio_latency_nonnegative for 5

// camera_access_indicator_visible (matches Coq: Theorem camera_access_indicator_visible)
assert camera_access_indicator_visible {
  all c: Scene | some c.scene_id
}
check camera_access_indicator_visible for 5

// microphone_access_indicator_visible (matches Coq: Theorem microphone_access_indicator_visible)
assert microphone_access_indicator_visible {
  all c: Scene | some c.scene_id
}
check microphone_access_indicator_visible for 5

// recording_indicator_persistent (matches Coq: Theorem recording_indicator_persistent)
assert recording_indicator_persistent {
  all c: Scene | some c.scene_id
}
check recording_indicator_persistent for 5

// no_silent_recording (matches Coq: Theorem no_silent_recording)
assert no_silent_recording {
  all c: Scene | some c.scene_id
}
check no_silent_recording for 5

// camera_preview_matches_capture (matches Coq: Theorem camera_preview_matches_capture)
assert camera_preview_matches_capture {
  all c: Scene | some c.scene_id
}
check camera_preview_matches_capture for 5

// audio_sample_rate_valid (matches Coq: Theorem audio_sample_rate_valid)
assert audio_sample_rate_valid {
  all c: Scene | some c.scene_id
}
check audio_sample_rate_valid for 5

// video_frame_rate_bounded (matches Coq: Theorem video_frame_rate_bounded)
assert video_frame_rate_bounded {
  all c: Scene | some c.scene_id
}
check video_frame_rate_bounded for 5

// photo_metadata_strippable (matches Coq: Theorem photo_metadata_strippable)
assert photo_metadata_strippable {
  all c: Scene | some c.scene_id
}
check photo_metadata_strippable for 5

// audio_level_bounded (matches Coq: Theorem audio_level_bounded)
assert audio_level_bounded {
  all c: Scene | some c.scene_id
}
check audio_level_bounded for 5

// camera_permission_per_session (matches Coq: Theorem camera_permission_per_session)
assert camera_permission_per_session {
  all c: Scene | some c.scene_id
}
check camera_permission_per_session for 5

// background_camera_blocked (matches Coq: Theorem background_camera_blocked)
assert background_camera_blocked {
  all c: Scene | some c.scene_id
}
check background_camera_blocked for 5

// camera_interrupt_handled (matches Coq: Theorem camera_interrupt_handled)
assert camera_interrupt_handled {
  all c: Scene | some c.scene_id
}
check camera_interrupt_handled for 5

// audio_route_change_handled (matches Coq: Theorem audio_route_change_handled)
assert audio_route_change_handled {
  all c: Scene | some c.scene_id
}
check audio_route_change_handled for 5

// video_stabilization_bounded (matches Coq: Theorem video_stabilization_bounded)
assert video_stabilization_bounded {
  all c: Scene | some c.scene_id
}
check video_stabilization_bounded for 5

// capture_resolution_bounded (matches Coq: Theorem capture_resolution_bounded)
assert capture_resolution_bounded {
  all c: Scene | some c.scene_id
}
check capture_resolution_bounded for 5
