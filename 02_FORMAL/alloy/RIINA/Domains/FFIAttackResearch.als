// Copyright (c) 2026 The RIINA Authors. All rights reserved.
// Auto-generated from 02_FORMAL/coq/domains/FFIAttackResearch.v (20 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/ffi_attack_research

open util/boolean

// FFIType (matches Coq: Inductive FFIType)
abstract sig FFIType {}
one sig FFI_Int8 extends FFIType {}
one sig FFI_Int16 extends FFIType {}
one sig FFI_Int32 extends FFIType {}
one sig FFI_Int64 extends FFIType {}
one sig FFI_Ptr extends FFIType {}
one sig FFI_Array extends FFIType {}
one sig FFI_Struct extends FFIType {}
one sig FFI_Void extends FFIType {}

// FFICallDescriptor (matches Coq: Record FFICallDescriptor)
sig FFICallDescriptor {
  ffi_name: one Int // function id,
  ffi_params: one list,
  ffi_return: one FFIType,
  ffi_sandboxed: one Bool,
  ffi_validated: one Bool
}

// MemRegion (matches Coq: Record MemRegion)
sig MemRegion {
  region_base: one Int,
  region_size: one Int,
  region_owner: one Int // sandbox id
}

// Sandbox (matches Coq: Record Sandbox)
sig Sandbox {
  sandbox_id: one Int,
  sandbox_region: one MemRegion,
  sandbox_active: one Bool,
  allowed_calls: one list
}

// MarshalBuffer (matches Coq: Record MarshalBuffer)
sig MarshalBuffer {
  buf_capacity: one Int,
  buf_used: one Int
}

// ffi_call_safe (matches Coq: Definition ffi_call_safe)
pred ffi_call_safe[call: FFICallDescriptor] {
  some call
}

// regions_disjoint (matches Coq: Definition regions_disjoint)
pred regions_disjoint {}

// addr_in_region (matches Coq: Definition addr_in_region)
pred addr_in_region[r: MemRegion] {
  some r
}

// call_allowed (matches Coq: Definition call_allowed)
pred call_allowed[sb: Sandbox, call_id: nat] {
  some sb
}

// buf_remaining (matches Coq: Definition buf_remaining)
pred buf_remaining[b: MarshalBuffer] {
  some b
}

// can_marshal (matches Coq: Definition can_marshal)
pred can_marshal[b: MarshalBuffer, t: FFIType] {
  some b
}

// ffi_safe_implies_sandboxed (matches Coq: Theorem ffi_safe_implies_sandboxed)
assert ffi_safe_implies_sandboxed {
  all c: FFICallDescriptor | some c.ffi_name
}
check ffi_safe_implies_sandboxed for 5

// ffi_safe_implies_validated (matches Coq: Theorem ffi_safe_implies_validated)
assert ffi_safe_implies_validated {
  all c: FFICallDescriptor | some c.ffi_name
}
check ffi_safe_implies_validated for 5

// ffi_safe_construct (matches Coq: Theorem ffi_safe_construct)
assert ffi_safe_construct {
  all c: FFICallDescriptor | some c.ffi_name
}
check ffi_safe_construct for 5

// int8_alignment_positive (matches Coq: Theorem int8_alignment_positive)
assert int8_alignment_positive {
  all c: FFICallDescriptor | some c.ffi_name
}
check int8_alignment_positive for 5

// ffi_type_align_ge_1 (matches Coq: Lemma ffi_type_align_ge_1)
assert ffi_type_align_ge_1 {
  all c: FFICallDescriptor | some c.ffi_name
}
check ffi_type_align_ge_1 for 5

// ptr_size_constant (matches Coq: Theorem ptr_size_constant)
assert ptr_size_constant {
  all c: FFICallDescriptor | some c.ffi_name
}
check ptr_size_constant for 5

// array_size_correct (matches Coq: Theorem array_size_correct)
assert array_size_correct {
  all c: FFICallDescriptor | some c.ffi_name
}
check array_size_correct for 5

// empty_struct_zero_size (matches Coq: Theorem empty_struct_zero_size)
assert empty_struct_zero_size {
  all c: FFICallDescriptor | some c.ffi_name
}
check empty_struct_zero_size for 5

// marshal_preserves_capacity (matches Coq: Theorem marshal_preserves_capacity)
assert marshal_preserves_capacity {
  all c: FFICallDescriptor | some c.ffi_name
}
check marshal_preserves_capacity for 5

// marshal_increases_used (matches Coq: Theorem marshal_increases_used)
assert marshal_increases_used {
  all c: FFICallDescriptor | some c.ffi_name
}
check marshal_increases_used for 5

// marshal_never_overflows (matches Coq: Theorem marshal_never_overflows)
assert marshal_never_overflows {
  all c: FFICallDescriptor | some c.ffi_name
}
check marshal_never_overflows for 5

// marshal_failure_means_insufficient (matches Coq: Theorem marshal_failure_means_insufficient)
assert marshal_failure_means_insufficient {
  all c: FFICallDescriptor | some c.ffi_name
}
check marshal_failure_means_insufficient for 5

// marshal_void_always_succeeds (matches Coq: Theorem marshal_void_always_succeeds)
assert marshal_void_always_succeeds {
  all c: FFICallDescriptor | some c.ffi_name
}
check marshal_void_always_succeeds for 5

// disjoint_regions_no_overlap (matches Coq: Theorem disjoint_regions_no_overlap)
assert disjoint_regions_no_overlap {
  all c: FFICallDescriptor | some c.ffi_name
}
check disjoint_regions_no_overlap for 5

// sandbox_call_allowed_decidable (matches Coq: Theorem sandbox_call_allowed_decidable)
assert sandbox_call_allowed_decidable {
  all c: FFICallDescriptor | some c.ffi_name
}
check sandbox_call_allowed_decidable for 5

// disjoint_symmetric (matches Coq: Theorem disjoint_symmetric)
assert disjoint_symmetric {
  all c: FFICallDescriptor | some c.ffi_name
}
check disjoint_symmetric for 5

// addr_in_region_bounds (matches Coq: Theorem addr_in_region_bounds)
assert addr_in_region_bounds {
  all c: FFICallDescriptor | some c.ffi_name
}
check addr_in_region_bounds for 5

// ffi_void_size_zero (matches Coq: Theorem ffi_void_size_zero)
assert ffi_void_size_zero {
  all c: FFICallDescriptor | some c.ffi_name
}
check ffi_void_size_zero for 5

// ffi_int8_size (matches Coq: Theorem ffi_int8_size)
assert ffi_int8_size {
  all c: FFICallDescriptor | some c.ffi_name
}
check ffi_int8_size for 5

// marshal_void_preserves_used (matches Coq: Theorem marshal_void_preserves_used)
assert marshal_void_preserves_used {
  all c: FFICallDescriptor | some c.ffi_name
}
check marshal_void_preserves_used for 5
