// SPDX-License-Identifier: MPL-2.0
// Copyright (c) 2026 The RIINA Authors.
// Auto-generated from 02_FORMAL/coq/domains/AlgebraicEffects.v (22 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/algebraic_effects

open util/boolean

// BaseTy (matches Coq: Inductive BaseTy)
abstract sig BaseTy {}
one sig TUnit extends BaseTy {}
one sig TBool extends BaseTy {}
one sig TNat extends BaseTy {}

// EffectOp (matches Coq: Inductive EffectOp)
abstract sig EffectOp {}
one sig OpRead extends EffectOp {} // State read
one sig OpWrite extends EffectOp {} // State write
one sig OpRaise extends EffectOp {} // Exception raise
one sig OpPrint extends EffectOp {} // I/O print
one sig OpRandom extends EffectOp {} // Non-determinism
one sig OpAsync extends EffectOp {} // Async operation

// CompTy (matches Coq: Inductive CompTy)
abstract sig CompTy {}
one sig CTyPure extends CompTy {} // A ! ∅
one sig CTyEff extends CompTy {} // A ! Σ

// Val (matches Coq: Inductive Val)
abstract sig Val {}
one sig VUnit extends Val {}
one sig VBool extends Val {}
one sig VNat extends Val {}

// Comp (matches Coq: Inductive Comp)
abstract sig Comp {}
one sig CReturn extends Comp {} // return v
one sig CPerform extends Comp {} // perform op v
one sig CHandle extends Comp {} // handle c with h
one sig CBind extends Comp {}
one sig HReturn extends Comp {} // return case
one sig HOp extends Comp {}

// EvalCtx (matches Coq: Inductive EvalCtx)
abstract sig EvalCtx {}
one sig EHole extends EvalCtx {}
one sig EBind extends EvalCtx {}

// OpSig (matches Coq: Record OpSig)
sig OpSig {
  opInputTy: one BaseTy,
  opOutputTy: one BaseTy
}

// effectOp_eqb (matches Coq: Definition effectOp_eqb)
pred effectOp_eqb {}

// in_row (matches Coq: Definition in_row)
pred in_row[op: EffectOp, row: EffectRow] {
  some op
}

// row_subset (matches Coq: Definition row_subset)
pred row_subset {}

// row_union (matches Coq: Definition row_union)
pred row_union {}

// row_nodup (matches Coq: Definition row_nodup)
pred row_nodup[r: EffectRow] {
  some r
}

// empty_row (matches Coq: Definition empty_row)
pred empty_row {}

// getBaseTy (matches Coq: Definition getBaseTy)
pred getBaseTy[ct: CompTy] {
  some ct
}

// getEffectRow (matches Coq: Definition getEffectRow)
pred getEffectRow[ct: CompTy] {
  some ct
}

// opSignature (matches Coq: Definition opSignature)
pred opSignature[op: EffectOp] {
  some op
}

// sig_wellformed (matches Coq: Definition sig_wellformed)
pred sig_wellformed[sig: EffectSig] {
  some sig
}

// row_minus (matches Coq: Definition row_minus)
pred row_minus[r: EffectRow, handled: EffectRow] {
  some r
}

// effect_polymorphic_fn (matches Coq: Definition effect_polymorphic_fn)
pred effect_polymorphic_fn {}

// all_effects_handled (matches Coq: Definition all_effects_handled)
pred all_effects_handled[c: Comp, handled: EffectRow] {
  some c
}

// respects_effects (matches Coq: Definition respects_effects)
pred respects_effects {}

// effectOp_eqb_eq (matches Coq: Lemma effectOp_eqb_eq)
assert effectOp_eqb_eq {
  all c: OpSig | some c.opInputTy
}
check effectOp_eqb_eq for 5

// effectOp_eqb_refl (matches Coq: Lemma effectOp_eqb_refl)
assert effectOp_eqb_refl {
  all c: OpSig | some c.opInputTy
}
check effectOp_eqb_refl for 5

// in_row_In (matches Coq: Lemma in_row_In)
assert in_row_In {
  all c: OpSig | some c.opInputTy
}
check in_row_In for 5

// row_subset_incl (matches Coq: Lemma row_subset_incl)
assert row_subset_incl {
  all c: OpSig | some c.opInputTy
}
check row_subset_incl for 5

// row_minus_spec (matches Coq: Lemma row_minus_spec)
assert row_minus_spec {
  all c: OpSig | some c.opInputTy
}
check row_minus_spec for 5

// EFF_001_01_effect_signature_wellformedness (matches Coq: Theorem EFF_001_01_effect_signature_wellformedness)
assert EFF_001_01_effect_signature_wellformedness {
  all c: OpSig | some c.opInputTy
}
check EFF_001_01_effect_signature_wellformedness for 5

// EFF_001_02_operation_typing (matches Coq: Theorem EFF_001_02_operation_typing)
assert EFF_001_02_operation_typing {
  all c: OpSig | some c.opInputTy
}
check EFF_001_02_operation_typing for 5

// EFF_001_03_handler_typing (matches Coq: Theorem EFF_001_03_handler_typing)
assert EFF_001_03_handler_typing {
  all c: OpSig | some c.opInputTy
}
check EFF_001_03_handler_typing for 5

// EFF_001_04_effect_row_combination (matches Coq: Theorem EFF_001_04_effect_row_combination)
assert EFF_001_04_effect_row_combination {
  all c: OpSig | some c.opInputTy
}
check EFF_001_04_effect_row_combination for 5

// EFF_001_05_effect_subsumption (matches Coq: Theorem EFF_001_05_effect_subsumption)
assert EFF_001_05_effect_subsumption {
  all c: OpSig | some c.opInputTy
}
check EFF_001_05_effect_subsumption for 5

// EFF_001_06_pure_computation (matches Coq: Theorem EFF_001_06_pure_computation)
assert EFF_001_06_pure_computation {
  all c: OpSig | some c.opInputTy
}
check EFF_001_06_pure_computation for 5

// compose_handlers_effects (matches Coq: Lemma compose_handlers_effects)
assert compose_handlers_effects {
  all c: OpSig | some c.opInputTy
}
check compose_handlers_effects for 5

// EFF_001_07_handler_composition (matches Coq: Theorem EFF_001_07_handler_composition)
assert EFF_001_07_handler_composition {
  all c: OpSig | some c.opInputTy
}
check EFF_001_07_handler_composition for 5

// EFF_001_08_effect_polymorphism (matches Coq: Theorem EFF_001_08_effect_polymorphism)
assert EFF_001_08_effect_polymorphism {
  all c: OpSig | some c.opInputTy
}
check EFF_001_08_effect_polymorphism for 5

// EFF_001_09_deep_handler_semantics (matches Coq: Theorem EFF_001_09_deep_handler_semantics)
assert EFF_001_09_deep_handler_semantics {
  all c: OpSig | some c.opInputTy
}
check EFF_001_09_deep_handler_semantics for 5

// EFF_001_10_shallow_handler_semantics (matches Coq: Theorem EFF_001_10_shallow_handler_semantics)
assert EFF_001_10_shallow_handler_semantics {
  all c: OpSig | some c.opInputTy
}
check EFF_001_10_shallow_handler_semantics for 5

// EFF_001_11_effect_masking (matches Coq: Theorem EFF_001_11_effect_masking)
assert EFF_001_11_effect_masking {
  all c: OpSig | some c.opInputTy
}
check EFF_001_11_effect_masking for 5

// EFF_001_12_resumption_linearity (matches Coq: Theorem EFF_001_12_resumption_linearity)
assert EFF_001_12_resumption_linearity {
  all c: OpSig | some c.opInputTy
}
check EFF_001_12_resumption_linearity for 5

// EFF_001_13_effect_safety (matches Coq: Theorem EFF_001_13_effect_safety)
assert EFF_001_13_effect_safety {
  all c: OpSig | some c.opInputTy
}
check EFF_001_13_effect_safety for 5

// EFF_001_14_effect_parametricity (matches Coq: Theorem EFF_001_14_effect_parametricity)
assert EFF_001_14_effect_parametricity {
  all c: OpSig | some c.opInputTy
}
check EFF_001_14_effect_parametricity for 5

// eval_pure_deterministic (matches Coq: Lemma eval_pure_deterministic)
assert eval_pure_deterministic {
  all c: OpSig | some c.opInputTy
}
check eval_pure_deterministic for 5

// EFF_001_15_effect_coherence (matches Coq: Theorem EFF_001_15_effect_coherence)
assert EFF_001_15_effect_coherence {
  all c: OpSig | some c.opInputTy
}
check EFF_001_15_effect_coherence for 5
