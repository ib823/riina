// Copyright (c) 2026 The RIINA Authors. All rights reserved.
// Auto-generated from 02_FORMAL/coq/domains/ControlFlowIntegrity.v (21 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/control_flow_integrity

open util/boolean

// EdgeType (matches Coq: Inductive EdgeType)
abstract sig EdgeType {}
one sig DirectJump extends EdgeType {} // Direct jump to known target
one sig ConditionalJump extends EdgeType {} // Conditional branch
one sig DirectCall extends EdgeType {} // Direct function call
one sig Return extends EdgeType {} // Return to caller
one sig FallThrough extends EdgeType {}

// MemPerm (matches Coq: Inductive MemPerm)
abstract sig MemPerm {}
one sig Readable extends MemPerm {}
one sig Writable extends MemPerm {}
one sig Executable extends MemPerm {}

// RelocState (matches Coq: Inductive RelocState)
abstract sig RelocState {}
one sig PreReloc extends RelocState {} // Can be written during loading
one sig PostReloc extends RelocState {}

// BasicBlock (matches Coq: Record BasicBlock)
sig BasicBlock {
  bb_id: one Int,
  bb_start: one InstrAddr,
  bb_end: one InstrAddr,
  bb_func: one FuncId
}

// CFGEdge (matches Coq: Record CFGEdge)
sig CFGEdge {
  edge_src: one BasicBlock,
  edge_dst: one BasicBlock,
  edge_type: one EdgeType
}

// ShadowEntry (matches Coq: Record ShadowEntry)
sig ShadowEntry {
  se_return_addr: one InstrAddr,
  se_caller_func: one FuncId
}

// FuncType (matches Coq: Record FuncType)
sig FuncType {
  ft_arg_types: one list,
  Simplified: one just,
  ft_ret_type: one Int
}

// TypedFuncPtr (matches Coq: Record TypedFuncPtr)
sig TypedFuncPtr {
  tfp_addr: one InstrAddr,
  tfp_type: one FuncType
}

// VTable (matches Coq: Record VTable)
sig VTable {
  vt_type_id: one Int,
  vt_methods: one list
}

// TypedObject (matches Coq: Record TypedObject)
sig TypedObject {
  to_vtable: one VTable,
  to_expected_type: one Int
}

// ExceptionHandler (matches Coq: Record ExceptionHandler)
sig ExceptionHandler {
  eh_type: one Int // Exception type handled,
  eh_addr: one InstrAddr // Handler address
}

// JmpBuf (matches Coq: Record JmpBuf)
sig JmpBuf {
  jb_valid: one Bool,
  jb_target: one InstrAddr,
  jb_stack_ptr: one Int
}

// ThreadContext (matches Coq: Record ThreadContext)
sig ThreadContext {
  tc_id: one Int,
  tc_owner: one Int // Owning process/capability,
  tc_valid: one Bool
}

// edge_in_cfg (matches Coq: Definition edge_in_cfg)
pred edge_in_cfg[e: CFGEdge, cfg: ValidCFG] {
  some e
}

// shadow_push (matches Coq: Definition shadow_push)
pred shadow_push[ss: ShadowStack, ret: InstrAddr, caller: FuncId] {
  some ss
}

// valid_return (matches Coq: Definition valid_return)
pred valid_return[ss: ShadowStack, ret_addr: InstrAddr] {
  some ss
}

// valid_indirect_call (matches Coq: Definition valid_indirect_call)
pred valid_indirect_call[vt: ValidTargets, fp: TypedFuncPtr] {
  some vt
}

// has_perm (matches Coq: Definition has_perm)
pred has_perm[p: MemPerm] {
  some p
}

// w_xor_x (matches Coq: Definition w_xor_x)
pred w_xor_x {}

// vtable_type_matches (matches Coq: Definition vtable_type_matches)
pred vtable_type_matches[obj: TypedObject] {
  some obj
}

// handler_registered (matches Coq: Definition handler_registered)
pred handler_registered[vhs: ValidHandlers, h: ExceptionHandler] {
  some vhs
}

// longjmp_safe (matches Coq: Definition longjmp_safe)
pred longjmp_safe[jb: JmpBuf] {
  some jb
}

// got_writable (matches Coq: Definition got_writable)
pred got_writable[rs: RelocState] {
  some rs
}

// got_protected (matches Coq: Definition got_protected)
pred got_protected[rs: RelocState] {
  some rs
}

// thread_accessible (matches Coq: Definition thread_accessible)
pred thread_accessible[tc: ThreadContext, accessor: nat] {
  some tc
}

// ctl_001_rop_impossible (matches Coq: Theorem ctl_001_rop_impossible)
assert ctl_001_rop_impossible {
  all c: BasicBlock | some c.bb_id
}
check ctl_001_rop_impossible for 5

// ctl_002_jop_impossible (matches Coq: Theorem ctl_002_jop_impossible)
assert ctl_002_jop_impossible {
  all c: BasicBlock | some c.bb_id
}
check ctl_002_jop_impossible for 5

// ctl_003_cop_impossible (matches Coq: Theorem ctl_003_cop_impossible)
assert ctl_003_cop_impossible {
  all c: BasicBlock | some c.bb_id
}
check ctl_003_cop_impossible for 5

// ctl_004_ret2libc_impossible (matches Coq: Theorem ctl_004_ret2libc_impossible)
assert ctl_004_ret2libc_impossible {
  all c: BasicBlock | some c.bb_id
}
check ctl_004_ret2libc_impossible for 5

// ctl_005_srop_impossible (matches Coq: Theorem ctl_005_srop_impossible)
assert ctl_005_srop_impossible {
  all c: BasicBlock | some c.bb_id
}
check ctl_005_srop_impossible for 5

// ctl_006_code_injection_impossible (matches Coq: Theorem ctl_006_code_injection_impossible)
assert ctl_006_code_injection_impossible {
  all c: BasicBlock | some c.bb_id
}
check ctl_006_code_injection_impossible for 5

// ctl_007_code_reuse_controlled (matches Coq: Theorem ctl_007_code_reuse_controlled)
assert ctl_007_code_reuse_controlled {
  all c: BasicBlock | some c.bb_id
}
check ctl_007_code_reuse_controlled for 5

// ctl_008_data_only_mitigated (matches Coq: Theorem ctl_008_data_only_mitigated)
assert ctl_008_data_only_mitigated {
  all c: BasicBlock | some c.bb_id
}
check ctl_008_data_only_mitigated for 5

// ctl_009_cf_bending_impossible (matches Coq: Theorem ctl_009_cf_bending_impossible)
assert ctl_009_cf_bending_impossible {
  all c: BasicBlock | some c.bb_id
}
check ctl_009_cf_bending_impossible for 5

// ctl_010_indirect_call_safe (matches Coq: Theorem ctl_010_indirect_call_safe)
assert ctl_010_indirect_call_safe {
  all c: BasicBlock | some c.bb_id
}
check ctl_010_indirect_call_safe for 5

// ctl_011_vtable_hijack_impossible (matches Coq: Theorem ctl_011_vtable_hijack_impossible)
assert ctl_011_vtable_hijack_impossible {
  all c: BasicBlock | some c.bb_id
}
check ctl_011_vtable_hijack_impossible for 5

// ctl_012_exception_safe (matches Coq: Theorem ctl_012_exception_safe)
assert ctl_012_exception_safe {
  all c: BasicBlock | some c.bb_id
}
check ctl_012_exception_safe for 5

// ctl_013_longjmp_safe (matches Coq: Theorem ctl_013_longjmp_safe)
assert ctl_013_longjmp_safe {
  all c: BasicBlock | some c.bb_id
}
check ctl_013_longjmp_safe for 5

// ctl_014_got_plt_protected (matches Coq: Theorem ctl_014_got_plt_protected)
assert ctl_014_got_plt_protected {
  all c: BasicBlock | some c.bb_id
}
check ctl_014_got_plt_protected for 5

// ctl_015_thread_hijack_impossible (matches Coq: Theorem ctl_015_thread_hijack_impossible)
assert ctl_015_thread_hijack_impossible {
  all c: BasicBlock | some c.bb_id
}
check ctl_015_thread_hijack_impossible for 5

// ctl_016_shadow_push_pop_identity (matches Coq: Theorem ctl_016_shadow_push_pop_identity)
assert ctl_016_shadow_push_pop_identity {
  all c: BasicBlock | some c.bb_id
}
check ctl_016_shadow_push_pop_identity for 5

// ctl_017_valid_return_after_push (matches Coq: Theorem ctl_017_valid_return_after_push)
assert ctl_017_valid_return_after_push {
  all c: BasicBlock | some c.bb_id
}
check ctl_017_valid_return_after_push for 5

// ctl_018_wxor_x_empty (matches Coq: Theorem ctl_018_wxor_x_empty)
assert ctl_018_wxor_x_empty {
  all c: BasicBlock | some c.bb_id
}
check ctl_018_wxor_x_empty for 5

// ctl_019_reloc_state_decidable (matches Coq: Theorem ctl_019_reloc_state_decidable)
assert ctl_019_reloc_state_decidable {
  all c: BasicBlock | some c.bb_id
}
check ctl_019_reloc_state_decidable for 5

// ctl_020_shadow_push_length (matches Coq: Theorem ctl_020_shadow_push_length)
assert ctl_020_shadow_push_length {
  all c: BasicBlock | some c.bb_id
}
check ctl_020_shadow_push_length for 5

// ctl_021_valid_trace_prefix (matches Coq: Theorem ctl_021_valid_trace_prefix)
assert ctl_021_valid_trace_prefix {
  all c: BasicBlock | some c.bb_id
}
check ctl_021_valid_trace_prefix for 5
