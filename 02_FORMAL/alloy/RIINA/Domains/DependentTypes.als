// SPDX-License-Identifier: MPL-2.0
// Copyright (c) 2026 The RIINA Authors.
// Auto-generated from 02_FORMAL/coq/domains/DependentTypes.v (33 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/dependent_types

open util/boolean

// DTerm (matches Coq: Inductive DTerm)
abstract sig DTerm {}
one sig DVar extends DTerm {}
one sig DLam extends DTerm {} // λx:A.b
one sig DApp extends DTerm {} // f a
one sig DPair extends DTerm {} // (a, b)
one sig DFst extends DTerm {} // π₁
one sig DSnd extends DTerm {} // π₂
one sig DRefl extends DTerm {} // refl
one sig DJ extends DTerm {} // J eliminator
one sig DNil extends DTerm {} // nil : Vec A 0
one sig DCons extends DTerm {} // cons : A → Vec A n → Vec A (S n)
one sig DHead extends DTerm {} // head : Vec A (S n) → A
one sig DTail extends DTerm {} // tail : Vec A (S n) → Vec A n

// TYPE_005_01 (matches Coq: Theorem TYPE_005_01)
assert TYPE_005_01 {
  #univ >= 0
}
check TYPE_005_01 for 5

// TYPE_005_02 (matches Coq: Theorem TYPE_005_02)
assert TYPE_005_02 {
  #univ >= 0
}
check TYPE_005_02 for 5

// TYPE_005_03 (matches Coq: Theorem TYPE_005_03)
assert TYPE_005_03 {
  #univ >= 0
}
check TYPE_005_03 for 5

// TYPE_005_04 (matches Coq: Theorem TYPE_005_04)
assert TYPE_005_04 {
  #univ >= 0
}
check TYPE_005_04 for 5

// TYPE_005_05 (matches Coq: Theorem TYPE_005_05)
assert TYPE_005_05 {
  #univ >= 0
}
check TYPE_005_05 for 5

// TYPE_005_06 (matches Coq: Theorem TYPE_005_06)
assert TYPE_005_06 {
  #univ >= 0
}
check TYPE_005_06 for 5

// TYPE_005_07 (matches Coq: Theorem TYPE_005_07)
assert TYPE_005_07 {
  #univ >= 0
}
check TYPE_005_07 for 5

// TYPE_005_08 (matches Coq: Theorem TYPE_005_08)
assert TYPE_005_08 {
  #univ >= 0
}
check TYPE_005_08 for 5

// vec_cons_length_semantic (matches Coq: Lemma vec_cons_length_semantic)
assert vec_cons_length_semantic {
  #univ >= 0
}
check vec_cons_length_semantic for 5

// TYPE_005_09 (matches Coq: Theorem TYPE_005_09)
assert TYPE_005_09 {
  #univ >= 0
}
check TYPE_005_09 for 5

// vec_head_nonempty_semantic (matches Coq: Lemma vec_head_nonempty_semantic)
assert vec_head_nonempty_semantic {
  #univ >= 0
}
check vec_head_nonempty_semantic for 5

// TYPE_005_10 (matches Coq: Theorem TYPE_005_10)
assert TYPE_005_10 {
  #univ >= 0
}
check TYPE_005_10 for 5

// vec_dep_pattern_match (matches Coq: Lemma vec_dep_pattern_match)
assert vec_dep_pattern_match {
  #univ >= 0
}
check vec_dep_pattern_match for 5

// TYPE_005_11 (matches Coq: Theorem TYPE_005_11)
assert TYPE_005_11 {
  #univ >= 0
}
check TYPE_005_11 for 5

// transport_refl (matches Coq: Lemma transport_refl)
assert transport_refl {
  #univ >= 0
}
check transport_refl for 5

// transport_trans (matches Coq: Lemma transport_trans)
assert transport_trans {
  #univ >= 0
}
check transport_trans for 5

// TYPE_005_12 (matches Coq: Theorem TYPE_005_12)
assert TYPE_005_12 {
  #univ >= 0
}
check TYPE_005_12 for 5

// dep_congruence (matches Coq: Lemma dep_congruence)
assert dep_congruence {
  #univ >= 0
}
check dep_congruence for 5

// congruence2 (matches Coq: Lemma congruence2)
assert congruence2 {
  #univ >= 0
}
check congruence2 for 5

// lt_wf_aux (matches Coq: Lemma lt_wf_aux)
assert lt_wf_aux {
  #univ >= 0
}
check lt_wf_aux for 5

// lt_well_founded (matches Coq: Lemma lt_well_founded)
assert lt_well_founded {
  #univ >= 0
}
check lt_well_founded for 5

// TYPE_005_13 (matches Coq: Theorem TYPE_005_13)
assert TYPE_005_13 {
  #univ >= 0
}
check TYPE_005_13 for 5

// nat_dep_ind (matches Coq: Lemma nat_dep_ind)
assert nat_dep_ind {
  #univ >= 0
}
check nat_dep_ind for 5

// strong_ind (matches Coq: Lemma strong_ind)
assert strong_ind {
  #univ >= 0
}
check strong_ind for 5

// TYPE_005_14 (matches Coq: Theorem TYPE_005_14)
assert TYPE_005_14 {
  #univ >= 0
}
check TYPE_005_14 for 5

// dec_eq_nat (matches Coq: Lemma dec_eq_nat)
assert dec_eq_nat {
  #univ >= 0
}
check dec_eq_nat for 5

// dec_eq_bool (matches Coq: Lemma dec_eq_bool)
assert dec_eq_bool {
  #univ >= 0
}
check dec_eq_bool for 5

// dec_eq_prod (matches Coq: Lemma dec_eq_prod)
assert dec_eq_prod {
  #univ >= 0
}
check dec_eq_prod for 5

// dec_eq_option (matches Coq: Lemma dec_eq_option)
assert dec_eq_option {
  #univ >= 0
}
check dec_eq_option for 5

// dec_eq_list (matches Coq: Lemma dec_eq_list)
assert dec_eq_list {
  #univ >= 0
}
check dec_eq_list for 5

// dec_to_bool (matches Coq: Lemma dec_to_bool)
assert dec_to_bool {
  #univ >= 0
}
check dec_to_bool for 5

// nat_eq_reflect (matches Coq: Lemma nat_eq_reflect)
assert nat_eq_reflect {
  #univ >= 0
}
check nat_eq_reflect for 5

// uip_dec (matches Coq: Lemma uip_dec)
assert uip_dec {
  #univ >= 0
}
check uip_dec for 5
