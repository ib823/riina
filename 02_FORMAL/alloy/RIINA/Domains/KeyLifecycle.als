// SPDX-License-Identifier: MPL-2.0
// Copyright (c) 2026 The RIINA Authors.
// Auto-generated from 02_FORMAL/coq/domains/KeyLifecycle.v (25 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/key_lifecycle

open util/boolean

// KeyState (matches Coq: Inductive KeyState)
abstract sig KeyState {}
one sig PreGeneration extends KeyState {}
one sig Active extends KeyState {}
one sig Suspended extends KeyState {}
one sig Deactivated extends KeyState {}
one sig Compromised extends KeyState {}
one sig Destroyed extends KeyState {}

// KeyType (matches Coq: Inductive KeyType)
abstract sig KeyType {}
one sig SymmetricKey extends KeyType {}
one sig AsymmetricPrivate extends KeyType {}
one sig AsymmetricPublic extends KeyType {}
one sig SigningKey extends KeyType {}
one sig EncryptionKey extends KeyType {}

// entropy_sufficient (matches Coq: Definition entropy_sufficient)
pred entropy_sufficient[key: KeyMetadata, min_entropy: nat] {
  some key
}

// is_usable_state (matches Coq: Definition is_usable_state)
pred is_usable_state[state: KeyState] {
  some state
}

// valid_transition (matches Coq: Definition valid_transition)
pred valid_transition {}

// key_not_expired (matches Coq: Definition key_not_expired)
pred key_not_expired[key: KeyMetadata, current_time: nat] {
  some key
}

// rotation_valid (matches Coq: Definition rotation_valid)
pred rotation_valid[rot: RotationRecord] {
  some rot
}

// rotation_after_creation (matches Coq: Definition rotation_after_creation)
pred rotation_after_creation[key: KeyMetadata, rot: RotationRecord] {
  some key
}

// destruction_verified (matches Coq: Definition destruction_verified)
pred destruction_verified[dest: DestructionRecord] {
  some dest
}

// escrow_threshold_valid (matches Coq: Definition escrow_threshold_valid)
pred escrow_threshold_valid[share: EscrowShare] {
  some share
}

// escrow_share_index_valid (matches Coq: Definition escrow_share_index_valid)
pred escrow_share_index_valid[share: EscrowShare] {
  some share
}

// destruction_method_valid (matches Coq: Definition destruction_method_valid)
pred destruction_method_valid[dest: DestructionRecord] {
  some dest
}

// symmetric_key_size_ok (matches Coq: Definition symmetric_key_size_ok)
pred symmetric_key_size_ok {}

// asymmetric_key_size_ok (matches Coq: Definition asymmetric_key_size_ok)
pred asymmetric_key_size_ok {}

// purpose_matches (matches Coq: Definition purpose_matches)
pred purpose_matches {}

// lifetime_ok (matches Coq: Definition lifetime_ok)
pred lifetime_ok {}

// rotation_due (matches Coq: Definition rotation_due)
pred rotation_due {}

// derivation_depth_ok (matches Coq: Definition derivation_depth_ok)
pred derivation_depth_ok {}

// access_allowed (matches Coq: Definition access_allowed)
pred access_allowed {}

// hsm_stored (matches Coq: Definition hsm_stored)
pred hsm_stored[hsm_flag: bool] {
  some hsm_flag
}

// audit_complete (matches Coq: Definition audit_complete)
pred audit_complete {}

// backup_encrypted (matches Coq: Definition backup_encrypted)
pred backup_encrypted[encryption_key: nat] {
  some encryption_key
}

// custodians_diverse (matches Coq: Definition custodians_diverse)
pred custodians_diverse[min_custodians: nat] {
  some min_custodians
}

// recovery_tested (matches Coq: Definition recovery_tested)
pred recovery_tested {}

// key_layers (matches Coq: Definition key_layers)
pred key_layers {}

// key_001_entropy_sufficient (matches Coq: Theorem key_001_entropy_sufficient)
assert key_001_entropy_sufficient {
  #univ >= 0
}
check key_001_entropy_sufficient for 5

// key_002_active_usable (matches Coq: Theorem key_002_active_usable)
assert key_002_active_usable {
  #univ >= 0
}
check key_002_active_usable for 5

// key_003_valid_transition (matches Coq: Theorem key_003_valid_transition)
assert key_003_valid_transition {
  #univ >= 0
}
check key_003_valid_transition for 5

// key_004_destroyed_unusable (matches Coq: Theorem key_004_destroyed_unusable)
assert key_004_destroyed_unusable {
  #univ >= 0
}
check key_004_destroyed_unusable for 5

// key_005_compromised_unusable (matches Coq: Theorem key_005_compromised_unusable)
assert key_005_compromised_unusable {
  #univ >= 0
}
check key_005_compromised_unusable for 5

// key_006_not_expired (matches Coq: Theorem key_006_not_expired)
assert key_006_not_expired {
  #univ >= 0
}
check key_006_not_expired for 5

// key_007_rotation_new (matches Coq: Theorem key_007_rotation_new)
assert key_007_rotation_new {
  #univ >= 0
}
check key_007_rotation_new for 5

// key_008_rotation_timing (matches Coq: Theorem key_008_rotation_timing)
assert key_008_rotation_timing {
  #univ >= 0
}
check key_008_rotation_timing for 5

// key_009_destruction_verified (matches Coq: Theorem key_009_destruction_verified)
assert key_009_destruction_verified {
  #univ >= 0
}
check key_009_destruction_verified for 5

// key_010_escrow_threshold (matches Coq: Theorem key_010_escrow_threshold)
assert key_010_escrow_threshold {
  #univ >= 0
}
check key_010_escrow_threshold for 5

// key_011_escrow_share_index (matches Coq: Theorem key_011_escrow_share_index)
assert key_011_escrow_share_index {
  #univ >= 0
}
check key_011_escrow_share_index for 5

// key_012_destruction_method (matches Coq: Theorem key_012_destruction_method)
assert key_012_destruction_method {
  #univ >= 0
}
check key_012_destruction_method for 5

// key_013_symmetric_size (matches Coq: Theorem key_013_symmetric_size)
assert key_013_symmetric_size {
  #univ >= 0
}
check key_013_symmetric_size for 5

// key_014_asymmetric_size (matches Coq: Theorem key_014_asymmetric_size)
assert key_014_asymmetric_size {
  #univ >= 0
}
check key_014_asymmetric_size for 5

// key_015_purpose_bound (matches Coq: Theorem key_015_purpose_bound)
assert key_015_purpose_bound {
  #univ >= 0
}
check key_015_purpose_bound for 5

// key_016_lifetime (matches Coq: Theorem key_016_lifetime)
assert key_016_lifetime {
  #univ >= 0
}
check key_016_lifetime for 5

// key_017_rotation_due (matches Coq: Theorem key_017_rotation_due)
assert key_017_rotation_due {
  #univ >= 0
}
check key_017_rotation_due for 5

// key_018_derivation_depth (matches Coq: Theorem key_018_derivation_depth)
assert key_018_derivation_depth {
  #univ >= 0
}
check key_018_derivation_depth for 5

// key_019_access_control (matches Coq: Theorem key_019_access_control)
assert key_019_access_control {
  #univ >= 0
}
check key_019_access_control for 5

// key_020_hsm_storage (matches Coq: Theorem key_020_hsm_storage)
assert key_020_hsm_storage {
  #univ >= 0
}
check key_020_hsm_storage for 5

// key_021_audit_complete (matches Coq: Theorem key_021_audit_complete)
assert key_021_audit_complete {
  #univ >= 0
}
check key_021_audit_complete for 5

// key_022_backup_encrypted (matches Coq: Theorem key_022_backup_encrypted)
assert key_022_backup_encrypted {
  #univ >= 0
}
check key_022_backup_encrypted for 5

// key_023_custodian_diversity (matches Coq: Theorem key_023_custodian_diversity)
assert key_023_custodian_diversity {
  #univ >= 0
}
check key_023_custodian_diversity for 5

// key_024_recovery_tested (matches Coq: Theorem key_024_recovery_tested)
assert key_024_recovery_tested {
  #univ >= 0
}
check key_024_recovery_tested for 5

// key_025_defense_in_depth (matches Coq: Theorem key_025_defense_in_depth)
assert key_025_defense_in_depth {
  #univ >= 0
}
check key_025_defense_in_depth for 5
