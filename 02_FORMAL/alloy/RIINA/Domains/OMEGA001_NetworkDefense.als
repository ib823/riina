// SPDX-License-Identifier: MPL-2.0
// Copyright (c) 2026 The RIINA Authors.
// Auto-generated from 02_FORMAL/coq/domains/OMEGA001_NetworkDefense.v (30 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/omega001__network_defense

open util/boolean

// ConnState (matches Coq: Inductive ConnState)
abstract sig ConnState {}
one sig ConnNew extends ConnState {}
one sig ConnEstablished extends ConnState {}
one sig ConnClosing extends ConnState {}
one sig ConnClosed extends ConnState {}

// TokenBucket (matches Coq: Record TokenBucket)
sig TokenBucket {
  tb_tokens: one Int,
  tb_capacity: one Int,
  tb_refill_rate: one Int // tokens per tick,
  tb_last_refill: one Int // tick count
}

// NetCapability (matches Coq: Record NetCapability)
sig NetCapability {
  cap_id: one Int,
  cap_permissions: one list,
  cap_expiry: one Int,
  cap_delegatable: one Bool,
  cap_signature: one Int // HMAC signature
}

// SynCookie (matches Coq: Record SynCookie)
sig SynCookie {
  sc_client_ip: one Int,
  sc_client_port: one Int,
  sc_server_port: one Int,
  sc_timestamp: one Int,
  sc_mss_index: one Int
}

// Connection (matches Coq: Record Connection)
sig Connection {
  conn_src: one Int,
  conn_dst: one Int,
  conn_state: one ConnState,
  conn_bytes_in: one Int,
  conn_bytes_out: one Int,
  conn_start_time: one Int
}

// tb_refill (matches Coq: Definition tb_refill)
pred tb_refill[tb: TokenBucket, now: nat] {
  some tb
}

// tb_available (matches Coq: Definition tb_available)
pred tb_available[tb: TokenBucket] {
  some tb
}

// cap_valid (matches Coq: Definition cap_valid)
pred cap_valid[cap: NetCapability, now: nat] {
  some cap
}

// cap_permits (matches Coq: Definition cap_permits)
pred cap_permits[cap: NetCapability, port: nat] {
  some cap
}

// cap_is_subset (matches Coq: Definition cap_is_subset)
pred cap_is_subset {}

// hmac_compute (matches Coq: Definition hmac_compute)
pred hmac_compute[key: nat, data: nat] {
  some key
}

// syn_cookie_generate (matches Coq: Definition syn_cookie_generate)
pred syn_cookie_generate[secret: nat, cookie: SynCookie] {
  some secret
}

// syn_cookie_verify (matches Coq: Definition syn_cookie_verify)
pred syn_cookie_verify[secret: nat, cookie: SynCookie, mac: nat] {
  some secret
}

// pow_hash (matches Coq: Definition pow_hash)
pred pow_hash {}

// pow_valid (matches Coq: Definition pow_valid)
pred pow_valid {}

// pow_verify (matches Coq: Definition pow_verify)
pred pow_verify {}

// conn_count_by_src (matches Coq: Definition conn_count_by_src)
pred conn_count_by_src[table: ConnTable, src: nat] {
  some table
}

// conn_limit_per_src (matches Coq: Definition conn_limit_per_src)
pred conn_limit_per_src {}

// conn_allowed (matches Coq: Definition conn_allowed)
pred conn_allowed[table: ConnTable, src: nat] {
  some table
}

// OMEGA_001_01_tb_capacity_bound (matches Coq: Theorem OMEGA_001_01_tb_capacity_bound)
assert OMEGA_001_01_tb_capacity_bound {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_001_01_tb_capacity_bound for 5

// OMEGA_001_02_tb_consume_decreases (matches Coq: Theorem OMEGA_001_02_tb_consume_decreases)
assert OMEGA_001_02_tb_consume_decreases {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_001_02_tb_consume_decreases for 5

// OMEGA_001_03_tb_consume_fails_insufficient (matches Coq: Theorem OMEGA_001_03_tb_consume_fails_insufficient)
assert OMEGA_001_03_tb_consume_fails_insufficient {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_001_03_tb_consume_fails_insufficient for 5

// OMEGA_001_04_tb_refill_monotone (matches Coq: Theorem OMEGA_001_04_tb_refill_monotone)
assert OMEGA_001_04_tb_refill_monotone {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_001_04_tb_refill_monotone for 5

// OMEGA_001_05_tb_consume_preserves_capacity (matches Coq: Theorem OMEGA_001_05_tb_consume_preserves_capacity)
assert OMEGA_001_05_tb_consume_preserves_capacity {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_001_05_tb_consume_preserves_capacity for 5

// OMEGA_001_06_tb_zero_cost_always_succeeds (matches Coq: Theorem OMEGA_001_06_tb_zero_cost_always_succeeds)
assert OMEGA_001_06_tb_zero_cost_always_succeeds {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_001_06_tb_zero_cost_always_succeeds for 5

// OMEGA_001_07_tb_refill_preserves_capacity (matches Coq: Theorem OMEGA_001_07_tb_refill_preserves_capacity)
assert OMEGA_001_07_tb_refill_preserves_capacity {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_001_07_tb_refill_preserves_capacity for 5

// OMEGA_001_08_tb_available_bound (matches Coq: Theorem OMEGA_001_08_tb_available_bound)
assert OMEGA_001_08_tb_available_bound {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_001_08_tb_available_bound for 5

// OMEGA_002_01_expired_cap_invalid (matches Coq: Theorem OMEGA_002_01_expired_cap_invalid)
assert OMEGA_002_01_expired_cap_invalid {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_002_01_expired_cap_invalid for 5

// OMEGA_002_02_cap_subset_reflexive (matches Coq: Theorem OMEGA_002_02_cap_subset_reflexive)
assert OMEGA_002_02_cap_subset_reflexive {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_002_02_cap_subset_reflexive for 5

// OMEGA_002_03_delegation_attenuation (matches Coq: Theorem OMEGA_002_03_delegation_attenuation)
assert OMEGA_002_03_delegation_attenuation {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_002_03_delegation_attenuation for 5

// OMEGA_002_04_delegation_permission_subset (matches Coq: Theorem OMEGA_002_04_delegation_permission_subset)
assert OMEGA_002_04_delegation_permission_subset {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_002_04_delegation_permission_subset for 5

// OMEGA_002_05_nondelegatable_blocks (matches Coq: Theorem OMEGA_002_05_nondelegatable_blocks)
assert OMEGA_002_05_nondelegatable_blocks {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_002_05_nondelegatable_blocks for 5

// OMEGA_002_06_empty_cap_permits_nothing (matches Coq: Theorem OMEGA_002_06_empty_cap_permits_nothing)
assert OMEGA_002_06_empty_cap_permits_nothing {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_002_06_empty_cap_permits_nothing for 5

// OMEGA_002_07_cap_permits_sound (matches Coq: Theorem OMEGA_002_07_cap_permits_sound)
assert OMEGA_002_07_cap_permits_sound {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_002_07_cap_permits_sound for 5

// OMEGA_003_01_syn_cookie_verify_sound (matches Coq: Theorem OMEGA_003_01_syn_cookie_verify_sound)
assert OMEGA_003_01_syn_cookie_verify_sound {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_003_01_syn_cookie_verify_sound for 5

// OMEGA_003_02_syn_cookie_wrong_secret (matches Coq: Theorem OMEGA_003_02_syn_cookie_wrong_secret)
assert OMEGA_003_02_syn_cookie_wrong_secret {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_003_02_syn_cookie_wrong_secret for 5

// OMEGA_003_03_syn_cookie_deterministic (matches Coq: Theorem OMEGA_003_03_syn_cookie_deterministic)
assert OMEGA_003_03_syn_cookie_deterministic {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_003_03_syn_cookie_deterministic for 5

// OMEGA_003_04_syn_cookie_stateless (matches Coq: Theorem OMEGA_003_04_syn_cookie_stateless)
assert OMEGA_003_04_syn_cookie_stateless {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_003_04_syn_cookie_stateless for 5

// OMEGA_003_05_syn_cookie_ip_sensitive (matches Coq: Theorem OMEGA_003_05_syn_cookie_ip_sensitive)
assert OMEGA_003_05_syn_cookie_ip_sensitive {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_003_05_syn_cookie_ip_sensitive for 5

// OMEGA_003_06_wrong_mac_rejected (matches Coq: Theorem OMEGA_003_06_wrong_mac_rejected)
assert OMEGA_003_06_wrong_mac_rejected {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_003_06_wrong_mac_rejected for 5

// OMEGA_004_01_empty_table_allows (matches Coq: Theorem OMEGA_004_01_empty_table_allows)
assert OMEGA_004_01_empty_table_allows {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_004_01_empty_table_allows for 5

// OMEGA_004_02_conn_count_nonneg (matches Coq: Theorem OMEGA_004_02_conn_count_nonneg)
assert OMEGA_004_02_conn_count_nonneg {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_004_02_conn_count_nonneg for 5

// OMEGA_004_03_conn_count_bound (matches Coq: Theorem OMEGA_004_03_conn_count_bound)
assert OMEGA_004_03_conn_count_bound {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_004_03_conn_count_bound for 5

// OMEGA_004_04_conn_lookup_deterministic (matches Coq: Theorem OMEGA_004_04_conn_lookup_deterministic)
assert OMEGA_004_04_conn_lookup_deterministic {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_004_04_conn_lookup_deterministic for 5

// OMEGA_004_05_pow_verify_sound (matches Coq: Theorem OMEGA_004_05_pow_verify_sound)
assert OMEGA_004_05_pow_verify_sound {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_004_05_pow_verify_sound for 5

// OMEGA_005_01_pow_deterministic (matches Coq: Theorem OMEGA_005_01_pow_deterministic)
assert OMEGA_005_01_pow_deterministic {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_005_01_pow_deterministic for 5

// OMEGA_005_02_pow_zero_difficulty_impossible (matches Coq: Theorem OMEGA_005_02_pow_zero_difficulty_impossible)
assert OMEGA_005_02_pow_zero_difficulty_impossible {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_005_02_pow_zero_difficulty_impossible for 5

// OMEGA_005_03_pow_verify_complete (matches Coq: Theorem OMEGA_005_03_pow_verify_complete)
assert OMEGA_005_03_pow_verify_complete {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_005_03_pow_verify_complete for 5

// OMEGA_005_04_pow_hash_deterministic (matches Coq: Theorem OMEGA_005_04_pow_hash_deterministic)
assert OMEGA_005_04_pow_hash_deterministic {
  all c: TokenBucket | some c.tb_tokens
}
check OMEGA_005_04_pow_hash_deterministic for 5
