// Copyright (c) 2026 The RIINA Authors. All rights reserved.
// Auto-generated from 02_FORMAL/coq/domains/PhysicalSecurity.v (21 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/physical_security

open util/boolean

// GateType (matches Coq: Inductive GateType)
abstract sig GateType {}
one sig AND extends GateType {}
one sig OR extends GateType {}
one sig NOT extends GateType {}
one sig XOR extends GateType {}
one sig NAND extends GateType {}
one sig NOR extends GateType {}
one sig BUF extends GateType {}
one sig MUX extends GateType {}

// TrojanStatus (matches Coq: Inductive TrojanStatus)
abstract sig TrojanStatus {}
one sig TrojanFree extends TrojanStatus {}
one sig TrojanDetected extends TrojanStatus {}

// XRayMatch (matches Coq: Inductive XRayMatch)
abstract sig XRayMatch {}
one sig Match extends XRayMatch {}
one sig Mismatch extends XRayMatch {}

// AuthResult (matches Coq: Inductive AuthResult)
abstract sig AuthResult {}
one sig Authentic extends AuthResult {}
one sig Counterfeit extends AuthResult {}

// FabStatus (matches Coq: Inductive FabStatus)
abstract sig FabStatus {}
one sig FabClean extends FabStatus {}
one sig FabTampered extends FabStatus {}

// ProbeAttempt (matches Coq: Inductive ProbeAttempt)
abstract sig ProbeAttempt {}
one sig NoProbe extends ProbeAttempt {}
one sig ProbeDetected extends ProbeAttempt {}

// Gate (matches Coq: Record Gate)
sig Gate {
  gate_type: one GateType,
  gate_inputs: one list,
  gate_output: one Signal
}

// RTLModule (matches Coq: Record RTLModule)
sig RTLModule {
  rtl_inputs: one list,
  rtl_outputs: one list,
  rtl_behavior: one list
}

// Netlist (matches Coq: Record Netlist)
sig Netlist {
  nl_gates: one list,
  nl_inputs: one list,
  nl_outputs: one list,
  nl_behavior: one list
}

// TimingPath (matches Coq: Record TimingPath)
sig TimingPath {
  path_gates: one list,
  path_delay: one Int
}

// Chip (matches Coq: Record Chip)
sig Chip {
  chip_id: one ChipId,
  chip_xray: one XRayImage,
  chip_puf: one Challenge
}

// GoldenSample (matches Coq: Record GoldenSample)
sig GoldenSample {
  golden_xray: one XRayImage,
  golden_puf: one Challenge
}

// DeviceState (matches Coq: Record DeviceState)
sig DeviceState {
  dev_voltage: one Voltage,
  dev_temperature: one Temperature,
  dev_mesh_intact: one Bool,
  dev_keys_valid: one Bool,
  dev_operational: one Bool
}

// semantic_equivalent (matches Coq: Definition semantic_equivalent)
pred semantic_equivalent[rtl: RTLModule, nl: Netlist] {
  some rtl
}

// timing_met (matches Coq: Definition timing_met)
pred timing_met[nl: Netlist, clk: ClockPeriod] {
  some nl
}

// no_hardware_trojans (matches Coq: Definition no_hardware_trojans)
pred no_hardware_trojans[rtl: RTLModule] {
  some rtl
}

// constant_time_hw (matches Coq: Definition constant_time_hw)
pred constant_time_hw[op: Operation] {
  some op
}

// deterministic_design (matches Coq: Definition deterministic_design)
pred deterministic_design[rtl: RTLModule] {
  some rtl
}

// structurally_equivalent (matches Coq: Definition structurally_equivalent)
pred structurally_equivalent[c: Chip, g: GoldenSample] {
  some c
}

// is_genuine (matches Coq: Definition is_genuine)
pred is_genuine[c: Chip, g: GoldenSample] {
  some c
}

// V_MIN (matches Coq: Definition V_MIN)
pred V_MIN {}

// V_MAX (matches Coq: Definition V_MAX)
pred V_MAX {}

// T_MIN (matches Coq: Definition T_MIN)
pred T_MIN {}

// T_MAX (matches Coq: Definition T_MAX)
pred T_MAX {}

// voltage_ok (matches Coq: Definition voltage_ok)
pred voltage_ok[d: DeviceState] {
  some d
}

// temp_ok (matches Coq: Definition temp_ok)
pred temp_ok[d: DeviceState] {
  some d
}

// tamper_detected (matches Coq: Definition tamper_detected)
pred tamper_detected[d: DeviceState] {
  some d
}

// keys_zeroized (matches Coq: Definition keys_zeroized)
pred keys_zeroized[d: DeviceState] {
  some d
}

// voltage_glitch (matches Coq: Definition voltage_glitch)
pred voltage_glitch[d: DeviceState] {
  some d
}

// temp_violation (matches Coq: Definition temp_violation)
pred temp_violation[d: DeviceState] {
  some d
}

// power_independent (matches Coq: Definition power_independent)
pred power_independent[op: Operation] {
  some op
}

// PHY_001_01_rtl_gate_equivalent (matches Coq: Theorem PHY_001_01_rtl_gate_equivalent)
assert PHY_001_01_rtl_gate_equivalent {
  all c: Gate | some c.gate_type
}
check PHY_001_01_rtl_gate_equivalent for 5

// PHY_001_02_timing_closed (matches Coq: Theorem PHY_001_02_timing_closed)
assert PHY_001_02_timing_closed {
  all c: Gate | some c.gate_type
}
check PHY_001_02_timing_closed for 5

// PHY_001_03_no_trojans (matches Coq: Theorem PHY_001_03_no_trojans)
assert PHY_001_03_no_trojans {
  all c: Gate | some c.gate_type
}
check PHY_001_03_no_trojans for 5

// PHY_001_04_hw_constant_time (matches Coq: Theorem PHY_001_04_hw_constant_time)
assert PHY_001_04_hw_constant_time {
  all c: Gate | some c.gate_type
}
check PHY_001_04_hw_constant_time for 5

// PHY_001_05_design_deterministic (matches Coq: Theorem PHY_001_05_design_deterministic)
assert PHY_001_05_design_deterministic {
  all c: Gate | some c.gate_type
}
check PHY_001_05_design_deterministic for 5

// PHY_001_06_golden_equivalent (matches Coq: Theorem PHY_001_06_golden_equivalent)
assert PHY_001_06_golden_equivalent {
  all c: Gate | some c.gate_type
}
check PHY_001_06_golden_equivalent for 5

// PHY_001_07_puf_unique (matches Coq: Theorem PHY_001_07_puf_unique)
assert PHY_001_07_puf_unique {
  all c: Gate | some c.gate_type
}
check PHY_001_07_puf_unique for 5

// PHY_001_08_puf_stable (matches Coq: Theorem PHY_001_08_puf_stable)
assert PHY_001_08_puf_stable {
  all c: Gate | some c.gate_type
}
check PHY_001_08_puf_stable for 5

// PHY_001_09_counterfeit_detected (matches Coq: Theorem PHY_001_09_counterfeit_detected)
assert PHY_001_09_counterfeit_detected {
  all c: Gate | some c.gate_type
}
check PHY_001_09_counterfeit_detected for 5

// PHY_001_10_no_fab_tampering (matches Coq: Theorem PHY_001_10_no_fab_tampering)
assert PHY_001_10_no_fab_tampering {
  all c: Gate | some c.gate_type
}
check PHY_001_10_no_fab_tampering for 5

// PHY_001_11_mesh_integrity (matches Coq: Theorem PHY_001_11_mesh_integrity)
assert PHY_001_11_mesh_integrity {
  all c: Gate | some c.gate_type
}
check PHY_001_11_mesh_integrity for 5

// PHY_001_12_tamper_response (matches Coq: Theorem PHY_001_12_tamper_response)
assert PHY_001_12_tamper_response {
  all c: Gate | some c.gate_type
}
check PHY_001_12_tamper_response for 5

// PHY_001_13_voltage_glitch_detected (matches Coq: Theorem PHY_001_13_voltage_glitch_detected)
assert PHY_001_13_voltage_glitch_detected {
  all c: Gate | some c.gate_type
}
check PHY_001_13_voltage_glitch_detected for 5

// PHY_001_14_temperature_bounds (matches Coq: Theorem PHY_001_14_temperature_bounds)
assert PHY_001_14_temperature_bounds {
  all c: Gate | some c.gate_type
}
check PHY_001_14_temperature_bounds for 5

// PHY_001_15_power_independent (matches Coq: Theorem PHY_001_15_power_independent)
assert PHY_001_15_power_independent {
  all c: Gate | some c.gate_type
}
check PHY_001_15_power_independent for 5

// PHY_001_16_tamper_disables_operation (matches Coq: Theorem PHY_001_16_tamper_disables_operation)
assert PHY_001_16_tamper_disables_operation {
  all c: Gate | some c.gate_type
}
check PHY_001_16_tamper_disables_operation for 5

// PHY_001_17_normal_preserves_state (matches Coq: Theorem PHY_001_17_normal_preserves_state)
assert PHY_001_17_normal_preserves_state {
  all c: Gate | some c.gate_type
}
check PHY_001_17_normal_preserves_state for 5

// PHY_001_18_mesh_broken_tamper (matches Coq: Theorem PHY_001_18_mesh_broken_tamper)
assert PHY_001_18_mesh_broken_tamper {
  all c: Gate | some c.gate_type
}
check PHY_001_18_mesh_broken_tamper for 5

// PHY_001_19_voltage_oor_tamper (matches Coq: Theorem PHY_001_19_voltage_oor_tamper)
assert PHY_001_19_voltage_oor_tamper {
  all c: Gate | some c.gate_type
}
check PHY_001_19_voltage_oor_tamper for 5

// PHY_001_20_temp_oor_tamper (matches Coq: Theorem PHY_001_20_temp_oor_tamper)
assert PHY_001_20_temp_oor_tamper {
  all c: Gate | some c.gate_type
}
check PHY_001_20_temp_oor_tamper for 5

// PHY_001_21_synthesis_all_inputs (matches Coq: Theorem PHY_001_21_synthesis_all_inputs)
assert PHY_001_21_synthesis_all_inputs {
  all c: Gate | some c.gate_type
}
check PHY_001_21_synthesis_all_inputs for 5
