// SPDX-License-Identifier: MPL-2.0
// Copyright (c) 2026 The RIINA Authors.
// Auto-generated from 02_FORMAL/coq/domains/RadiationHardening.v (20 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/radiation_hardening

open util/boolean

// SystemMode (matches Coq: Inductive SystemMode)
abstract sig SystemMode {}
one sig NormalMode extends SystemMode {}
one sig SafeMode extends SystemMode {}
one sig RecoveryMode extends SystemMode {}

// ECCWord (matches Coq: Record ECCWord)
sig ECCWord {
  ecc_data: one Word // Data bits,
  ecc_parity: one Word // Parity bits
}

// Watchdog (matches Coq: Record Watchdog)
sig Watchdog {
  wd_counter: one Int,
  wd_timeout: one Int,
  wd_last_kick: one Int
}

// Checkpoint (matches Coq: Record Checkpoint)
sig Checkpoint {
  cp_state: one Int // Abstract system state,
  cp_timestamp: one Int,
  cp_valid: one Bool
}

// CFSignature (matches Coq: Record CFSignature)
sig CFSignature {
  cfs_expected_next: one list,
  cfs_current: one Int
}

// StackFrame (matches Coq: Record StackFrame)
sig StackFrame {
  sf_canary: one Int,
  sf_data: one Int,
  sf_expected_canary: one Int
}

// ScrubState (matches Coq: Record ScrubState)
sig ScrubState {
  scrub_last_addr: one Int,
  scrub_errors_found: one Int,
  scrub_errors_corrected: one Int
}

// NVersionResult (matches Coq: Record NVersionResult)
sig NVersionResult {
  nvr_results: one list,
  nvr_agreement_threshold: one Int
}

// Probability (matches Coq: Record Probability)
sig Probability {
  prob_num: one Int,
  prob_denom: one Int
}

// RecoveryMetrics (matches Coq: Record RecoveryMetrics)
sig RecoveryMetrics {
  rm_mttr: one Int // Mean Time To Recovery,
  rm_requirement: one Int // Mission requirement
}

// CriticalData (matches Coq: Record CriticalData)
sig CriticalData {
  cd_primary: one Int,
  cd_backup1: one Int,
  cd_backup2: one Int,
  cd_checksum: one Int
}

// flip_bit (matches Coq: Definition flip_bit)
pred flip_bit[b: Bit] {
  some b
}

// majority_vote (matches Coq: Definition majority_vote)
pred majority_vote {}

// tmr_errors (matches Coq: Definition tmr_errors)
pred tmr_errors {}

// ecc_syndrome (matches Coq: Definition ecc_syndrome)
pred ecc_syndrome[e: ECCWord] {
  some e
}

// watchdog_expired (matches Coq: Definition watchdog_expired)
pred watchdog_expired[wd: Watchdog, current_time: nat] {
  some wd
}

// cf_valid (matches Coq: Definition cf_valid)
pred cf_valid[cfs: CFSignature, actual_next: nat] {
  some cfs
}

// canary_valid (matches Coq: Definition canary_valid)
pred canary_valid[sf: StackFrame] {
  some sf
}

// mode_eqb (matches Coq: Definition mode_eqb)
pred mode_eqb {}

// count_agreements (matches Coq: Definition count_agreements)
pred count_agreements[value: nat] {
  some value
}

// prob_lt (matches Coq: Definition prob_lt)
pred prob_lt {}

// recovery_within_bound (matches Coq: Definition recovery_within_bound)
pred recovery_within_bound[rm: RecoveryMetrics] {
  some rm
}

// cd_consistent (matches Coq: Definition cd_consistent)
pred cd_consistent[cd: CriticalData] {
  some cd
}

// cd_recover (matches Coq: Definition cd_recover)
pred cd_recover[cd: CriticalData] {
  some cd
}

// scrub_effective (matches Coq: Definition scrub_effective)
pred scrub_effective[ss: ScrubState] {
  some ss
}

// seu_response (matches Coq: Definition seu_response)
pred seu_response[seu_detected: bool, current_mode: SystemMode] {
  some seu_detected
}

// DOMAIN_001_01 (matches Coq: Theorem DOMAIN_001_01)
assert DOMAIN_001_01 {
  all c: ECCWord | some c.ecc_data
}
check DOMAIN_001_01 for 5

// DOMAIN_001_02 (matches Coq: Theorem DOMAIN_001_02)
assert DOMAIN_001_02 {
  all c: ECCWord | some c.ecc_data
}
check DOMAIN_001_02 for 5

// DOMAIN_001_03 (matches Coq: Theorem DOMAIN_001_03)
assert DOMAIN_001_03 {
  all c: ECCWord | some c.ecc_data
}
check DOMAIN_001_03 for 5

// DOMAIN_001_04 (matches Coq: Theorem DOMAIN_001_04)
assert DOMAIN_001_04 {
  all c: ECCWord | some c.ecc_data
}
check DOMAIN_001_04 for 5

// DOMAIN_001_05 (matches Coq: Theorem DOMAIN_001_05)
assert DOMAIN_001_05 {
  all c: ECCWord | some c.ecc_data
}
check DOMAIN_001_05 for 5

// DOMAIN_001_06 (matches Coq: Theorem DOMAIN_001_06)
assert DOMAIN_001_06 {
  all c: ECCWord | some c.ecc_data
}
check DOMAIN_001_06 for 5

// DOMAIN_001_07 (matches Coq: Theorem DOMAIN_001_07)
assert DOMAIN_001_07 {
  all c: ECCWord | some c.ecc_data
}
check DOMAIN_001_07 for 5

// DOMAIN_001_08 (matches Coq: Theorem DOMAIN_001_08)
assert DOMAIN_001_08 {
  all c: ECCWord | some c.ecc_data
}
check DOMAIN_001_08 for 5

// DOMAIN_001_09 (matches Coq: Theorem DOMAIN_001_09)
assert DOMAIN_001_09 {
  all c: ECCWord | some c.ecc_data
}
check DOMAIN_001_09 for 5

// DOMAIN_001_09_corrupted (matches Coq: Theorem DOMAIN_001_09_corrupted)
assert DOMAIN_001_09_corrupted {
  all c: ECCWord | some c.ecc_data
}
check DOMAIN_001_09_corrupted for 5

// DOMAIN_001_10 (matches Coq: Theorem DOMAIN_001_10)
assert DOMAIN_001_10 {
  all c: ECCWord | some c.ecc_data
}
check DOMAIN_001_10 for 5

// DOMAIN_001_11 (matches Coq: Theorem DOMAIN_001_11)
assert DOMAIN_001_11 {
  all c: ECCWord | some c.ecc_data
}
check DOMAIN_001_11 for 5

// DOMAIN_001_12 (matches Coq: Theorem DOMAIN_001_12)
assert DOMAIN_001_12 {
  all c: ECCWord | some c.ecc_data
}
check DOMAIN_001_12 for 5

// DOMAIN_001_13 (matches Coq: Theorem DOMAIN_001_13)
assert DOMAIN_001_13 {
  all c: ECCWord | some c.ecc_data
}
check DOMAIN_001_13 for 5

// DOMAIN_001_14 (matches Coq: Theorem DOMAIN_001_14)
assert DOMAIN_001_14 {
  all c: ECCWord | some c.ecc_data
}
check DOMAIN_001_14 for 5

// DOMAIN_001_15 (matches Coq: Theorem DOMAIN_001_15)
assert DOMAIN_001_15 {
  all c: ECCWord | some c.ecc_data
}
check DOMAIN_001_15 for 5

// DOMAIN_001_15_single_corruption (matches Coq: Theorem DOMAIN_001_15_single_corruption)
assert DOMAIN_001_15_single_corruption {
  all c: ECCWord | some c.ecc_data
}
check DOMAIN_001_15_single_corruption for 5

// DOMAIN_001_16 (matches Coq: Theorem DOMAIN_001_16)
assert DOMAIN_001_16 {
  all c: ECCWord | some c.ecc_data
}
check DOMAIN_001_16 for 5

// DOMAIN_001_17 (matches Coq: Theorem DOMAIN_001_17)
assert DOMAIN_001_17 {
  all c: ECCWord | some c.ecc_data
}
check DOMAIN_001_17 for 5

// DOMAIN_001_18 (matches Coq: Theorem DOMAIN_001_18)
assert DOMAIN_001_18 {
  all c: ECCWord | some c.ecc_data
}
check DOMAIN_001_18 for 5
