// Copyright (c) 2026 The RIINA Authors. All rights reserved.
// Auto-generated from 02_FORMAL/coq/domains/DualModeVerification.v (22 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/dual_mode_verification

open util/boolean

// expr (matches Coq: Inductive expr)
abstract sig expr {}
one sig EConst extends expr {}
one sig EPlus extends expr {}
one sig EIf extends expr {}

// RefinementPred (matches Coq: Record RefinementPred)
sig RefinementPred {
  full_pred: one Int,
  light_pred: one Int,
  light_sound: one forall
}

// lightweight_check (matches Coq: Definition lightweight_check)
pred lightweight_check[rt: RefinedType, v: nat] {
  some rt
}

// full_check (matches Coq: Definition full_check)
pred full_check[rt: RefinedType, v: nat] {
  some rt
}

// decidable_refinement (matches Coq: Definition decidable_refinement)
pred decidable_refinement[rt: RefinedType] {
  some rt
}

// refine_subtype (matches Coq: Definition refine_subtype)
pred refine_subtype {}

// refine_conj (matches Coq: Definition refine_conj)
pred refine_conj {}

// lightweight_sound (matches Coq: Theorem lightweight_sound)
assert lightweight_sound {
  all c: RefinementPred | some c.full_pred
}
check lightweight_sound for 5

// lightweight_complete_decidable (matches Coq: Theorem lightweight_complete_decidable)
assert lightweight_complete_decidable {
  all c: RefinementPred | some c.full_pred
}
check lightweight_complete_decidable for 5

// refine_subtype_refl (matches Coq: Theorem refine_subtype_refl)
assert refine_subtype_refl {
  all c: RefinementPred | some c.full_pred
}
check refine_subtype_refl for 5

// refine_subtype_trans (matches Coq: Theorem refine_subtype_trans)
assert refine_subtype_trans {
  all c: RefinementPred | some c.full_pred
}
check refine_subtype_trans for 5

// checked_values_satisfy (matches Coq: Theorem checked_values_satisfy)
assert checked_values_satisfy {
  all c: RefinementPred | some c.full_pred
}
check checked_values_satisfy for 5

// dual_mode_agreement (matches Coq: Theorem dual_mode_agreement)
assert dual_mode_agreement {
  all c: RefinementPred | some c.full_pred
}
check dual_mode_agreement for 5

// refinement_weakening (matches Coq: Theorem refinement_weakening)
assert refinement_weakening {
  all c: RefinementPred | some c.full_pred
}
check refinement_weakening for 5

// conj_subtype_left (matches Coq: Theorem conj_subtype_left)
assert conj_subtype_left {
  all c: RefinementPred | some c.full_pred
}
check conj_subtype_left for 5

// conj_subtype_right (matches Coq: Theorem conj_subtype_right)
assert conj_subtype_right {
  all c: RefinementPred | some c.full_pred
}
check conj_subtype_right for 5

// conj_greatest_lower_bound (matches Coq: Theorem conj_greatest_lower_bound)
assert conj_greatest_lower_bound {
  all c: RefinementPred | some c.full_pred
}
check conj_greatest_lower_bound for 5

// conj_full_pred_comm (matches Coq: Theorem conj_full_pred_comm)
assert conj_full_pred_comm {
  all c: RefinementPred | some c.full_pred
}
check conj_full_pred_comm for 5

// conj_full_pred_assoc (matches Coq: Theorem conj_full_pred_assoc)
assert conj_full_pred_assoc {
  all c: RefinementPred | some c.full_pred
}
check conj_full_pred_assoc for 5

// conj_light_is_andb (matches Coq: Theorem conj_light_is_andb)
assert conj_light_is_andb {
  all c: RefinementPred | some c.full_pred
}
check conj_light_is_andb for 5

// eval_const (matches Coq: Theorem eval_const)
assert eval_const {
  all c: RefinementPred | some c.full_pred
}
check eval_const for 5

// eval_plus (matches Coq: Theorem eval_plus)
assert eval_plus {
  all c: RefinementPred | some c.full_pred
}
check eval_plus for 5

// lightweight_false_implies_not_full (matches Coq: Theorem lightweight_false_implies_not_full)
assert lightweight_false_implies_not_full {
  all c: RefinementPred | some c.full_pred
}
check lightweight_false_implies_not_full for 5

// subtype_lightweight_sound (matches Coq: Theorem subtype_lightweight_sound)
assert subtype_lightweight_sound {
  all c: RefinementPred | some c.full_pred
}
check subtype_lightweight_sound for 5

// conj_decidable (matches Coq: Theorem conj_decidable)
assert conj_decidable {
  all c: RefinementPred | some c.full_pred
}
check conj_decidable for 5

// refine_subtype_antisym_eq (matches Coq: Theorem refine_subtype_antisym_eq)
assert refine_subtype_antisym_eq {
  all c: RefinementPred | some c.full_pred
}
check refine_subtype_antisym_eq for 5

// eval_if_false (matches Coq: Theorem eval_if_false)
assert eval_if_false {
  all c: RefinementPred | some c.full_pred
}
check eval_if_false for 5

// eval_if_true (matches Coq: Theorem eval_if_true)
assert eval_if_true {
  all c: RefinementPred | some c.full_pred
}
check eval_if_true for 5

// conj_sub_both (matches Coq: Theorem conj_sub_both)
assert conj_sub_both {
  all c: RefinementPred | some c.full_pred
}
check conj_sub_both for 5
