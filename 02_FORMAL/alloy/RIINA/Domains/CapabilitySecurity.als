// Copyright (c) 2026 The RIINA Authors. All rights reserved.
// Auto-generated from 02_FORMAL/coq/domains/CapabilitySecurity.v (108 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/capability_security

open util/boolean

// Permission (matches Coq: Inductive Permission)
abstract sig Permission {}
one sig Read extends Permission {}
one sig Write extends Permission {}
one sig Execute extends Permission {}
one sig Delete extends Permission {}
one sig Create extends Permission {}
one sig Admin extends Permission {}

// DelegationType (matches Coq: Inductive DelegationType)
abstract sig DelegationType {}
one sig DelegFull extends DelegationType {} // Full delegation - delegate can re-delegate
one sig DelegRestricted extends DelegationType {} // Delegate cannot re-delegate

// Capability (matches Coq: Record Capability)
sig Capability {
  cap_unforgeable: one Bool,
  cap_transferable: one Bool,
  cap_revocable: one Bool,
  cap_attenuatable: one Bool
}

// ObjectCapability (matches Coq: Record ObjectCapability)
sig ObjectCapability {
  ocap_no_ambient_authority: one Bool,
  ocap_explicit_grant: one Bool,
  ocap_encapsulation: one Bool,
  ocap_connectivity: one Bool
}

// LeastPrivilege (matches Coq: Record LeastPrivilege)
sig LeastPrivilege {
  lp_minimal_permissions: one Bool,
  lp_time_limited: one Bool,
  lp_scope_limited: one Bool
}

// CapabilityConfig (matches Coq: Record CapabilityConfig)
sig CapabilityConfig {
  cc_cap: one Capability,
  cc_ocap: one ObjectCapability,
  cc_lp: one LeastPrivilege
}

// MemCapability (matches Coq: Record MemCapability)
sig MemCapability {
  mem_base: one Int // Base address,
  mem_length: one Int // Length of region,
  mem_perms: one PermSet // Permissions,
  mem_sealed: one Bool // Whether capability is sealed,
  mem_valid: one Bool // Whether capability is valid (not revoked)
}

// RevocationTable (matches Coq: Record RevocationTable)
sig RevocationTable {
  rev_entries: one list
}

// Principal (matches Coq: Record Principal)
sig Principal {
  prin_id: one Int,
  prin_capabilities: one list
}

// ConfinementPolicy (matches Coq: Record ConfinementPolicy)
sig ConfinementPolicy {
  conf_no_ambient: one Bool,
  conf_explicit_only: one Bool,
  conf_no_escalation: one Bool
}

// Delegation (matches Coq: Record Delegation)
sig Delegation {
  del_from: one Int // Delegator principal ID,
  del_to: one Int // Delegatee principal ID,
  del_cap_id: one Int // Capability being delegated,
  del_type: one DelegationType,
  del_active: one Bool // Whether delegation is still active
}

// perm_level (matches Coq: Definition perm_level)
pred perm_level[p: Permission] {
  some p
}

// perm_leq (matches Coq: Definition perm_leq)
pred perm_leq {}

// perm_lt (matches Coq: Definition perm_lt)
pred perm_lt {}

// perm_eq (matches Coq: Definition perm_eq)
pred perm_eq {}

// mem_bounds_check (matches Coq: Definition mem_bounds_check)
pred mem_bounds_check[mc: MemCapability, addr: nat] {
  some mc
}

// mem_has_perm (matches Coq: Definition mem_has_perm)
pred mem_has_perm[mc: MemCapability, p: Permission] {
  some mc
}

// mem_can_read (matches Coq: Definition mem_can_read)
pred mem_can_read[mc: MemCapability, addr: nat] {
  some mc
}

// mem_can_write (matches Coq: Definition mem_can_write)
pred mem_can_write[mc: MemCapability, addr: nat] {
  some mc
}

// mem_can_execute (matches Coq: Definition mem_can_execute)
pred mem_can_execute[mc: MemCapability, addr: nat] {
  some mc
}

// perms_subset (matches Coq: Definition perms_subset)
pred perms_subset {}

// derive_mem_cap (matches Coq: Definition derive_mem_cap)
pred derive_mem_cap {}

// is_revoked (matches Coq: Definition is_revoked)
pred is_revoked[rt: RevocationTable, cap_id: nat] {
  some rt
}

// revoke_capability (matches Coq: Definition revoke_capability)
pred revoke_capability[rt: RevocationTable, cap_id: nat] {
  some rt
}

// has_capability (matches Coq: Definition has_capability)
pred has_capability[p: Principal, cap_id: nat] {
  some p
}

// confinement_enforced (matches Coq: Definition confinement_enforced)
pred confinement_enforced[cp: ConfinementPolicy] {
  some cp
}

// can_redelegate (matches Coq: Definition can_redelegate)
pred can_redelegate[d: Delegation] {
  some d
}

// capability_sound (matches Coq: Definition capability_sound)
pred capability_sound[c: Capability] {
  some c
}

// ocap_sound (matches Coq: Definition ocap_sound)
pred ocap_sound[o: ObjectCapability] {
  some o
}

// least_privilege_enforced (matches Coq: Definition least_privilege_enforced)
pred least_privilege_enforced[l: LeastPrivilege] {
  some l
}

// capability_secure (matches Coq: Definition capability_secure)
pred capability_secure[c: CapabilityConfig] {
  some c
}

// riina_cap (matches Coq: Definition riina_cap)
pred riina_cap {}

// riina_ocap (matches Coq: Definition riina_ocap)
pred riina_ocap {}

// riina_lp (matches Coq: Definition riina_lp)
pred riina_lp {}

// riina_cap_config (matches Coq: Definition riina_cap_config)
pred riina_cap_config {}

// riina_confinement (matches Coq: Definition riina_confinement)
pred riina_confinement {}

// riina_mem_cap (matches Coq: Definition riina_mem_cap)
pred riina_mem_cap {}

// empty_rev_table (matches Coq: Definition empty_rev_table)
pred empty_rev_table {}

// riina_delegation (matches Coq: Definition riina_delegation)
pred riina_delegation {}

// andb_true_iff (matches Coq: Lemma andb_true_iff)
assert andb_true_iff {
  all c: Capability | some c.cap_unforgeable
}
check andb_true_iff for 5

// andb_false_iff (matches Coq: Lemma andb_false_iff)
assert andb_false_iff {
  all c: Capability | some c.cap_unforgeable
}
check andb_false_iff for 5

// orb_true_iff (matches Coq: Lemma orb_true_iff)
assert orb_true_iff {
  all c: Capability | some c.cap_unforgeable
}
check orb_true_iff for 5

// negb_true_iff (matches Coq: Lemma negb_true_iff)
assert negb_true_iff {
  all c: Capability | some c.cap_unforgeable
}
check negb_true_iff for 5

// negb_false_iff (matches Coq: Lemma negb_false_iff)
assert negb_false_iff {
  all c: Capability | some c.cap_unforgeable
}
check negb_false_iff for 5

// CAP_001 (matches Coq: Theorem CAP_001)
assert CAP_001 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_001 for 5

// CAP_002 (matches Coq: Theorem CAP_002)
assert CAP_002 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_002 for 5

// CAP_003 (matches Coq: Theorem CAP_003)
assert CAP_003 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_003 for 5

// CAP_004 (matches Coq: Theorem CAP_004)
assert CAP_004 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_004 for 5

// CAP_005 (matches Coq: Theorem CAP_005)
assert CAP_005 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_005 for 5

// CAP_006 (matches Coq: Theorem CAP_006)
assert CAP_006 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_006 for 5

// CAP_007 (matches Coq: Theorem CAP_007)
assert CAP_007 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_007 for 5

// CAP_008 (matches Coq: Theorem CAP_008)
assert CAP_008 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_008 for 5

// CAP_009 (matches Coq: Theorem CAP_009)
assert CAP_009 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_009 for 5

// CAP_010 (matches Coq: Theorem CAP_010)
assert CAP_010 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_010 for 5

// CAP_011 (matches Coq: Theorem CAP_011)
assert CAP_011 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_011 for 5

// CAP_012 (matches Coq: Theorem CAP_012)
assert CAP_012 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_012 for 5

// CAP_013 (matches Coq: Theorem CAP_013)
assert CAP_013 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_013 for 5

// CAP_014 (matches Coq: Theorem CAP_014)
assert CAP_014 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_014 for 5

// CAP_015 (matches Coq: Theorem CAP_015)
assert CAP_015 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_015 for 5

// CAP_016 (matches Coq: Theorem CAP_016)
assert CAP_016 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_016 for 5

// CAP_017 (matches Coq: Theorem CAP_017)
assert CAP_017 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_017 for 5

// CAP_018 (matches Coq: Theorem CAP_018)
assert CAP_018 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_018 for 5

// CAP_019 (matches Coq: Theorem CAP_019)
assert CAP_019 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_019 for 5

// CAP_020 (matches Coq: Theorem CAP_020)
assert CAP_020 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_020 for 5

// CAP_021 (matches Coq: Theorem CAP_021)
assert CAP_021 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_021 for 5

// CAP_022 (matches Coq: Theorem CAP_022)
assert CAP_022 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_022 for 5

// CAP_023 (matches Coq: Theorem CAP_023)
assert CAP_023 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_023 for 5

// CAP_024 (matches Coq: Theorem CAP_024)
assert CAP_024 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_024 for 5

// CAP_025 (matches Coq: Theorem CAP_025)
assert CAP_025 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_025 for 5

// CAP_026 (matches Coq: Theorem CAP_026)
assert CAP_026 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_026 for 5

// CAP_027 (matches Coq: Theorem CAP_027)
assert CAP_027 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_027 for 5

// CAP_028 (matches Coq: Theorem CAP_028)
assert CAP_028 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_028 for 5

// CAP_029 (matches Coq: Theorem CAP_029)
assert CAP_029 {
  all c: Capability | some c.cap_unforgeable
}
check CAP_029 for 5

// CAP_030_complete (matches Coq: Theorem CAP_030_complete)
assert CAP_030_complete {
  all c: Capability | some c.cap_unforgeable
}
check CAP_030_complete for 5

// CAP_031_unforgeable_implies_authentic (matches Coq: Theorem CAP_031_unforgeable_implies_authentic)
assert CAP_031_unforgeable_implies_authentic {
  all c: Capability | some c.cap_unforgeable
}
check CAP_031_unforgeable_implies_authentic for 5

// CAP_032_unforgeable_config (matches Coq: Theorem CAP_032_unforgeable_config)
assert CAP_032_unforgeable_config {
  all c: Capability | some c.cap_unforgeable
}
check CAP_032_unforgeable_config for 5

// CAP_033_unforgeable_preservation (matches Coq: Theorem CAP_033_unforgeable_preservation)
assert CAP_033_unforgeable_preservation {
  all c: Capability | some c.cap_unforgeable
}
check CAP_033_unforgeable_preservation for 5

// CAP_034_unforgeable_and_revocable (matches Coq: Theorem CAP_034_unforgeable_and_revocable)
assert CAP_034_unforgeable_and_revocable {
  all c: Capability | some c.cap_unforgeable
}
check CAP_034_unforgeable_and_revocable for 5

// CAP_035_no_forge_without_grant (matches Coq: Theorem CAP_035_no_forge_without_grant)
assert CAP_035_no_forge_without_grant {
  all c: Capability | some c.cap_unforgeable
}
check CAP_035_no_forge_without_grant for 5

// CAP_036_encapsulation_prevents_forge (matches Coq: Theorem CAP_036_encapsulation_prevents_forge)
assert CAP_036_encapsulation_prevents_forge {
  all c: Capability | some c.cap_unforgeable
}
check CAP_036_encapsulation_prevents_forge for 5

// CAP_037_connectivity_controlled (matches Coq: Theorem CAP_037_connectivity_controlled)
assert CAP_037_connectivity_controlled {
  all c: Capability | some c.cap_unforgeable
}
check CAP_037_connectivity_controlled for 5

// CAP_038_unforgeable_mem_cap (matches Coq: Theorem CAP_038_unforgeable_mem_cap)
assert CAP_038_unforgeable_mem_cap {
  all c: Capability | some c.cap_unforgeable
}
check CAP_038_unforgeable_mem_cap for 5

// CAP_039_sealed_cap_unforgeable (matches Coq: Theorem CAP_039_sealed_cap_unforgeable)
assert CAP_039_sealed_cap_unforgeable {
  all c: Capability | some c.cap_unforgeable
}
check CAP_039_sealed_cap_unforgeable for 5

// CAP_040_valid_cap_required (matches Coq: Theorem CAP_040_valid_cap_required)
assert CAP_040_valid_cap_required {
  all c: Capability | some c.cap_unforgeable
}
check CAP_040_valid_cap_required for 5

// CAP_041_attenuatable_means_monotonic (matches Coq: Theorem CAP_041_attenuatable_means_monotonic)
assert CAP_041_attenuatable_means_monotonic {
  all c: Capability | some c.cap_unforgeable
}
check CAP_041_attenuatable_means_monotonic for 5

// perm_in_head (matches Coq: Lemma perm_in_head)
assert perm_in_head {
  all c: Capability | some c.cap_unforgeable
}
check perm_in_head for 5

// perm_in_cons (matches Coq: Lemma perm_in_cons)
assert perm_in_cons {
  all c: Capability | some c.cap_unforgeable
}
check perm_in_cons for 5

// forallb_impl (matches Coq: Lemma forallb_impl)
assert forallb_impl {
  all c: Capability | some c.cap_unforgeable
}
check forallb_impl for 5

// CAP_042_perms_subset_reflexive (matches Coq: Theorem CAP_042_perms_subset_reflexive)
assert CAP_042_perms_subset_reflexive {
  all c: Capability | some c.cap_unforgeable
}
check CAP_042_perms_subset_reflexive for 5

// CAP_043_empty_perms_subset (matches Coq: Theorem CAP_043_empty_perms_subset)
assert CAP_043_empty_perms_subset {
  all c: Capability | some c.cap_unforgeable
}
check CAP_043_empty_perms_subset for 5

// CAP_044_derive_from_self (matches Coq: Theorem CAP_044_derive_from_self)
assert CAP_044_derive_from_self {
  all c: Capability | some c.cap_unforgeable
}
check CAP_044_derive_from_self for 5

// CAP_045_derive_cannot_exceed_parent (matches Coq: Theorem CAP_045_derive_cannot_exceed_parent)
assert CAP_045_derive_cannot_exceed_parent {
  all c: Capability | some c.cap_unforgeable
}
check CAP_045_derive_cannot_exceed_parent for 5

// CAP_046_derive_bounds_contained (matches Coq: Theorem CAP_046_derive_bounds_contained)
assert CAP_046_derive_bounds_contained {
  all c: Capability | some c.cap_unforgeable
}
check CAP_046_derive_bounds_contained for 5

// CAP_047_derive_perms_subset (matches Coq: Theorem CAP_047_derive_perms_subset)
assert CAP_047_derive_perms_subset {
  all c: Capability | some c.cap_unforgeable
}
check CAP_047_derive_perms_subset for 5

// CAP_048_sealed_prevents_derive (matches Coq: Theorem CAP_048_sealed_prevents_derive)
assert CAP_048_sealed_prevents_derive {
  all c: Capability | some c.cap_unforgeable
}
check CAP_048_sealed_prevents_derive for 5

// CAP_049_perm_leq_reflexive (matches Coq: Theorem CAP_049_perm_leq_reflexive)
assert CAP_049_perm_leq_reflexive {
  all c: Capability | some c.cap_unforgeable
}
check CAP_049_perm_leq_reflexive for 5

// CAP_050_read_leq_write (matches Coq: Theorem CAP_050_read_leq_write)
assert CAP_050_read_leq_write {
  all c: Capability | some c.cap_unforgeable
}
check CAP_050_read_leq_write for 5

// CAP_051_write_leq_execute (matches Coq: Theorem CAP_051_write_leq_execute)
assert CAP_051_write_leq_execute {
  all c: Capability | some c.cap_unforgeable
}
check CAP_051_write_leq_execute for 5

// CAP_052_perm_leq_transitive (matches Coq: Theorem CAP_052_perm_leq_transitive)
assert CAP_052_perm_leq_transitive {
  all c: Capability | some c.cap_unforgeable
}
check CAP_052_perm_leq_transitive for 5

// CAP_053_perm_lt_irreflexive (matches Coq: Theorem CAP_053_perm_lt_irreflexive)
assert CAP_053_perm_lt_irreflexive {
  all c: Capability | some c.cap_unforgeable
}
check CAP_053_perm_lt_irreflexive for 5

// CAP_054_monotonic_no_escalation (matches Coq: Theorem CAP_054_monotonic_no_escalation)
assert CAP_054_monotonic_no_escalation {
  all c: Capability | some c.cap_unforgeable
}
check CAP_054_monotonic_no_escalation for 5

// CAP_055_derive_preserves_validity (matches Coq: Theorem CAP_055_derive_preserves_validity)
assert CAP_055_derive_preserves_validity {
  all c: Capability | some c.cap_unforgeable
}
check CAP_055_derive_preserves_validity for 5

// CAP_056_empty_not_revoked (matches Coq: Theorem CAP_056_empty_not_revoked)
assert CAP_056_empty_not_revoked {
  all c: Capability | some c.cap_unforgeable
}
check CAP_056_empty_not_revoked for 5

// CAP_057_revoke_makes_revoked (matches Coq: Theorem CAP_057_revoke_makes_revoked)
assert CAP_057_revoke_makes_revoked {
  all c: Capability | some c.cap_unforgeable
}
check CAP_057_revoke_makes_revoked for 5

// CAP_058_revoke_idempotent (matches Coq: Theorem CAP_058_revoke_idempotent)
assert CAP_058_revoke_idempotent {
  all c: Capability | some c.cap_unforgeable
}
check CAP_058_revoke_idempotent for 5

// CAP_059_revoke_other_unchanged (matches Coq: Theorem CAP_059_revoke_other_unchanged)
assert CAP_059_revoke_other_unchanged {
  all c: Capability | some c.cap_unforgeable
}
check CAP_059_revoke_other_unchanged for 5

// CAP_060_cap_revocable_riina (matches Coq: Theorem CAP_060_cap_revocable_riina)
assert CAP_060_cap_revocable_riina {
  all c: Capability | some c.cap_unforgeable
}
check CAP_060_cap_revocable_riina for 5

// CAP_061_revocable_implies_can_revoke (matches Coq: Theorem CAP_061_revocable_implies_can_revoke)
assert CAP_061_revocable_implies_can_revoke {
  all c: Capability | some c.cap_unforgeable
}
check CAP_061_revocable_implies_can_revoke for 5

// CAP_062_revoked_mem_cap_invalid (matches Coq: Theorem CAP_062_revoked_mem_cap_invalid)
assert CAP_062_revoked_mem_cap_invalid {
  all c: Capability | some c.cap_unforgeable
}
check CAP_062_revoked_mem_cap_invalid for 5

// CAP_063_revoked_cannot_read (matches Coq: Theorem CAP_063_revoked_cannot_read)
assert CAP_063_revoked_cannot_read {
  all c: Capability | some c.cap_unforgeable
}
check CAP_063_revoked_cannot_read for 5

// CAP_064_revoked_cannot_write (matches Coq: Theorem CAP_064_revoked_cannot_write)
assert CAP_064_revoked_cannot_write {
  all c: Capability | some c.cap_unforgeable
}
check CAP_064_revoked_cannot_write for 5

// CAP_065_revoked_cannot_execute (matches Coq: Theorem CAP_065_revoked_cannot_execute)
assert CAP_065_revoked_cannot_execute {
  all c: Capability | some c.cap_unforgeable
}
check CAP_065_revoked_cannot_execute for 5

// CAP_066_confinement_enforced (matches Coq: Theorem CAP_066_confinement_enforced)
assert CAP_066_confinement_enforced {
  all c: Capability | some c.cap_unforgeable
}
check CAP_066_confinement_enforced for 5

// CAP_067_no_ambient_authority (matches Coq: Theorem CAP_067_no_ambient_authority)
assert CAP_067_no_ambient_authority {
  all c: Capability | some c.cap_unforgeable
}
check CAP_067_no_ambient_authority for 5

// CAP_068_explicit_access_only (matches Coq: Theorem CAP_068_explicit_access_only)
assert CAP_068_explicit_access_only {
  all c: Capability | some c.cap_unforgeable
}
check CAP_068_explicit_access_only for 5

// CAP_069_no_privilege_escalation (matches Coq: Theorem CAP_069_no_privilege_escalation)
assert CAP_069_no_privilege_escalation {
  all c: Capability | some c.cap_unforgeable
}
check CAP_069_no_privilege_escalation for 5

// CAP_070_ocap_no_ambient (matches Coq: Theorem CAP_070_ocap_no_ambient)
assert CAP_070_ocap_no_ambient {
  all c: Capability | some c.cap_unforgeable
}
check CAP_070_ocap_no_ambient for 5

// CAP_071_has_cap_empty (matches Coq: Theorem CAP_071_has_cap_empty)
assert CAP_071_has_cap_empty {
  all c: Capability | some c.cap_unforgeable
}
check CAP_071_has_cap_empty for 5

// CAP_072_has_cap_head (matches Coq: Theorem CAP_072_has_cap_head)
assert CAP_072_has_cap_head {
  all c: Capability | some c.cap_unforgeable
}
check CAP_072_has_cap_head for 5

// CAP_073_confinement_complete (matches Coq: Theorem CAP_073_confinement_complete)
assert CAP_073_confinement_complete {
  all c: Capability | some c.cap_unforgeable
}
check CAP_073_confinement_complete for 5

// CAP_074_confined_needs_cap (matches Coq: Theorem CAP_074_confined_needs_cap)
assert CAP_074_confined_needs_cap {
  all c: Capability | some c.cap_unforgeable
}
check CAP_074_confined_needs_cap for 5

// CAP_075_confined_no_escalate (matches Coq: Theorem CAP_075_confined_no_escalate)
assert CAP_075_confined_no_escalate {
  all c: Capability | some c.cap_unforgeable
}
check CAP_075_confined_no_escalate for 5

// CAP_076_full_can_redelegate (matches Coq: Theorem CAP_076_full_can_redelegate)
assert CAP_076_full_can_redelegate {
  all c: Capability | some c.cap_unforgeable
}
check CAP_076_full_can_redelegate for 5

// CAP_077_restricted_cannot_redelegate (matches Coq: Theorem CAP_077_restricted_cannot_redelegate)
assert CAP_077_restricted_cannot_redelegate {
  all c: Capability | some c.cap_unforgeable
}
check CAP_077_restricted_cannot_redelegate for 5

// CAP_078_once_cannot_redelegate (matches Coq: Theorem CAP_078_once_cannot_redelegate)
assert CAP_078_once_cannot_redelegate {
  all c: Capability | some c.cap_unforgeable
}
check CAP_078_once_cannot_redelegate for 5

// CAP_079_inactive_delegation (matches Coq: Theorem CAP_079_inactive_delegation)
assert CAP_079_inactive_delegation {
  all c: Capability | some c.cap_unforgeable
}
check CAP_079_inactive_delegation for 5

// CAP_080_delegation_has_from (matches Coq: Theorem CAP_080_delegation_has_from)
assert CAP_080_delegation_has_from {
  all c: Capability | some c.cap_unforgeable
}
check CAP_080_delegation_has_from for 5

// CAP_081_delegation_has_to (matches Coq: Theorem CAP_081_delegation_has_to)
assert CAP_081_delegation_has_to {
  all c: Capability | some c.cap_unforgeable
}
check CAP_081_delegation_has_to for 5

// CAP_082_delegation_has_cap (matches Coq: Theorem CAP_082_delegation_has_cap)
assert CAP_082_delegation_has_cap {
  all c: Capability | some c.cap_unforgeable
}
check CAP_082_delegation_has_cap for 5

// CAP_083_delegation_type_full (matches Coq: Theorem CAP_083_delegation_type_full)
assert CAP_083_delegation_type_full {
  all c: Capability | some c.cap_unforgeable
}
check CAP_083_delegation_type_full for 5

// CAP_084_delegation_type_restricted (matches Coq: Theorem CAP_084_delegation_type_restricted)
assert CAP_084_delegation_type_restricted {
  all c: Capability | some c.cap_unforgeable
}
check CAP_084_delegation_type_restricted for 5

// CAP_085_delegation_type_once (matches Coq: Theorem CAP_085_delegation_type_once)
assert CAP_085_delegation_type_once {
  all c: Capability | some c.cap_unforgeable
}
check CAP_085_delegation_type_once for 5

// CAP_086_bounds_check_in_range (matches Coq: Theorem CAP_086_bounds_check_in_range)
assert CAP_086_bounds_check_in_range {
  all c: Capability | some c.cap_unforgeable
}
check CAP_086_bounds_check_in_range for 5

// CAP_087_bounds_check_out_of_range_low (matches Coq: Theorem CAP_087_bounds_check_out_of_range_low)
assert CAP_087_bounds_check_out_of_range_low {
  all c: Capability | some c.cap_unforgeable
}
check CAP_087_bounds_check_out_of_range_low for 5

// CAP_088_bounds_check_out_of_range_high (matches Coq: Theorem CAP_088_bounds_check_out_of_range_high)
assert CAP_088_bounds_check_out_of_range_high {
  all c: Capability | some c.cap_unforgeable
}
check CAP_088_bounds_check_out_of_range_high for 5

// CAP_089_riina_mem_cap_valid (matches Coq: Theorem CAP_089_riina_mem_cap_valid)
assert CAP_089_riina_mem_cap_valid {
  all c: Capability | some c.cap_unforgeable
}
check CAP_089_riina_mem_cap_valid for 5

// CAP_090_riina_mem_cap_not_sealed (matches Coq: Theorem CAP_090_riina_mem_cap_not_sealed)
assert CAP_090_riina_mem_cap_not_sealed {
  all c: Capability | some c.cap_unforgeable
}
check CAP_090_riina_mem_cap_not_sealed for 5

// CAP_091_riina_mem_cap_base (matches Coq: Theorem CAP_091_riina_mem_cap_base)
assert CAP_091_riina_mem_cap_base {
  all c: Capability | some c.cap_unforgeable
}
check CAP_091_riina_mem_cap_base for 5

// CAP_092_riina_mem_cap_length (matches Coq: Theorem CAP_092_riina_mem_cap_length)
assert CAP_092_riina_mem_cap_length {
  all c: Capability | some c.cap_unforgeable
}
check CAP_092_riina_mem_cap_length for 5

// CAP_093_valid_for_read (matches Coq: Theorem CAP_093_valid_for_read)
assert CAP_093_valid_for_read {
  all c: Capability | some c.cap_unforgeable
}
check CAP_093_valid_for_read for 5

// CAP_094_valid_for_write (matches Coq: Theorem CAP_094_valid_for_write)
assert CAP_094_valid_for_write {
  all c: Capability | some c.cap_unforgeable
}
check CAP_094_valid_for_write for 5

// CAP_095_valid_for_execute (matches Coq: Theorem CAP_095_valid_for_execute)
assert CAP_095_valid_for_execute {
  all c: Capability | some c.cap_unforgeable
}
check CAP_095_valid_for_execute for 5

// CAP_096_sealed_cannot_derive (matches Coq: Theorem CAP_096_sealed_cannot_derive)
assert CAP_096_sealed_cannot_derive {
  all c: Capability | some c.cap_unforgeable
}
check CAP_096_sealed_cannot_derive for 5

// CAP_097_empty_perms_no_access (matches Coq: Theorem CAP_097_empty_perms_no_access)
assert CAP_097_empty_perms_no_access {
  all c: Capability | some c.cap_unforgeable
}
check CAP_097_empty_perms_no_access for 5

// CAP_098_mem_cap_complete (matches Coq: Theorem CAP_098_mem_cap_complete)
assert CAP_098_mem_cap_complete {
  all c: Capability | some c.cap_unforgeable
}
check CAP_098_mem_cap_complete for 5

// CAP_099_zero_length_no_access (matches Coq: Theorem CAP_099_zero_length_no_access)
assert CAP_099_zero_length_no_access {
  all c: Capability | some c.cap_unforgeable
}
check CAP_099_zero_length_no_access for 5

// CAP_100_security_complete (matches Coq: Theorem CAP_100_security_complete)
assert CAP_100_security_complete {
  all c: Capability | some c.cap_unforgeable
}
check CAP_100_security_complete for 5
