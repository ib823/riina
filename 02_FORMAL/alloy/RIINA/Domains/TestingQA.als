// SPDX-License-Identifier: MPL-2.0
// Copyright (c) 2026 The RIINA Authors.
// Auto-generated from 02_FORMAL/coq/domains/TestingQA.v (29 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/testing_qa

open util/boolean

// TestResult (matches Coq: Inductive TestResult)
abstract sig TestResult {}
one sig TRPass extends TestResult {}
one sig TRFail extends TestResult {}
one sig TRError extends TestResult {}

// TraceEvent (matches Coq: Inductive TraceEvent)
abstract sig TraceEvent {}
one sig TEEnter extends TraceEvent {}
one sig TEExit extends TraceEvent {}
one sig TEAssert extends TraceEvent {}
one sig TECoverage extends TraceEvent {}

// MutationOp (matches Coq: Inductive MutationOp)
abstract sig MutationOp {}
one sig MONegate extends MutationOp {}
one sig MOArithSwap extends MutationOp {}
one sig MORelSwap extends MutationOp {}
one sig MODeleteStmt extends MutationOp {}
one sig MOConstChange extends MutationOp {}

// SecurityProperty (matches Coq: Inductive SecurityProperty)
abstract sig SecurityProperty {}
one sig SPAuthentication extends SecurityProperty {}
one sig SPAuthorization extends SecurityProperty {}
one sig SPConfidentiality extends SecurityProperty {}
one sig SPIntegrity extends SecurityProperty {}
one sig SPNonRepudiation extends SecurityProperty {}

// SimpleType (matches Coq: Inductive SimpleType)
abstract sig SimpleType {}
one sig TyNat extends SimpleType {}
one sig TyBool extends SimpleType {}
one sig TyFun extends SimpleType {}

// Expr (matches Coq: Inductive Expr)
abstract sig Expr {}
one sig ENat extends Expr {}
one sig EBool extends Expr {}
one sig EAdd extends Expr {}
one sig EIf extends Expr {}

// SanitizerResult (matches Coq: Inductive SanitizerResult)
abstract sig SanitizerResult {}
one sig SRClean extends SanitizerResult {}
one sig SRViolation extends SanitizerResult {}

// TestCase (matches Coq: Record TestCase)
sig TestCase {
  tc_name: one string,
  tc_input: one Int,
  tc_expected: one Int
}

// GenState (matches Coq: Record GenState)
sig GenState {
  gs_seed: one Int,
  gs_size: one Int
}

// Mutant (matches Coq: Record Mutant)
sig Mutant {
  mut_location: one Int,
  mut_operator: one MutationOp,
  mut_killed: one Bool
}

// SecurityCoverage (matches Coq: Record SecurityCoverage)
sig SecurityCoverage {
  sc_properties: one list,
  sc_tested: one list
}

// TimingMeasurement (matches Coq: Record TimingMeasurement)
sig TimingMeasurement {
  tm_input1: one Int,
  tm_input2: one Int,
  tm_time1: one Int,
  tm_time2: one Int
}

// TestState (matches Coq: Record TestState)
sig TestState {
  ts_counter: one Int,
  ts_flag: one Bool
}

// Fixture (matches Coq: Record Fixture)
sig Fixture {
  fix_setup: one TestState,
  fix_teardown: one TestState
}

// Component (matches Coq: Record Component)
sig Component {
  comp_name: one string,
  comp_input_type: one SimpleType,
  comp_output_type: one SimpleType,
  comp_impl: one Int
}

// APIContract (matches Coq: Record APIContract)
sig APIContract {
  api_precondition: one Int,
  api_postcondition: one Int,
  api_impl: one Int
}

// SecurityFlow (matches Coq: Record SecurityFlow)
sig SecurityFlow {
  sf_source: one SecurityProperty,
  sf_sink: one SecurityProperty,
  sf_valid: one Bool
}

// KATTest (matches Coq: Record KATTest)
sig KATTest {
  kat_input: one Int,
  kat_expected: one Int
}

// BruteForceProtection (matches Coq: Record BruteForceProtection)
sig BruteForceProtection {
  bfp_max_attempts: one Int,
  bfp_current_attempts: one Int,
  bfp_locked: one Bool
}

// is_constant_time (matches Coq: Definition is_constant_time)
pred is_constant_time[tm: TimingMeasurement, tolerance: nat] {
  some tm
}

// run_test (matches Coq: Definition run_test)
pred run_test[tc: TestCase] {
  some tc
}

// test_result_eqb (matches Coq: Definition test_result_eqb)
pred test_result_eqb {}

// test_passed (matches Coq: Definition test_passed)
pred test_passed[r: TestResult] {
  some r
}

// initial_state (matches Coq: Definition initial_state)
pred initial_state {}

// id_fixture (matches Coq: Definition id_fixture)
pred id_fixture {}

// expected_panic (matches Coq: Definition expected_panic)
pred expected_panic[input: nat] {
  some input
}

// check_property (matches Coq: Definition check_property)
pred check_property[prop: Property] {
  some prop
}

// path_covered (matches Coq: Definition path_covered)
pred path_covered[p: CodePath] {
  some p
}

// valid_structured_input (matches Coq: Definition valid_structured_input)
pred valid_structured_input[n: nat] {
  some n
}

// differential_test (matches Coq: Definition differential_test)
pred differential_test[input: nat] {
  some input
}

// sanitizer_pass (matches Coq: Definition sanitizer_pass)
pred sanitizer_pass[sr: SanitizerResult] {
  some sr
}

// satisfies_contract (matches Coq: Definition satisfies_contract)
pred satisfies_contract[api: APIContract, input: nat] {
  some api
}

// mutation_valid (matches Coq: Definition mutation_valid)
pred mutation_valid[m: Mutant, max_loc: nat] {
  some m
}

// mutation_score (matches Coq: Definition mutation_score)
pred mutation_score {}

// test_detects_mutation (matches Coq: Definition test_detects_mutation)
pred test_detects_mutation[tc: TestCase] {
  some tc
}

// timing_attack_detected (matches Coq: Definition timing_attack_detected)
pred timing_attack_detected[tolerance: nat] {
  some tolerance
}

// run_kat (matches Coq: Definition run_kat)
pred run_kat[kat: KATTest] {
  some kat
}

// check_brute_force (matches Coq: Definition check_brute_force)
pred check_brute_force[bfp: BruteForceProtection] {
  some bfp
}

// line_covered (matches Coq: Definition line_covered)
pred line_covered[line: nat, trace: ExecutionTrace] {
  some line
}

// sec_prop_eqb (matches Coq: Definition sec_prop_eqb)
pred sec_prop_eqb {}

// security_prop_covered (matches Coq: Definition security_prop_covered)
pred security_prop_covered[sp: SecurityProperty, sc: SecurityCoverage] {
  some sp
}

// all_security_covered (matches Coq: Definition all_security_covered)
pred all_security_covered[sc: SecurityCoverage] {
  some sc
}

// nat_eqb_refl (matches Coq: Lemma nat_eqb_refl)
assert nat_eqb_refl {
  all c: TestCase | some c.tc_name
}
check nat_eqb_refl for 5

// forallb_true_iff (matches Coq: Lemma forallb_true_iff)
assert forallb_true_iff {
  all c: TestCase | some c.tc_name
}
check forallb_true_iff for 5

// existsb_exists (matches Coq: Lemma existsb_exists)
assert existsb_exists {
  all c: TestCase | some c.tc_name
}
check existsb_exists for 5

// list_beq_refl (matches Coq: Lemma list_beq_refl)
assert list_beq_refl {
  all c: TestCase | some c.tc_name
}
check list_beq_refl for 5

// M_001_01 (matches Coq: Theorem M_001_01)
assert M_001_01 {
  all c: TestCase | some c.tc_name
}
check M_001_01 for 5

// M_001_02 (matches Coq: Theorem M_001_02)
assert M_001_02 {
  all c: TestCase | some c.tc_name
}
check M_001_02 for 5

// M_001_03 (matches Coq: Theorem M_001_03)
assert M_001_03 {
  all c: TestCase | some c.tc_name
}
check M_001_03 for 5

// M_001_04 (matches Coq: Theorem M_001_04)
assert M_001_04 {
  all c: TestCase | some c.tc_name
}
check M_001_04 for 5

// M_001_05 (matches Coq: Theorem M_001_05)
assert M_001_05 {
  all c: TestCase | some c.tc_name
}
check M_001_05 for 5

// M_001_06 (matches Coq: Theorem M_001_06)
assert M_001_06 {
  all c: TestCase | some c.tc_name
}
check M_001_06 for 5

// M_001_07 (matches Coq: Theorem M_001_07)
assert M_001_07 {
  all c: TestCase | some c.tc_name
}
check M_001_07 for 5

// M_001_08 (matches Coq: Theorem M_001_08)
assert M_001_08 {
  all c: TestCase | some c.tc_name
}
check M_001_08 for 5

// M_001_09 (matches Coq: Theorem M_001_09)
assert M_001_09 {
  all c: TestCase | some c.tc_name
}
check M_001_09 for 5

// M_001_10 (matches Coq: Theorem M_001_10)
assert M_001_10 {
  all c: TestCase | some c.tc_name
}
check M_001_10 for 5

// M_001_11 (matches Coq: Theorem M_001_11)
assert M_001_11 {
  all c: TestCase | some c.tc_name
}
check M_001_11 for 5

// M_001_12 (matches Coq: Theorem M_001_12)
assert M_001_12 {
  all c: TestCase | some c.tc_name
}
check M_001_12 for 5

// M_001_13 (matches Coq: Theorem M_001_13)
assert M_001_13 {
  all c: TestCase | some c.tc_name
}
check M_001_13 for 5

// M_001_14 (matches Coq: Theorem M_001_14)
assert M_001_14 {
  all c: TestCase | some c.tc_name
}
check M_001_14 for 5

// M_001_15 (matches Coq: Theorem M_001_15)
assert M_001_15 {
  all c: TestCase | some c.tc_name
}
check M_001_15 for 5

// M_001_16 (matches Coq: Theorem M_001_16)
assert M_001_16 {
  all c: TestCase | some c.tc_name
}
check M_001_16 for 5

// M_001_17 (matches Coq: Theorem M_001_17)
assert M_001_17 {
  all c: TestCase | some c.tc_name
}
check M_001_17 for 5

// M_001_18 (matches Coq: Theorem M_001_18)
assert M_001_18 {
  all c: TestCase | some c.tc_name
}
check M_001_18 for 5

// M_001_19 (matches Coq: Theorem M_001_19)
assert M_001_19 {
  all c: TestCase | some c.tc_name
}
check M_001_19 for 5

// M_001_20 (matches Coq: Theorem M_001_20)
assert M_001_20 {
  all c: TestCase | some c.tc_name
}
check M_001_20 for 5

// M_001_21 (matches Coq: Theorem M_001_21)
assert M_001_21 {
  all c: TestCase | some c.tc_name
}
check M_001_21 for 5

// M_001_22 (matches Coq: Theorem M_001_22)
assert M_001_22 {
  all c: TestCase | some c.tc_name
}
check M_001_22 for 5

// M_001_23 (matches Coq: Theorem M_001_23)
assert M_001_23 {
  all c: TestCase | some c.tc_name
}
check M_001_23 for 5

// M_001_24 (matches Coq: Theorem M_001_24)
assert M_001_24 {
  all c: TestCase | some c.tc_name
}
check M_001_24 for 5

// M_001_25 (matches Coq: Theorem M_001_25)
assert M_001_25 {
  all c: TestCase | some c.tc_name
}
check M_001_25 for 5
