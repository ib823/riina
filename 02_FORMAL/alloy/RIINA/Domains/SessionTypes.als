// SPDX-License-Identifier: MPL-2.0
// Copyright (c) 2026 The RIINA Authors.
// Auto-generated from 02_FORMAL/coq/domains/SessionTypes.v (45 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/session_types

open util/boolean

// MsgType (matches Coq: Inductive MsgType)
abstract sig MsgType {}
one sig MTNat extends MsgType {}
one sig MTBool extends MsgType {}
one sig MTUnit extends MsgType {}
one sig MTString extends MsgType {}

// SessionType (matches Coq: Inductive SessionType)
abstract sig SessionType {}
one sig SSend extends SessionType {} // !T.S - send type T then continue as S
one sig SRecv extends SessionType {} // ?T.S - receive type T then continue as S
one sig SSelect extends SessionType {} // +{L:S} - internal choice
one sig SOffer extends SessionType {} // &{L:S} - external choice
one sig SEnd extends SessionType {}

// Process (matches Coq: Inductive Process)
abstract sig Process {}
one sig PSend extends Process {} // send value on channel, continue
one sig PRecv extends Process {} // receive on channel, continue
one sig PSelect extends Process {} // select branch on channel
one sig POffer extends Process {} // offer branches
one sig PClose extends Process {} // close channel
one sig PEnd extends Process {} // terminated process
one sig PPar extends Process {}

// Channel (matches Coq: Record Channel)
sig Channel {
  chan_id: one Int,
  chan_type: one SessionType,
  chan_linear: one Bool // Linear flag - must be used exactly once
}

// ChannelPair (matches Coq: Record ChannelPair)
sig ChannelPair {
  endpoint_a: one Channel,
  endpoint_b: one Channel
}

// msg_type_eqb (matches Coq: Definition msg_type_eqb)
pred msg_type_eqb {}

// channel_used (matches Coq: Definition channel_used)
pred channel_used[ch: Channel] {
  some ch
}

// is_fresh (matches Coq: Definition is_fresh)
pred is_fresh[ch: Channel] {
  some ch
}

// well_formed_pair (matches Coq: Definition well_formed_pair)
pred well_formed_pair[cp: ChannelPair] {
  some cp
}

// is_value (matches Coq: Definition is_value)
pred is_value[p: Process] {
  some p
}

// waiting (matches Coq: Definition waiting)
pred waiting[cfg: Config, t: ThreadId, r: Resource] {
  some cfg
}

// holding (matches Coq: Definition holding)
pred holding[cfg: Config, t: ThreadId, r: Resource] {
  some cfg
}

// waits_for (matches Coq: Definition waits_for)
pred waits_for[cfg: Config] {
  some cfg
}

// circular_wait (matches Coq: Definition circular_wait)
pred circular_wait[cfg: Config] {
  some cfg
}

// deadlocked (matches Coq: Definition deadlocked)
pred deadlocked[cfg: Config] {
  some cfg
}

// session_typed (matches Coq: Definition session_typed)
pred session_typed[cfg: Config] {
  some cfg
}

// ST_001_dual_end (matches Coq: Theorem ST_001_dual_end)
assert ST_001_dual_end {
  all c: Channel | some c.chan_id
}
check ST_001_dual_end for 5

// ST_002_dual_send_recv (matches Coq: Theorem ST_002_dual_send_recv)
assert ST_002_dual_send_recv {
  all c: Channel | some c.chan_id
}
check ST_002_dual_send_recv for 5

// ST_003_dual_recv_send (matches Coq: Theorem ST_003_dual_recv_send)
assert ST_003_dual_recv_send {
  all c: Channel | some c.chan_id
}
check ST_003_dual_recv_send for 5

// ST_004_dual_select_offer (matches Coq: Theorem ST_004_dual_select_offer)
assert ST_004_dual_select_offer {
  all c: Channel | some c.chan_id
}
check ST_004_dual_select_offer for 5

// ST_005_dual_offer_select (matches Coq: Theorem ST_005_dual_offer_select)
assert ST_005_dual_offer_select {
  all c: Channel | some c.chan_id
}
check ST_005_dual_offer_select for 5

// ST_006_dual_involutive_end (matches Coq: Theorem ST_006_dual_involutive_end)
assert ST_006_dual_involutive_end {
  all c: Channel | some c.chan_id
}
check ST_006_dual_involutive_end for 5

// ST_007_dual_involutive_send (matches Coq: Theorem ST_007_dual_involutive_send)
assert ST_007_dual_involutive_send {
  all c: Channel | some c.chan_id
}
check ST_007_dual_involutive_send for 5

// ST_008_dual_involutive_recv (matches Coq: Theorem ST_008_dual_involutive_recv)
assert ST_008_dual_involutive_recv {
  all c: Channel | some c.chan_id
}
check ST_008_dual_involutive_recv for 5

// ST_009_dual_chain (matches Coq: Theorem ST_009_dual_chain)
assert ST_009_dual_chain {
  all c: Channel | some c.chan_id
}
check ST_009_dual_chain for 5

// ST_010_dual_chain_rev (matches Coq: Theorem ST_010_dual_chain_rev)
assert ST_010_dual_chain_rev {
  all c: Channel | some c.chan_id
}
check ST_010_dual_chain_rev for 5

// ST_011_dual_preserves_msg (matches Coq: Theorem ST_011_dual_preserves_msg)
assert ST_011_dual_preserves_msg {
  all c: Channel | some c.chan_id
}
check ST_011_dual_preserves_msg for 5

// ST_012_endpoints_dual (matches Coq: Theorem ST_012_endpoints_dual)
assert ST_012_endpoints_dual {
  all c: Channel | some c.chan_id
}
check ST_012_endpoints_dual for 5

// ST_013_fresh_linear (matches Coq: Theorem ST_013_fresh_linear)
assert ST_013_fresh_linear {
  all c: Channel | some c.chan_id
}
check ST_013_fresh_linear for 5

// ST_014_used_not_linear (matches Coq: Theorem ST_014_used_not_linear)
assert ST_014_used_not_linear {
  all c: Channel | some c.chan_id
}
check ST_014_used_not_linear for 5

// ST_015_use_preserves_id (matches Coq: Theorem ST_015_use_preserves_id)
assert ST_015_use_preserves_id {
  all c: Channel | some c.chan_id
}
check ST_015_use_preserves_id for 5

// ST_016_use_preserves_type (matches Coq: Theorem ST_016_use_preserves_type)
assert ST_016_use_preserves_type {
  all c: Channel | some c.chan_id
}
check ST_016_use_preserves_type for 5

// ST_017_wf_pair_dual (matches Coq: Theorem ST_017_wf_pair_dual)
assert ST_017_wf_pair_dual {
  all c: Channel | some c.chan_id
}
check ST_017_wf_pair_dual for 5

// ST_018_wf_pair_same_id (matches Coq: Theorem ST_018_wf_pair_same_id)
assert ST_018_wf_pair_same_id {
  all c: Channel | some c.chan_id
}
check ST_018_wf_pair_same_id for 5

// ST_019_session_no_deadlock (matches Coq: Theorem ST_019_session_no_deadlock)
assert ST_019_session_no_deadlock {
  all c: Channel | some c.chan_id
}
check ST_019_session_no_deadlock for 5

// ST_020_dual_communicate (matches Coq: Theorem ST_020_dual_communicate)
assert ST_020_dual_communicate {
  all c: Channel | some c.chan_id
}
check ST_020_dual_communicate for 5

// ST_021_value_done (matches Coq: Theorem ST_021_value_done)
assert ST_021_value_done {
  all c: Channel | some c.chan_id
}
check ST_021_value_done for 5

// ST_022_end_is_value (matches Coq: Theorem ST_022_end_is_value)
assert ST_022_end_is_value {
  all c: Channel | some c.chan_id
}
check ST_022_end_is_value for 5

// ST_023_empty_deadlock_free (matches Coq: Theorem ST_023_empty_deadlock_free)
assert ST_023_empty_deadlock_free {
  all c: Channel | some c.chan_id
}
check ST_023_empty_deadlock_free for 5

// ST_024_msg_eq_refl (matches Coq: Theorem ST_024_msg_eq_refl)
assert ST_024_msg_eq_refl {
  all c: Channel | some c.chan_id
}
check ST_024_msg_eq_refl for 5

// ST_025_msg_eq_true (matches Coq: Theorem ST_025_msg_eq_true)
assert ST_025_msg_eq_true {
  all c: Channel | some c.chan_id
}
check ST_025_msg_eq_true for 5

// ST_026_msg_type_cases (matches Coq: Theorem ST_026_msg_type_cases)
assert ST_026_msg_type_cases {
  all c: Channel | some c.chan_id
}
check ST_026_msg_type_cases for 5

// ST_027_msg_type_dec (matches Coq: Theorem ST_027_msg_type_dec)
assert ST_027_msg_type_dec {
  all c: Channel | some c.chan_id
}
check ST_027_msg_type_dec for 5

// ST_028_session_type_cases (matches Coq: Theorem ST_028_session_type_cases)
assert ST_028_session_type_cases {
  all c: Channel | some c.chan_id
}
check ST_028_session_type_cases for 5

// ST_029_dual_non_end_send (matches Coq: Theorem ST_029_dual_non_end_send)
assert ST_029_dual_non_end_send {
  all c: Channel | some c.chan_id
}
check ST_029_dual_non_end_send for 5

// ST_030_dual_non_end_recv (matches Coq: Theorem ST_030_dual_non_end_recv)
assert ST_030_dual_non_end_recv {
  all c: Channel | some c.chan_id
}
check ST_030_dual_non_end_recv for 5

// ST_031_dual_empty_select (matches Coq: Theorem ST_031_dual_empty_select)
assert ST_031_dual_empty_select {
  all c: Channel | some c.chan_id
}
check ST_031_dual_empty_select for 5

// ST_032_dual_empty_offer (matches Coq: Theorem ST_032_dual_empty_offer)
assert ST_032_dual_empty_offer {
  all c: Channel | some c.chan_id
}
check ST_032_dual_empty_offer for 5

// ST_033_lookup_empty (matches Coq: Theorem ST_033_lookup_empty)
assert ST_033_lookup_empty {
  all c: Channel | some c.chan_id
}
check ST_033_lookup_empty for 5

// ST_034_lookup_found (matches Coq: Theorem ST_034_lookup_found)
assert ST_034_lookup_found {
  all c: Channel | some c.chan_id
}
check ST_034_lookup_found for 5

// ST_035_lookup_skip (matches Coq: Theorem ST_035_lookup_skip)
assert ST_035_lookup_skip {
  all c: Channel | some c.chan_id
}
check ST_035_lookup_skip for 5

// ST_036_dual_compose_send (matches Coq: Theorem ST_036_dual_compose_send)
assert ST_036_dual_compose_send {
  all c: Channel | some c.chan_id
}
check ST_036_dual_compose_send for 5

// ST_037_dual_branches (matches Coq: Theorem ST_037_dual_branches)
assert ST_037_dual_branches {
  all c: Channel | some c.chan_id
}
check ST_037_dual_branches for 5

// ST_038_single_branch_dual (matches Coq: Theorem ST_038_single_branch_dual)
assert ST_038_single_branch_dual {
  all c: Channel | some c.chan_id
}
check ST_038_single_branch_dual for 5

// ST_039_wt_end_empty (matches Coq: Theorem ST_039_wt_end_empty)
assert ST_039_wt_end_empty {
  all c: Channel | some c.chan_id
}
check ST_039_wt_end_empty for 5

// ST_040_par_exists (matches Coq: Theorem ST_040_par_exists)
assert ST_040_par_exists {
  all c: Channel | some c.chan_id
}
check ST_040_par_exists for 5

// ST_041_chan_construct (matches Coq: Theorem ST_041_chan_construct)
assert ST_041_chan_construct {
  all c: Channel | some c.chan_id
}
check ST_041_chan_construct for 5

// ST_042_pair_construct (matches Coq: Theorem ST_042_pair_construct)
assert ST_042_pair_construct {
  all c: Channel | some c.chan_id
}
check ST_042_pair_construct for 5

// ST_043_process_cases (matches Coq: Theorem ST_043_process_cases)
assert ST_043_process_cases {
  all c: Channel | some c.chan_id
}
check ST_043_process_cases for 5

// ST_044_dual_triple_end (matches Coq: Theorem ST_044_dual_triple_end)
assert ST_044_dual_triple_end {
  all c: Channel | some c.chan_id
}
check ST_044_dual_triple_end for 5

// ST_045_nested_send_dual (matches Coq: Theorem ST_045_nested_send_dual)
assert ST_045_nested_send_dual {
  all c: Channel | some c.chan_id
}
check ST_045_nested_send_dual for 5
