// SPDX-License-Identifier: MPL-2.0
// Copyright (c) 2026 The RIINA Authors.
// Auto-generated from 02_FORMAL/coq/domains/WasmBackendVerification.v (43 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/wasm_backend_verification

open util/boolean

// WasmValType (matches Coq: Inductive WasmValType)
abstract sig WasmValType {}
one sig I32 extends WasmValType {}
one sig I64 extends WasmValType {}
one sig F32 extends WasmValType {}
one sig F64 extends WasmValType {}

// RiinaType (matches Coq: Inductive RiinaType)
abstract sig RiinaType {}
one sig RTNombor extends RiinaType {} // integer
one sig RTTeks extends RiinaType {} // string â€” pointer in WASM
one sig RTBool extends RiinaType {} // boolean
one sig RTUnit extends RiinaType {} // void
one sig RTSecret extends RiinaType {}
one sig Public extends RiinaType {}
one sig Secret extends RiinaType {}

// WasmInstr (matches Coq: Inductive WasmInstr)
abstract sig WasmInstr {}
one sig WConst extends WasmInstr {} // i32.const
one sig WLoad extends WasmInstr {} // i32.load offset
one sig WStore extends WasmInstr {} // i32.store offset
one sig WAdd extends WasmInstr {} // i32.add
one sig WMul extends WasmInstr {} // i32.mul
one sig WCall extends WasmInstr {} // call func_idx
one sig WLocalGet extends WasmInstr {} // local.get idx
one sig WLocalSet extends WasmInstr {} // local.set idx
one sig WIf extends WasmInstr {}
one sig WReturn extends WasmInstr {}
one sig WDrop extends WasmInstr {}
one sig WNop extends WasmInstr {}

// RiinaIR (matches Coq: Inductive RiinaIR)
abstract sig RiinaIR {}
one sig IRConst extends RiinaIR {}
one sig IRVar extends RiinaIR {}
one sig IRAdd extends RiinaIR {}
one sig IRMul extends RiinaIR {}
one sig IRCall extends RiinaIR {}
one sig IRLet extends RiinaIR {}
one sig IRIf extends RiinaIR {}
one sig IRLoad extends RiinaIR {}
one sig IRStore extends RiinaIR {}

// RiinaEffect (matches Coq: Inductive RiinaEffect)
abstract sig RiinaEffect {}
one sig EffPure extends RiinaEffect {}
one sig EffIO extends RiinaEffect {}
one sig EffNet extends RiinaEffect {}
one sig EffFS extends RiinaEffect {}

// sec_le (matches Coq: Definition sec_le)
pred sec_le {}

// export_is_public (matches Coq: Definition export_is_public)
pred export_is_public[export_func: nat] {
  some export_func
}

// ni_preserved (matches Coq: Definition ni_preserved)
pred ni_preserved {}

// memory_partitioned (matches Coq: Definition memory_partitioned)
pred memory_partitioned {}

// effect_le (matches Coq: Definition effect_le)
pred effect_le {}

// import_effect_safe (matches Coq: Definition import_effect_safe)
pred import_effect_safe[declared: RiinaEffect, import_effect: RiinaEffect] {
  some declared
}

// regions_disjoint (matches Coq: Definition regions_disjoint)
pred regions_disjoint {}

// no_cross_label_access (matches Coq: Definition no_cross_label_access)
pred no_cross_label_access[addr: nat, label: SecLabel] {
  some addr
}

// string_in_segment (matches Coq: Definition string_in_segment)
pred string_in_segment[s: StringConst, seg: DataSegment] {
  some s
}

// string_compiles_to_ptr (matches Coq: Definition string_compiles_to_ptr)
pred string_compiles_to_ptr[s: StringConst] {
  some s
}

// closure_layout_valid (matches Coq: Definition closure_layout_valid)
pred closure_layout_valid[cl: Closure, addr: nat] {
  some cl
}

// compile_closure_alloc (matches Coq: Definition compile_closure_alloc)
pred compile_closure_alloc[cl: Closure, addr: nat] {
  some cl
}

// pair_size (matches Coq: Definition pair_size)
pred pair_size {}

// sum_size (matches Coq: Definition sum_size)
pred sum_size {}

// pair_fst_offset (matches Coq: Definition pair_fst_offset)
pred pair_fst_offset[p: PairLayout] {
  some p
}

// pair_snd_offset (matches Coq: Definition pair_snd_offset)
pred pair_snd_offset[p: PairLayout] {
  some p
}

// sum_tag_valid (matches Coq: Definition sum_tag_valid)
pred sum_tag_valid[s: SumLayout] {
  some s
}

// wasm_eval_const (matches Coq: Lemma wasm_eval_const)
assert wasm_eval_const {
  #univ >= 0
}
check wasm_eval_const for 5

// wasm_eval_add (matches Coq: Lemma wasm_eval_add)
assert wasm_eval_add {
  #univ >= 0
}
check wasm_eval_add for 5

// wasm_eval_mul (matches Coq: Lemma wasm_eval_mul)
assert wasm_eval_mul {
  #univ >= 0
}
check wasm_eval_mul for 5

// wasm_001_const_preservation (matches Coq: Theorem wasm_001_const_preservation)
assert wasm_001_const_preservation {
  #univ >= 0
}
check wasm_001_const_preservation for 5

// wasm_002_ni_preservation (matches Coq: Theorem wasm_002_ni_preservation)
assert wasm_002_ni_preservation {
  #univ >= 0
}
check wasm_002_ni_preservation for 5

// wasm_002_memory_separation (matches Coq: Theorem wasm_002_memory_separation)
assert wasm_002_memory_separation {
  #univ >= 0
}
check wasm_002_memory_separation for 5

// wasm_003_effect_preservation (matches Coq: Theorem wasm_003_effect_preservation)
assert wasm_003_effect_preservation {
  #univ >= 0
}
check wasm_003_effect_preservation for 5

// wasm_003_io_self_safe (matches Coq: Theorem wasm_003_io_self_safe)
assert wasm_003_io_self_safe {
  #univ >= 0
}
check wasm_003_io_self_safe for 5

// wasm_004_int_type_preserved (matches Coq: Theorem wasm_004_int_type_preserved)
assert wasm_004_int_type_preserved {
  #univ >= 0
}
check wasm_004_int_type_preserved for 5

// wasm_004_add_type_preserved (matches Coq: Theorem wasm_004_add_type_preserved)
assert wasm_004_add_type_preserved {
  #univ >= 0
}
check wasm_004_add_type_preserved for 5

// wasm_004_bool_type_preserved (matches Coq: Theorem wasm_004_bool_type_preserved)
assert wasm_004_bool_type_preserved {
  #univ >= 0
}
check wasm_004_bool_type_preserved for 5

// wasm_005_disjoint_regions (matches Coq: Theorem wasm_005_disjoint_regions)
assert wasm_005_disjoint_regions {
  #univ >= 0
}
check wasm_005_disjoint_regions for 5

// wasm_005_public_cannot_access_secret (matches Coq: Theorem wasm_005_public_cannot_access_secret)
assert wasm_005_public_cannot_access_secret {
  #univ >= 0
}
check wasm_005_public_cannot_access_secret for 5

// wasm_006_string_const_produces_ptr (matches Coq: Theorem wasm_006_string_const_produces_ptr)
assert wasm_006_string_const_produces_ptr {
  #univ >= 0
}
check wasm_006_string_const_produces_ptr for 5

// wasm_006_string_ptr_is_i32 (matches Coq: Theorem wasm_006_string_ptr_is_i32)
assert wasm_006_string_ptr_is_i32 {
  #univ >= 0
}
check wasm_006_string_ptr_is_i32 for 5

// wasm_006_string_dedup (matches Coq: Theorem wasm_006_string_dedup)
assert wasm_006_string_dedup {
  #univ >= 0
}
check wasm_006_string_dedup for 5

// wasm_007_closure_layout (matches Coq: Theorem wasm_007_closure_layout)
assert wasm_007_closure_layout {
  #univ >= 0
}
check wasm_007_closure_layout for 5

// wasm_007_closure_no_overlap (matches Coq: Theorem wasm_007_closure_no_overlap)
assert wasm_007_closure_no_overlap {
  #univ >= 0
}
check wasm_007_closure_no_overlap for 5

// wasm_007_closure_func_idx_recoverable (matches Coq: Theorem wasm_007_closure_func_idx_recoverable)
assert wasm_007_closure_func_idx_recoverable {
  #univ >= 0
}
check wasm_007_closure_func_idx_recoverable for 5

// wasm_008_pair_offsets_disjoint (matches Coq: Theorem wasm_008_pair_offsets_disjoint)
assert wasm_008_pair_offsets_disjoint {
  #univ >= 0
}
check wasm_008_pair_offsets_disjoint for 5

// wasm_008_pair_fits_in_region (matches Coq: Theorem wasm_008_pair_fits_in_region)
assert wasm_008_pair_fits_in_region {
  #univ >= 0
}
check wasm_008_pair_fits_in_region for 5

// wasm_008_sum_tag_determines_branch (matches Coq: Theorem wasm_008_sum_tag_determines_branch)
assert wasm_008_sum_tag_determines_branch {
  #univ >= 0
}
check wasm_008_sum_tag_determines_branch for 5

// wasm_008_sum_fits_in_region (matches Coq: Theorem wasm_008_sum_fits_in_region)
assert wasm_008_sum_fits_in_region {
  #univ >= 0
}
check wasm_008_sum_fits_in_region for 5

// wasm_008_pairs_disjoint (matches Coq: Theorem wasm_008_pairs_disjoint)
assert wasm_008_pairs_disjoint {
  #univ >= 0
}
check wasm_008_pairs_disjoint for 5

// wasm_009_alloc_returns_current (matches Coq: Theorem wasm_009_alloc_returns_current)
assert wasm_009_alloc_returns_current {
  #univ >= 0
}
check wasm_009_alloc_returns_current for 5

// wasm_009_alloc_advances_ptr (matches Coq: Theorem wasm_009_alloc_advances_ptr)
assert wasm_009_alloc_advances_ptr {
  #univ >= 0
}
check wasm_009_alloc_advances_ptr for 5

// wasm_009_alloc_preserves_limit (matches Coq: Theorem wasm_009_alloc_preserves_limit)
assert wasm_009_alloc_preserves_limit {
  #univ >= 0
}
check wasm_009_alloc_preserves_limit for 5

// wasm_009_sequential_alloc_disjoint (matches Coq: Theorem wasm_009_sequential_alloc_disjoint)
assert wasm_009_sequential_alloc_disjoint {
  #univ >= 0
}
check wasm_009_sequential_alloc_disjoint for 5

// wasm_009_alloc_oom (matches Coq: Theorem wasm_009_alloc_oom)
assert wasm_009_alloc_oom {
  #univ >= 0
}
check wasm_009_alloc_oom for 5

// wasm_010_compile_ir_total (matches Coq: Theorem wasm_010_compile_ir_total)
assert wasm_010_compile_ir_total {
  #univ >= 0
}
check wasm_010_compile_ir_total for 5

// wasm_010_const_translates (matches Coq: Theorem wasm_010_const_translates)
assert wasm_010_const_translates {
  #univ >= 0
}
check wasm_010_const_translates for 5

// wasm_010_var_translates (matches Coq: Theorem wasm_010_var_translates)
assert wasm_010_var_translates {
  #univ >= 0
}
check wasm_010_var_translates for 5

// wasm_010_add_translates (matches Coq: Theorem wasm_010_add_translates)
assert wasm_010_add_translates {
  #univ >= 0
}
check wasm_010_add_translates for 5

// wasm_010_mul_translates (matches Coq: Theorem wasm_010_mul_translates)
assert wasm_010_mul_translates {
  #univ >= 0
}
check wasm_010_mul_translates for 5

// wasm_010_call_translates (matches Coq: Theorem wasm_010_call_translates)
assert wasm_010_call_translates {
  #univ >= 0
}
check wasm_010_call_translates for 5

// wasm_010_let_translates (matches Coq: Theorem wasm_010_let_translates)
assert wasm_010_let_translates {
  #univ >= 0
}
check wasm_010_let_translates for 5

// wasm_010_if_translates (matches Coq: Theorem wasm_010_if_translates)
assert wasm_010_if_translates {
  #univ >= 0
}
check wasm_010_if_translates for 5

// wasm_010_load_translates (matches Coq: Theorem wasm_010_load_translates)
assert wasm_010_load_translates {
  #univ >= 0
}
check wasm_010_load_translates for 5

// wasm_010_store_translates (matches Coq: Theorem wasm_010_store_translates)
assert wasm_010_store_translates {
  #univ >= 0
}
check wasm_010_store_translates for 5

// app_ne_nil_r (matches Coq: Lemma app_ne_nil_r)
assert app_ne_nil_r {
  #univ >= 0
}
check app_ne_nil_r for 5

// singleton_ne_nil (matches Coq: Lemma singleton_ne_nil)
assert singleton_ne_nil {
  #univ >= 0
}
check singleton_ne_nil for 5

// cons_ne_nil (matches Coq: Lemma cons_ne_nil)
assert cons_ne_nil {
  #univ >= 0
}
check cons_ne_nil for 5

// wasm_010_completeness (matches Coq: Theorem wasm_010_completeness)
assert wasm_010_completeness {
  #univ >= 0
}
check wasm_010_completeness for 5
