// Copyright (c) 2026 The RIINA Authors. All rights reserved.
// Auto-generated from 02_FORMAL/coq/domains/PhysicsSecurity.v (26 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/physics_security

open util/boolean

// SensorKind (matches Coq: Inductive SensorKind)
abstract sig SensorKind {}
one sig Temperature extends SensorKind {}
one sig Pressure extends SensorKind {}
one sig Accelerometer extends SensorKind {}
one sig Gyroscope extends SensorKind {}

// PhysState (matches Coq: Inductive PhysState)
abstract sig PhysState {}
one sig Idle extends PhysState {}
one sig Sensing extends PhysState {}
one sig Processing extends PhysState {}
one sig Actuating extends PhysState {}
one sig Error extends PhysState {}

// SensorReading (matches Coq: Record SensorReading)
sig SensorReading {
  sensor_kind: one SensorKind,
  reading_value: one Int // scaled integer value,
  reading_min: one Int // valid minimum,
  reading_max: one Int // valid maximum,
  timestamp: one Int // monotonic timestamp,
  sensor_id: one Int
}

// MeasurementSpec (matches Coq: Record MeasurementSpec)
sig MeasurementSpec {
  meas_tolerance: one Int // maximum allowed deviation,
  meas_samples: one Int // number of samples for averaging,
  meas_min_samples: one Int // minimum required samples
}

// TimingConstraint (matches Coq: Record TimingConstraint)
sig TimingConstraint {
  deadline: one Int // max allowed time,
  wcet: one Int // worst-case execution time,
  period: one Int // task period,
  jitter_bound: one Int // max jitter
}

// reading_in_bounds (matches Coq: Definition reading_in_bounds)
pred reading_in_bounds[r: SensorReading] {
  some r
}

// reading_valid (matches Coq: Definition reading_valid)
pred reading_valid[r: SensorReading] {
  some r
}

// spec_feasible (matches Coq: Definition spec_feasible)
pred spec_feasible[spec: MeasurementSpec] {
  some spec
}

// readings_avg (matches Coq: Definition readings_avg)
pred readings_avg {}

// all_within_tolerance (matches Coq: Definition all_within_tolerance)
pred all_within_tolerance {}

// timing_feasible (matches Coq: Definition timing_feasible)
pred timing_feasible[tc: TimingConstraint] {
  some tc
}

// timing_schedulable (matches Coq: Definition timing_schedulable)
pred timing_schedulable[tc: TimingConstraint] {
  some tc
}

// phys_transition (matches Coq: Definition phys_transition)
pred phys_transition[s: PhysState, sensor_ok: bool] {
  some s
}

// is_operational (matches Coq: Definition is_operational)
pred is_operational[s: PhysState] {
  some s
}

// reading_in_bounds_correct (matches Coq: Theorem reading_in_bounds_correct)
assert reading_in_bounds_correct {
  all c: SensorReading | some c.sensor_kind
}
check reading_in_bounds_correct for 5

// valid_reading_min_le_max (matches Coq: Theorem valid_reading_min_le_max)
assert valid_reading_min_le_max {
  all c: SensorReading | some c.sensor_kind
}
check valid_reading_min_le_max for 5

// reading_value_bounded (matches Coq: Theorem reading_value_bounded)
assert reading_value_bounded {
  all c: SensorReading | some c.sensor_kind
}
check reading_value_bounded for 5

// spec_feasible_correct (matches Coq: Theorem spec_feasible_correct)
assert spec_feasible_correct {
  all c: SensorReading | some c.sensor_kind
}
check spec_feasible_correct for 5

// spec_feasible_nonzero_samples (matches Coq: Theorem spec_feasible_nonzero_samples)
assert spec_feasible_nonzero_samples {
  all c: SensorReading | some c.sensor_kind
}
check spec_feasible_nonzero_samples for 5

// empty_readings_avg_zero (matches Coq: Theorem empty_readings_avg_zero)
assert empty_readings_avg_zero {
  all c: SensorReading | some c.sensor_kind
}
check empty_readings_avg_zero for 5

// timing_feasible_correct (matches Coq: Theorem timing_feasible_correct)
assert timing_feasible_correct {
  all c: SensorReading | some c.sensor_kind
}
check timing_feasible_correct for 5

// feasible_wcet_within_deadline (matches Coq: Theorem feasible_wcet_within_deadline)
assert feasible_wcet_within_deadline {
  all c: SensorReading | some c.sensor_kind
}
check feasible_wcet_within_deadline for 5

// feasible_deadline_within_period (matches Coq: Theorem feasible_deadline_within_period)
assert feasible_deadline_within_period {
  all c: SensorReading | some c.sensor_kind
}
check feasible_deadline_within_period for 5

// idle_always_transitions_to_sensing (matches Coq: Theorem idle_always_transitions_to_sensing)
assert idle_always_transitions_to_sensing {
  all c: SensorReading | some c.sensor_kind
}
check idle_always_transitions_to_sensing for 5

// sensing_error_on_failure (matches Coq: Theorem sensing_error_on_failure)
assert sensing_error_on_failure {
  all c: SensorReading | some c.sensor_kind
}
check sensing_error_on_failure for 5

// sensing_proceeds_on_success (matches Coq: Theorem sensing_proceeds_on_success)
assert sensing_proceeds_on_success {
  all c: SensorReading | some c.sensor_kind
}
check sensing_proceeds_on_success for 5

// error_recovers_to_idle (matches Coq: Theorem error_recovers_to_idle)
assert error_recovers_to_idle {
  all c: SensorReading | some c.sensor_kind
}
check error_recovers_to_idle for 5

// full_cycle_returns_to_idle (matches Coq: Theorem full_cycle_returns_to_idle)
assert full_cycle_returns_to_idle {
  all c: SensorReading | some c.sensor_kind
}
check full_cycle_returns_to_idle for 5

// error_state_not_operational (matches Coq: Theorem error_state_not_operational)
assert error_state_not_operational {
  all c: SensorReading | some c.sensor_kind
}
check error_state_not_operational for 5

// idle_is_operational (matches Coq: Theorem idle_is_operational)
assert idle_is_operational {
  all c: SensorReading | some c.sensor_kind
}
check idle_is_operational for 5

// reading_bounded_values (matches Coq: Theorem reading_bounded_values)
assert reading_bounded_values {
  all c: SensorReading | some c.sensor_kind
}
check reading_bounded_values for 5

// sensing_transitions_depend_on_input (matches Coq: Theorem sensing_transitions_depend_on_input)
assert sensing_transitions_depend_on_input {
  all c: SensorReading | some c.sensor_kind
}
check sensing_transitions_depend_on_input for 5

// actuating_transitions_to_idle (matches Coq: Theorem actuating_transitions_to_idle)
assert actuating_transitions_to_idle {
  all c: SensorReading | some c.sensor_kind
}
check actuating_transitions_to_idle for 5

// processing_transitions_to_actuating (matches Coq: Theorem processing_transitions_to_actuating)
assert processing_transitions_to_actuating {
  all c: SensorReading | some c.sensor_kind
}
check processing_transitions_to_actuating for 5

// processing_is_operational (matches Coq: Theorem processing_is_operational)
assert processing_is_operational {
  all c: SensorReading | some c.sensor_kind
}
check processing_is_operational for 5

// actuating_is_operational (matches Coq: Theorem actuating_is_operational)
assert actuating_is_operational {
  all c: SensorReading | some c.sensor_kind
}
check actuating_is_operational for 5

// sensing_is_operational (matches Coq: Theorem sensing_is_operational)
assert sensing_is_operational {
  all c: SensorReading | some c.sensor_kind
}
check sensing_is_operational for 5

// error_recovery_cycle (matches Coq: Theorem error_recovery_cycle)
assert error_recovery_cycle {
  all c: SensorReading | some c.sensor_kind
}
check error_recovery_cycle for 5

// reading_bounds_decomposition (matches Coq: Theorem reading_bounds_decomposition)
assert reading_bounds_decomposition {
  all c: SensorReading | some c.sensor_kind
}
check reading_bounds_decomposition for 5

// timing_feasible_decomposition (matches Coq: Theorem timing_feasible_decomposition)
assert timing_feasible_decomposition {
  all c: SensorReading | some c.sensor_kind
}
check timing_feasible_decomposition for 5
