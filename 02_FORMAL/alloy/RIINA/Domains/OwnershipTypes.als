// SPDX-License-Identifier: MPL-2.0
// Copyright (c) 2026 The RIINA Authors.
// Auto-generated from 02_FORMAL/coq/domains/OwnershipTypes.v (20 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/ownership_types

open util/boolean

// OwnState (matches Coq: Inductive OwnState)
abstract sig OwnState {}
one sig Owned extends OwnState {} // Exclusively owned
one sig Moved extends OwnState {} // Ownership transferred
one sig Borrowed extends OwnState {} // Immutably borrowed
one sig MutBorrowed extends OwnState {} // Mutably borrowed
one sig Dropped extends OwnState {} // Deallocated

// RefCellState (matches Coq: Inductive RefCellState)
abstract sig RefCellState {}
one sig RCUnborrowed extends RefCellState {}
one sig RCSharedBorrow extends RefCellState {} // count of shared borrows
one sig RCMutBorrow extends RefCellState {}

// OwnedVar (matches Coq: Record OwnedVar)
sig OwnedVar {
  ov_id: one Int,
  ov_state: one OwnState,
  ov_lifetime: one Lifetime // Scope lifetime,
  ov_is_copy: one Bool // Copy type?
}

// Borrow (matches Coq: Record Borrow)
sig Borrow {
  br_source: one Int // Source variable ID,
  br_target: one Int // Borrow variable ID,
  br_mutable: one Bool // Mutable borrow?,
  br_lifetime: one Lifetime // Borrow lifetime
}

// OwnCtx (matches Coq: Record OwnCtx)
sig OwnCtx {
  oc_vars: one list,
  oc_borrows: one list,
  oc_current_lifetime: one Lifetime
}

// RefCell (matches Coq: Record RefCell)
sig RefCell {
  rc_id: one Int,
  rc_state: one RefCellState,
  rc_lifetime: one Lifetime
}

// BoxAlloc (matches Coq: Record BoxAlloc)
sig BoxAlloc {
  box_id: one Int,
  box_allocated: one Bool,
  box_dropped: one Bool
}

// lifetime_outlives (matches Coq: Definition lifetime_outlives)
pred lifetime_outlives {}

// is_usable (matches Coq: Definition is_usable)
pred is_usable[v: OwnedVar] {
  some v
}

// can_mut_borrow (matches Coq: Definition can_mut_borrow)
pred can_mut_borrow[ctx: OwnCtx, id: nat] {
  some ctx
}

// can_shared_borrow (matches Coq: Definition can_shared_borrow)
pred can_shared_borrow[ctx: OwnCtx, id: nat] {
  some ctx
}

// count_borrows (matches Coq: Definition count_borrows)
pred count_borrows[ctx: OwnCtx, id: nat] {
  some ctx
}

// count_mut_borrows (matches Coq: Definition count_mut_borrows)
pred count_mut_borrows[ctx: OwnCtx, id: nat] {
  some ctx
}

// borrow_lifetime_valid (matches Coq: Definition borrow_lifetime_valid)
pred borrow_lifetime_valid[ctx: OwnCtx, b: Borrow] {
  some ctx
}

// is_moved (matches Coq: Definition is_moved)
pred is_moved[v: OwnedVar] {
  some v
}

// is_dropped (matches Coq: Definition is_dropped)
pred is_dropped[v: OwnedVar] {
  some v
}

// box_new (matches Coq: Definition box_new)
pred box_new[id: nat] {
  some id
}

// well_formed_ctx (matches Coq: Definition well_formed_ctx)
pred well_formed_ctx[ctx: OwnCtx] {
  some ctx
}

// no_active_borrows (matches Coq: Definition no_active_borrows)
pred no_active_borrows[ctx: OwnCtx, id: nat] {
  some ctx
}

// memory_safe (matches Coq: Definition memory_safe)
pred memory_safe[ctx: OwnCtx] {
  some ctx
}

// existsb_false_forall (matches Coq: Lemma existsb_false_forall)
assert existsb_false_forall {
  all c: OwnedVar | some c.ov_id
}
check existsb_false_forall for 5

// find_var_map_moved (matches Coq: Lemma find_var_map_moved)
assert find_var_map_moved {
  all c: OwnedVar | some c.ov_id
}
check find_var_map_moved for 5

// MEM_001_01 (matches Coq: Theorem MEM_001_01)
assert MEM_001_01 {
  all c: OwnedVar | some c.ov_id
}
check MEM_001_01 for 5

// MEM_001_02 (matches Coq: Theorem MEM_001_02)
assert MEM_001_02 {
  all c: OwnedVar | some c.ov_id
}
check MEM_001_02 for 5

// MEM_001_03 (matches Coq: Theorem MEM_001_03)
assert MEM_001_03 {
  all c: OwnedVar | some c.ov_id
}
check MEM_001_03 for 5

// filter_all_false_empty (matches Coq: Lemma filter_all_false_empty)
assert filter_all_false_empty {
  all c: OwnedVar | some c.ov_id
}
check filter_all_false_empty for 5

// MEM_001_04 (matches Coq: Theorem MEM_001_04)
assert MEM_001_04 {
  all c: OwnedVar | some c.ov_id
}
check MEM_001_04 for 5

// MEM_001_05 (matches Coq: Theorem MEM_001_05)
assert MEM_001_05 {
  all c: OwnedVar | some c.ov_id
}
check MEM_001_05 for 5

// MEM_001_06 (matches Coq: Theorem MEM_001_06)
assert MEM_001_06 {
  all c: OwnedVar | some c.ov_id
}
check MEM_001_06 for 5

// MEM_001_07 (matches Coq: Theorem MEM_001_07)
assert MEM_001_07 {
  all c: OwnedVar | some c.ov_id
}
check MEM_001_07 for 5

// MEM_001_08 (matches Coq: Theorem MEM_001_08)
assert MEM_001_08 {
  all c: OwnedVar | some c.ov_id
}
check MEM_001_08 for 5

// MEM_001_09 (matches Coq: Theorem MEM_001_09)
assert MEM_001_09 {
  all c: OwnedVar | some c.ov_id
}
check MEM_001_09 for 5

// find_var_map_dropped (matches Coq: Lemma find_var_map_dropped)
assert find_var_map_dropped {
  all c: OwnedVar | some c.ov_id
}
check find_var_map_dropped for 5

// MEM_001_10 (matches Coq: Theorem MEM_001_10)
assert MEM_001_10 {
  all c: OwnedVar | some c.ov_id
}
check MEM_001_10 for 5

// MEM_001_11 (matches Coq: Theorem MEM_001_11)
assert MEM_001_11 {
  all c: OwnedVar | some c.ov_id
}
check MEM_001_11 for 5

// MEM_001_12 (matches Coq: Theorem MEM_001_12)
assert MEM_001_12 {
  all c: OwnedVar | some c.ov_id
}
check MEM_001_12 for 5

// MEM_001_13 (matches Coq: Theorem MEM_001_13)
assert MEM_001_13 {
  all c: OwnedVar | some c.ov_id
}
check MEM_001_13 for 5

// MEM_001_14 (matches Coq: Theorem MEM_001_14)
assert MEM_001_14 {
  all c: OwnedVar | some c.ov_id
}
check MEM_001_14 for 5

// MEM_001_15 (matches Coq: Theorem MEM_001_15)
assert MEM_001_15 {
  all c: OwnedVar | some c.ov_id
}
check MEM_001_15 for 5

// lifetime_outlives_refl (matches Coq: Theorem lifetime_outlives_refl)
assert lifetime_outlives_refl {
  all c: OwnedVar | some c.ov_id
}
check lifetime_outlives_refl for 5
