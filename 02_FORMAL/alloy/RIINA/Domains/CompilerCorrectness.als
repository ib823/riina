// SPDX-License-Identifier: MPL-2.0
// Copyright (c) 2026 The RIINA Authors.
// Auto-generated from 02_FORMAL/coq/domains/CompilerCorrectness.v (78 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/compiler_correctness

open util/boolean

// ir_ty (matches Coq: Inductive ir_ty)
abstract sig ir_ty {}
one sig IR_TUnit extends ir_ty {}
one sig IR_TBool extends ir_ty {}
one sig IR_TInt extends ir_ty {}
one sig IR_TFn extends ir_ty {} // T1 -> T2
one sig IR_TProd extends ir_ty {} // T1 * T2
one sig IR_TSum extends ir_ty {}
one sig IR_Unit extends ir_ty {}
one sig IR_Bool extends ir_ty {}
one sig IR_Int extends ir_ty {}
one sig IR_Pair extends ir_ty {}
one sig IR_Fst extends ir_ty {}
one sig IR_Snd extends ir_ty {}
one sig IR_Inl extends ir_ty {}
one sig IR_Inr extends ir_ty {}
one sig IR_If extends ir_ty {}

// src_ty (matches Coq: Inductive src_ty)
abstract sig src_ty {}
one sig Src_TUnit extends src_ty {}
one sig Src_TBool extends src_ty {}
one sig Src_TInt extends src_ty {}
one sig Src_TProd extends src_ty {}
one sig Src_TSum extends src_ty {}
one sig Src_TFn extends src_ty {}

// src_expr (matches Coq: Inductive src_expr)
abstract sig src_expr {}
one sig Src_Unit extends src_expr {}
one sig Src_Bool extends src_expr {}
one sig Src_Int extends src_expr {}
one sig Src_Pair extends src_expr {}
one sig Src_Fst extends src_expr {}
one sig Src_Snd extends src_expr {}
one sig Src_Inl extends src_expr {}
one sig Src_Inr extends src_expr {}
one sig Src_If extends src_expr {}

// ParsingPhase (matches Coq: Record ParsingPhase)
sig ParsingPhase {
  pp_syntax_correct: one Bool,
  pp_ast_well_formed: one Bool,
  pp_error_recovery: one Bool
}

// TypeCheckPhase (matches Coq: Record TypeCheckPhase)
sig TypeCheckPhase {
  tc_type_soundness: one Bool,
  tc_inference_complete: one Bool,
  tc_constraint_solving: one Bool
}

// OptimizationPhase (matches Coq: Record OptimizationPhase)
sig OptimizationPhase {
  op_semantics_preserved: one Bool,
  op_termination_preserved: one Bool,
  op_memory_safety_preserved: one Bool
}

// CodeGenPhase (matches Coq: Record CodeGenPhase)
sig CodeGenPhase {
  cg_instruction_correct: one Bool,
  cg_register_allocation: one Bool,
  cg_calling_convention: one Bool,
  cg_stack_layout: one Bool
}

// CompilerConfig (matches Coq: Record CompilerConfig)
sig CompilerConfig {
  cc_parsing: one ParsingPhase,
  cc_typecheck: one TypeCheckPhase,
  cc_optimization: one OptimizationPhase,
  cc_codegen: one CodeGenPhase
}

// parsing_correct (matches Coq: Definition parsing_correct)
pred parsing_correct[p: ParsingPhase] {
  some p
}

// typecheck_sound (matches Coq: Definition typecheck_sound)
pred typecheck_sound[t: TypeCheckPhase] {
  some t
}

// optimization_safe (matches Coq: Definition optimization_safe)
pred optimization_safe[o: OptimizationPhase] {
  some o
}

// codegen_correct (matches Coq: Definition codegen_correct)
pred codegen_correct[c: CodeGenPhase] {
  some c
}

// compiler_verified (matches Coq: Definition compiler_verified)
pred compiler_verified[c: CompilerConfig] {
  some c
}

// riina_parsing (matches Coq: Definition riina_parsing)
pred riina_parsing {}

// riina_typecheck (matches Coq: Definition riina_typecheck)
pred riina_typecheck {}

// riina_optim (matches Coq: Definition riina_optim)
pred riina_optim {}

// riina_codegen (matches Coq: Definition riina_codegen)
pred riina_codegen {}

// riina_compiler (matches Coq: Definition riina_compiler)
pred riina_compiler {}

// ir_equiv (matches Coq: Definition ir_equiv)
pred ir_equiv {}

// src_ir_equiv (matches Coq: Definition src_ir_equiv)
pred src_ir_equiv[e_src: src_expr, e_ir: ir_expr] {
  some e_src
}

// andb_true_iff (matches Coq: Lemma andb_true_iff)
assert andb_true_iff {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check andb_true_iff for 5

// CC_001 (matches Coq: Theorem CC_001)
assert CC_001 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_001 for 5

// CC_002 (matches Coq: Theorem CC_002)
assert CC_002 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_002 for 5

// CC_003 (matches Coq: Theorem CC_003)
assert CC_003 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_003 for 5

// CC_004 (matches Coq: Theorem CC_004)
assert CC_004 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_004 for 5

// CC_005 (matches Coq: Theorem CC_005)
assert CC_005 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_005 for 5

// CC_006 (matches Coq: Theorem CC_006)
assert CC_006 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_006 for 5

// CC_007 (matches Coq: Theorem CC_007)
assert CC_007 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_007 for 5

// CC_008 (matches Coq: Theorem CC_008)
assert CC_008 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_008 for 5

// CC_009 (matches Coq: Theorem CC_009)
assert CC_009 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_009 for 5

// CC_010 (matches Coq: Theorem CC_010)
assert CC_010 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_010 for 5

// CC_011 (matches Coq: Theorem CC_011)
assert CC_011 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_011 for 5

// CC_012 (matches Coq: Theorem CC_012)
assert CC_012 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_012 for 5

// CC_013 (matches Coq: Theorem CC_013)
assert CC_013 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_013 for 5

// CC_014 (matches Coq: Theorem CC_014)
assert CC_014 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_014 for 5

// CC_015 (matches Coq: Theorem CC_015)
assert CC_015 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_015 for 5

// CC_016 (matches Coq: Theorem CC_016)
assert CC_016 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_016 for 5

// CC_017 (matches Coq: Theorem CC_017)
assert CC_017 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_017 for 5

// CC_018 (matches Coq: Theorem CC_018)
assert CC_018 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_018 for 5

// CC_019 (matches Coq: Theorem CC_019)
assert CC_019 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_019 for 5

// CC_020 (matches Coq: Theorem CC_020)
assert CC_020 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_020 for 5

// CC_021 (matches Coq: Theorem CC_021)
assert CC_021 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_021 for 5

// CC_022 (matches Coq: Theorem CC_022)
assert CC_022 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_022 for 5

// CC_023 (matches Coq: Theorem CC_023)
assert CC_023 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_023 for 5

// CC_024 (matches Coq: Theorem CC_024)
assert CC_024 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_024 for 5

// CC_025 (matches Coq: Theorem CC_025)
assert CC_025 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_025 for 5

// CC_026 (matches Coq: Theorem CC_026)
assert CC_026 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_026 for 5

// CC_027 (matches Coq: Theorem CC_027)
assert CC_027 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_027 for 5

// CC_028 (matches Coq: Theorem CC_028)
assert CC_028 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_028 for 5

// CC_029 (matches Coq: Theorem CC_029)
assert CC_029 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_029 for 5

// CC_030_complete (matches Coq: Theorem CC_030_complete)
assert CC_030_complete {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check CC_030_complete for 5

// ir_value_not_step (matches Coq: Lemma ir_value_not_step)
assert ir_value_not_step {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check ir_value_not_step for 5

// ir_preservation (matches Coq: Theorem ir_preservation)
assert ir_preservation {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check ir_preservation for 5

// ir_multi_preservation (matches Coq: Theorem ir_multi_preservation)
assert ir_multi_preservation {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check ir_multi_preservation for 5

// ir_pair_value_not_step (matches Coq: Lemma ir_pair_value_not_step)
assert ir_pair_value_not_step {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check ir_pair_value_not_step for 5

// ir_bool_not_step (matches Coq: Lemma ir_bool_not_step)
assert ir_bool_not_step {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check ir_bool_not_step for 5

// ir_step_deterministic (matches Coq: Theorem ir_step_deterministic)
assert ir_step_deterministic {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check ir_step_deterministic for 5

// ir_progress (matches Coq: Theorem ir_progress)
assert ir_progress {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check ir_progress for 5

// ir_equiv_refl (matches Coq: Theorem ir_equiv_refl)
assert ir_equiv_refl {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check ir_equiv_refl for 5

// ir_equiv_sym (matches Coq: Theorem ir_equiv_sym)
assert ir_equiv_sym {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check ir_equiv_sym for 5

// ir_equiv_trans (matches Coq: Theorem ir_equiv_trans)
assert ir_equiv_trans {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check ir_equiv_trans for 5

// ir_multi_trans (matches Coq: Lemma ir_multi_trans)
assert ir_multi_trans {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check ir_multi_trans for 5

// ir_multi_pair_cong1 (matches Coq: Lemma ir_multi_pair_cong1)
assert ir_multi_pair_cong1 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check ir_multi_pair_cong1 for 5

// ir_multi_pair_cong2 (matches Coq: Lemma ir_multi_pair_cong2)
assert ir_multi_pair_cong2 {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check ir_multi_pair_cong2 for 5

// opt_if_true_sound (matches Coq: Theorem opt_if_true_sound)
assert opt_if_true_sound {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check opt_if_true_sound for 5

// opt_if_false_sound (matches Coq: Theorem opt_if_false_sound)
assert opt_if_false_sound {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check opt_if_false_sound for 5

// opt_fst_pair_sound (matches Coq: Theorem opt_fst_pair_sound)
assert opt_fst_pair_sound {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check opt_fst_pair_sound for 5

// opt_snd_pair_sound (matches Coq: Theorem opt_snd_pair_sound)
assert opt_snd_pair_sound {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check opt_snd_pair_sound for 5

// ir_value_normal (matches Coq: Theorem ir_value_normal)
assert ir_value_normal {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check ir_value_normal for 5

// ir_value_reduces_self (matches Coq: Theorem ir_value_reduces_self)
assert ir_value_reduces_self {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check ir_value_reduces_self for 5

// equiv_preserves_typing (matches Coq: Theorem equiv_preserves_typing)
assert equiv_preserves_typing {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check equiv_preserves_typing for 5

// src_value_not_step (matches Coq: Lemma src_value_not_step)
assert src_value_not_step {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check src_value_not_step for 5

// src_step_deterministic (matches Coq: Theorem src_step_deterministic)
assert src_step_deterministic {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check src_step_deterministic for 5

// src_preservation (matches Coq: Theorem src_preservation)
assert src_preservation {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check src_preservation for 5

// src_progress (matches Coq: Theorem src_progress)
assert src_progress {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check src_progress for 5

// compile_preserves_value (matches Coq: Theorem compile_preserves_value)
assert compile_preserves_value {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check compile_preserves_value for 5

// compile_preserves_typing (matches Coq: Theorem compile_preserves_typing)
assert compile_preserves_typing {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check compile_preserves_typing for 5

// compile_forward_simulation (matches Coq: Theorem compile_forward_simulation)
assert compile_forward_simulation {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check compile_forward_simulation for 5

// compile_forward_multi_simulation (matches Coq: Theorem compile_forward_multi_simulation)
assert compile_forward_multi_simulation {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check compile_forward_multi_simulation for 5

// compile_value_inv (matches Coq: Lemma compile_value_inv)
assert compile_value_inv {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check compile_value_inv for 5

// compile_backward_simulation (matches Coq: Theorem compile_backward_simulation)
assert compile_backward_simulation {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check compile_backward_simulation for 5

// compile_establishes_equiv (matches Coq: Theorem compile_establishes_equiv)
assert compile_establishes_equiv {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check compile_establishes_equiv for 5

// equiv_preserved_forward (matches Coq: Theorem equiv_preserved_forward)
assert equiv_preserved_forward {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check equiv_preserved_forward for 5

// compile_terminates_equivalently (matches Coq: Theorem compile_terminates_equivalently)
assert compile_terminates_equivalently {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check compile_terminates_equivalently for 5

// compile_type_safety (matches Coq: Theorem compile_type_safety)
assert compile_type_safety {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check compile_type_safety for 5

// opt_dead_code_if_true (matches Coq: Theorem opt_dead_code_if_true)
assert opt_dead_code_if_true {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check opt_dead_code_if_true for 5

// opt_dead_code_if_false (matches Coq: Theorem opt_dead_code_if_false)
assert opt_dead_code_if_false {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check opt_dead_code_if_false for 5

// opt_fst_pair_typed (matches Coq: Theorem opt_fst_pair_typed)
assert opt_fst_pair_typed {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check opt_fst_pair_typed for 5

// opt_snd_pair_typed (matches Coq: Theorem opt_snd_pair_typed)
assert opt_snd_pair_typed {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check opt_snd_pair_typed for 5

// const_prop_bool (matches Coq: Theorem const_prop_bool)
assert const_prop_bool {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check const_prop_bool for 5

// const_prop_int (matches Coq: Theorem const_prop_int)
assert const_prop_int {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check const_prop_int for 5

// const_prop_unit (matches Coq: Theorem const_prop_unit)
assert const_prop_unit {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check const_prop_unit for 5

// parsing_correct_prop (matches Coq: Theorem parsing_correct_prop)
assert parsing_correct_prop {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check parsing_correct_prop for 5

// optimization_relation_reflexive (matches Coq: Theorem optimization_relation_reflexive)
assert optimization_relation_reflexive {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check optimization_relation_reflexive for 5

// optimization_relation_symmetric (matches Coq: Theorem optimization_relation_symmetric)
assert optimization_relation_symmetric {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check optimization_relation_symmetric for 5

// optimization_relation_transitive (matches Coq: Theorem optimization_relation_transitive)
assert optimization_relation_transitive {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check optimization_relation_transitive for 5

// full_pipeline_correctness (matches Coq: Theorem full_pipeline_correctness)
assert full_pipeline_correctness {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check full_pipeline_correctness for 5

// full_pipeline_termination (matches Coq: Theorem full_pipeline_termination)
assert full_pipeline_termination {
  all c: ParsingPhase | some c.pp_syntax_correct
}
check full_pipeline_termination for 5
