// SPDX-License-Identifier: MPL-2.0
// Copyright (c) 2026 The RIINA Authors.
// Auto-generated from 02_FORMAL/coq/domains/DELTA001_VerifiedDistribution.v (32 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/delta001__verified_distribution

open util/boolean

// Role (matches Coq: Inductive Role)
abstract sig Role {}
one sig Follower extends Role {}
one sig Candidate extends Role {}
one sig Leader extends Role {}

// BFTPhase (matches Coq: Inductive BFTPhase)
abstract sig BFTPhase {}
one sig PrePrepare extends BFTPhase {}
one sig Prepare extends BFTPhase {}
one sig Commit extends BFTPhase {}
one sig Reply extends BFTPhase {}

// LogEntry (matches Coq: Record LogEntry)
sig LogEntry {
  entry_term: one Term,
  entry_index: one Int,
  entry_command: one Int // abstract command
}

// RaftNode (matches Coq: Record RaftNode)
sig RaftNode {
  node_id: one NodeId,
  node_term: one Term,
  node_role: one Role,
  node_log: one list,
  node_voted_for: one option,
  node_commit_index: one Int
}

// RaftCluster (matches Coq: Record RaftCluster)
sig RaftCluster {
  cluster_nodes: one list,
  cluster_size: one Int
}

// BFTMessage (matches Coq: Record BFTMessage)
sig BFTMessage {
  bft_phase: one BFTPhase,
  bft_view: one Int,
  bft_seq: one Int,
  bft_digest: one Int,
  bft_sender: one NodeId
}

// BFTState (matches Coq: Record BFTState)
sig BFTState {
  bft_n: one Int // total nodes,
  bft_f: one Int // max faulty,
  bft_correct: one list,
  bft_faulty: one list
}

// HashRing (matches Coq: Record HashRing)
sig HashRing {
  ring_nodes: one list,
  ring_size: one Int // ring modulus
}

// is_quorum (matches Coq: Definition is_quorum)
pred is_quorum[votes: nat, total: nat] {
  some votes
}

// voted_for_in_term (matches Coq: Definition voted_for_in_term)
pred voted_for_in_term[node: RaftNode, candidate: NodeId, term: Term] {
  some node
}

// count_votes (matches Coq: Definition count_votes)
pred count_votes[candidate: NodeId, term: Term] {
  some candidate
}

// logs_match_at (matches Coq: Definition logs_match_at)
pred logs_match_at[idx: nat] {
  some idx
}

// entry_committed (matches Coq: Definition entry_committed)
pred entry_committed[cluster: RaftCluster, idx: nat] {
  some cluster
}

// bft_quorum (matches Coq: Definition bft_quorum)
pred bft_quorum[state: BFTState] {
  some state
}

// bft_valid (matches Coq: Definition bft_valid)
pred bft_valid[state: BFTState] {
  some state
}

// gc_increment (matches Coq: Definition gc_increment)
pred gc_increment[gc: GCounter, node: nat] {
  some gc
}

// gc_value (matches Coq: Definition gc_value)
pred gc_value[gc: GCounter] {
  some gc
}

// gc_merge (matches Coq: Definition gc_merge)
pred gc_merge {}

// gs_add (matches Coq: Definition gs_add)
pred gs_add[s: GSet, v: nat] {
  some s
}

// gs_merge (matches Coq: Definition gs_merge)
pred gs_merge {}

// gs_member (matches Coq: Definition gs_member)
pred gs_member[s: GSet, v: nat] {
  some s
}

// ring_add_node (matches Coq: Definition ring_add_node)
pred ring_add_node[ring: HashRing, pos: nat, node: NodeId] {
  some ring
}

// ring_remove_node (matches Coq: Definition ring_remove_node)
pred ring_remove_node[ring: HashRing, node: NodeId] {
  some ring
}

// DELTA_001_01_quorum_intersection (matches Coq: Theorem DELTA_001_01_quorum_intersection)
assert DELTA_001_01_quorum_intersection {
  all c: LogEntry | some c.entry_term
}
check DELTA_001_01_quorum_intersection for 5

// DELTA_001_02_single_vote_per_term (matches Coq: Theorem DELTA_001_02_single_vote_per_term)
assert DELTA_001_02_single_vote_per_term {
  all c: LogEntry | some c.entry_term
}
check DELTA_001_02_single_vote_per_term for 5

// DELTA_001_03_log_matching_reflexive (matches Coq: Theorem DELTA_001_03_log_matching_reflexive)
assert DELTA_001_03_log_matching_reflexive {
  all c: LogEntry | some c.entry_term
}
check DELTA_001_03_log_matching_reflexive for 5

// DELTA_001_04_committed_requires_quorum (matches Coq: Theorem DELTA_001_04_committed_requires_quorum)
assert DELTA_001_04_committed_requires_quorum {
  all c: LogEntry | some c.entry_term
}
check DELTA_001_04_committed_requires_quorum for 5

// DELTA_001_05_empty_log_no_commit (matches Coq: Theorem DELTA_001_05_empty_log_no_commit)
assert DELTA_001_05_empty_log_no_commit {
  all c: LogEntry | some c.entry_term
}
check DELTA_001_05_empty_log_no_commit for 5

// DELTA_001_06_leader_append_only (matches Coq: Theorem DELTA_001_06_leader_append_only)
assert DELTA_001_06_leader_append_only {
  all c: LogEntry | some c.entry_term
}
check DELTA_001_06_leader_append_only for 5

// DELTA_001_07_term_monotonic (matches Coq: Theorem DELTA_001_07_term_monotonic)
assert DELTA_001_07_term_monotonic {
  all c: LogEntry | some c.entry_term
}
check DELTA_001_07_term_monotonic for 5

// DELTA_001_08_entry_at_deterministic (matches Coq: Theorem DELTA_001_08_entry_at_deterministic)
assert DELTA_001_08_entry_at_deterministic {
  all c: LogEntry | some c.entry_term
}
check DELTA_001_08_entry_at_deterministic for 5

// DELTA_001_09_log_prefix_match (matches Coq: Theorem DELTA_001_09_log_prefix_match)
assert DELTA_001_09_log_prefix_match {
  all c: LogEntry | some c.entry_term
}
check DELTA_001_09_log_prefix_match for 5

// DELTA_001_10_quorum_nonempty (matches Coq: Theorem DELTA_001_10_quorum_nonempty)
assert DELTA_001_10_quorum_nonempty {
  all c: LogEntry | some c.entry_term
}
check DELTA_001_10_quorum_nonempty for 5

// DELTA_002_01_bft_bound (matches Coq: Theorem DELTA_002_01_bft_bound)
assert DELTA_002_01_bft_bound {
  all c: LogEntry | some c.entry_term
}
check DELTA_002_01_bft_bound for 5

// DELTA_002_02_bft_quorum_sufficient (matches Coq: Theorem DELTA_002_02_bft_quorum_sufficient)
assert DELTA_002_02_bft_quorum_sufficient {
  all c: LogEntry | some c.entry_term
}
check DELTA_002_02_bft_quorum_sufficient for 5

// DELTA_002_03_bft_two_quorums_overlap (matches Coq: Theorem DELTA_002_03_bft_two_quorums_overlap)
assert DELTA_002_03_bft_two_quorums_overlap {
  all c: LogEntry | some c.entry_term
}
check DELTA_002_03_bft_two_quorums_overlap for 5

// DELTA_002_04_correct_majority (matches Coq: Theorem DELTA_002_04_correct_majority)
assert DELTA_002_04_correct_majority {
  all c: LogEntry | some c.entry_term
}
check DELTA_002_04_correct_majority for 5

// DELTA_002_05_bft_f_zero (matches Coq: Theorem DELTA_002_05_bft_f_zero)
assert DELTA_002_05_bft_f_zero {
  all c: LogEntry | some c.entry_term
}
check DELTA_002_05_bft_f_zero for 5

// DELTA_002_06_bft_phases_ordered (matches Coq: Theorem DELTA_002_06_bft_phases_ordered)
assert DELTA_002_06_bft_phases_ordered {
  all c: LogEntry | some c.entry_term
}
check DELTA_002_06_bft_phases_ordered for 5

// DELTA_003_01_gc_merge_comm (matches Coq: Theorem DELTA_003_01_gc_merge_comm)
assert DELTA_003_01_gc_merge_comm {
  all c: LogEntry | some c.entry_term
}
check DELTA_003_01_gc_merge_comm for 5

// DELTA_003_02_gc_merge_assoc (matches Coq: Theorem DELTA_003_02_gc_merge_assoc)
assert DELTA_003_02_gc_merge_assoc {
  all c: LogEntry | some c.entry_term
}
check DELTA_003_02_gc_merge_assoc for 5

// DELTA_003_03_gc_merge_idempotent (matches Coq: Theorem DELTA_003_03_gc_merge_idempotent)
assert DELTA_003_03_gc_merge_idempotent {
  all c: LogEntry | some c.entry_term
}
check DELTA_003_03_gc_merge_idempotent for 5

// DELTA_003_04_gc_value_nonneg (matches Coq: Theorem DELTA_003_04_gc_value_nonneg)
assert DELTA_003_04_gc_value_nonneg {
  all c: LogEntry | some c.entry_term
}
check DELTA_003_04_gc_value_nonneg for 5

// fold_left_add_mono (matches Coq: Lemma fold_left_add_mono)
assert fold_left_add_mono {
  all c: LogEntry | some c.entry_term
}
check fold_left_add_mono for 5

// DELTA_003_05_gc_merge_monotone (matches Coq: Theorem DELTA_003_05_gc_merge_monotone)
assert DELTA_003_05_gc_merge_monotone {
  all c: LogEntry | some c.entry_term
}
check DELTA_003_05_gc_merge_monotone for 5

// DELTA_003_06_gs_add_member (matches Coq: Theorem DELTA_003_06_gs_add_member)
assert DELTA_003_06_gs_add_member {
  all c: LogEntry | some c.entry_term
}
check DELTA_003_06_gs_add_member for 5

// DELTA_003_07_gs_add_preserves (matches Coq: Theorem DELTA_003_07_gs_add_preserves)
assert DELTA_003_07_gs_add_preserves {
  all c: LogEntry | some c.entry_term
}
check DELTA_003_07_gs_add_preserves for 5

// DELTA_003_08_gs_merge_contains_left (matches Coq: Theorem DELTA_003_08_gs_merge_contains_left)
assert DELTA_003_08_gs_merge_contains_left {
  all c: LogEntry | some c.entry_term
}
check DELTA_003_08_gs_merge_contains_left for 5

// DELTA_003_09_gs_add_idempotent (matches Coq: Theorem DELTA_003_09_gs_add_idempotent)
assert DELTA_003_09_gs_add_idempotent {
  all c: LogEntry | some c.entry_term
}
check DELTA_003_09_gs_add_idempotent for 5

// DELTA_003_10_gc_empty_zero (matches Coq: Theorem DELTA_003_10_gc_empty_zero)
assert DELTA_003_10_gc_empty_zero {
  all c: LogEntry | some c.entry_term
}
check DELTA_003_10_gc_empty_zero for 5

// DELTA_004_01_ring_add_increases (matches Coq: Theorem DELTA_004_01_ring_add_increases)
assert DELTA_004_01_ring_add_increases {
  all c: LogEntry | some c.entry_term
}
check DELTA_004_01_ring_add_increases for 5

// DELTA_004_02_ring_remove_decreases (matches Coq: Theorem DELTA_004_02_ring_remove_decreases)
assert DELTA_004_02_ring_remove_decreases {
  all c: LogEntry | some c.entry_term
}
check DELTA_004_02_ring_remove_decreases for 5

// DELTA_004_03_ring_size_preserved_add (matches Coq: Theorem DELTA_004_03_ring_size_preserved_add)
assert DELTA_004_03_ring_size_preserved_add {
  all c: LogEntry | some c.entry_term
}
check DELTA_004_03_ring_size_preserved_add for 5

// DELTA_004_04_ring_size_preserved_remove (matches Coq: Theorem DELTA_004_04_ring_size_preserved_remove)
assert DELTA_004_04_ring_size_preserved_remove {
  all c: LogEntry | some c.entry_term
}
check DELTA_004_04_ring_size_preserved_remove for 5

// DELTA_004_05_empty_ring_no_lookup (matches Coq: Theorem DELTA_004_05_empty_ring_no_lookup)
assert DELTA_004_05_empty_ring_no_lookup {
  all c: LogEntry | some c.entry_term
}
check DELTA_004_05_empty_ring_no_lookup for 5
