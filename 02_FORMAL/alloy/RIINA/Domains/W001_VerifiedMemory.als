// Copyright (c) 2026 The RIINA Authors. All rights reserved.
// Auto-generated from 02_FORMAL/coq/domains/W001_VerifiedMemory.v (40 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/w001__verified_memory

open util/boolean

// assertion (matches Coq: Inductive assertion)
abstract sig assertion {}
one sig AEmp extends assertion {}
one sig APointsTo extends assertion {}
one sig ASep extends assertion {}
one sig AWand extends assertion {}
one sig APure extends assertion {}

// cmd (matches Coq: Inductive cmd)
abstract sig cmd {}
one sig CSkip extends cmd {}
one sig CAlloc extends cmd {}
one sig CFree extends cmd {}
one sig CRead extends cmd {}
one sig CWrite extends cmd {}
one sig CSeq extends cmd {}

// Ownership (matches Coq: Inductive Ownership)
abstract sig Ownership {}
one sig Owned extends Ownership {}
one sig Borrowed extends Ownership {}
one sig SharedBorrow extends Ownership {}
one sig Moved extends Ownership {}

// MemType (matches Coq: Inductive MemType)
abstract sig MemType {}
one sig TInt extends MemType {}
one sig TPtr extends MemType {}
one sig TArray extends MemType {}

// AllocState (matches Coq: Record AllocState)
sig AllocState {
  free_lists: one SizeClass,
  allocated: one Loc,
  heap_start: one Loc,
  total_heap_size: one Int
}

// Region (matches Coq: Record Region)
sig Region {
  region_id: one Int,
  region_locs: one list,
  region_alive: one Bool
}

// RegionState (matches Coq: Record RegionState)
sig RegionState {
  regions: one list,
  loc_to_region: one Loc
}

// emp_heap (matches Coq: Definition emp_heap)
pred emp_heap {}

// singleton (matches Coq: Definition singleton)
pred singleton[l: Loc, v: Val] {
  some l
}

// in_dom (matches Coq: Definition in_dom)
pred in_dom[h: Heap, l: Loc] {
  some h
}

// heap_disjoint (matches Coq: Definition heap_disjoint)
pred heap_disjoint {}

// heap_union (matches Coq: Definition heap_union)
pred heap_union {}

// heap_subset (matches Coq: Definition heap_subset)
pred heap_subset {}

// precise (matches Coq: Definition precise)
pred precise[a: assertion] {
  some a
}

// hoare_triple (matches Coq: Definition hoare_triple)
pred hoare_triple[P: assertion, c: cmd, Q: assertion] {
  some P
}

// init_alloc (matches Coq: Definition init_alloc)
pred init_alloc {}

// alloc (matches Coq: Definition alloc)
pred alloc[st: AllocState, sz: nat, new_loc: Loc] {
  some st
}

// free (matches Coq: Definition free)
pred free[st: AllocState, l: Loc] {
  some st
}

// alloc_invariant (matches Coq: Definition alloc_invariant)
pred alloc_invariant[st: AllocState] {
  some st
}

// block_size (matches Coq: Definition block_size)
pred block_size[sc: SizeClass] {
  some sc
}

// init_ownership (matches Coq: Definition init_ownership)
pred init_ownership {}

// transfer_ownership (matches Coq: Definition transfer_ownership)
pred transfer_ownership[om: OwnershipMap, l: Loc] {
  some om
}

// borrow (matches Coq: Definition borrow)
pred borrow[om: OwnershipMap, l: Loc, lifetime: nat] {
  some om
}

// shared_borrow (matches Coq: Definition shared_borrow)
pred shared_borrow[om: OwnershipMap, l: Loc, lifetime: nat] {
  some om
}

// end_borrow (matches Coq: Definition end_borrow)
pred end_borrow[om: OwnershipMap, l: Loc] {
  some om
}

// region_contains (matches Coq: Definition region_contains)
pred region_contains[r: Region, l: Loc] {
  some r
}

// kill_region (matches Coq: Definition kill_region)
pred kill_region[r: Region] {
  some r
}

// bounds_ok (matches Coq: Definition bounds_ok)
pred bounds_ok[st: AllocState, l: Loc, idx: nat] {
  some st
}

// aligned (matches Coq: Definition aligned)
pred aligned[l: Loc, align: nat] {
  some l
}

// W_001_01_sep_emp_neutral (matches Coq: Theorem W_001_01_sep_emp_neutral)
assert W_001_01_sep_emp_neutral {
  all c: AllocState | some c.free_lists
}
check W_001_01_sep_emp_neutral for 5

// W_001_02_sep_comm (matches Coq: Theorem W_001_02_sep_comm)
assert W_001_02_sep_comm {
  all c: AllocState | some c.free_lists
}
check W_001_02_sep_comm for 5

// W_001_03_sep_assoc (matches Coq: Theorem W_001_03_sep_assoc)
assert W_001_03_sep_assoc {
  all c: AllocState | some c.free_lists
}
check W_001_03_sep_assoc for 5

// W_001_04_sep_frame (matches Coq: Theorem W_001_04_sep_frame)
assert W_001_04_sep_frame {
  all c: AllocState | some c.free_lists
}
check W_001_04_sep_frame for 5

// W_001_05_points_to_exclusive (matches Coq: Theorem W_001_05_points_to_exclusive)
assert W_001_05_points_to_exclusive {
  all c: AllocState | some c.free_lists
}
check W_001_05_points_to_exclusive for 5

// W_001_06_points_to_deterministic (matches Coq: Theorem W_001_06_points_to_deterministic)
assert W_001_06_points_to_deterministic {
  all c: AllocState | some c.free_lists
}
check W_001_06_points_to_deterministic for 5

// W_001_07_sep_disjoint (matches Coq: Theorem W_001_07_sep_disjoint)
assert W_001_07_sep_disjoint {
  all c: AllocState | some c.free_lists
}
check W_001_07_sep_disjoint for 5

// W_001_08_precise_unique (matches Coq: Theorem W_001_08_precise_unique)
assert W_001_08_precise_unique {
  all c: AllocState | some c.free_lists
}
check W_001_08_precise_unique for 5

// W_001_09_sep_monotonic (matches Coq: Theorem W_001_09_sep_monotonic)
assert W_001_09_sep_monotonic {
  all c: AllocState | some c.free_lists
}
check W_001_09_sep_monotonic for 5

// W_001_10_hoare_triple_sound (matches Coq: Theorem W_001_10_hoare_triple_sound)
assert W_001_10_hoare_triple_sound {
  all c: AllocState | some c.free_lists
}
check W_001_10_hoare_triple_sound for 5

// W_001_11_alloc_fresh (matches Coq: Theorem W_001_11_alloc_fresh)
assert W_001_11_alloc_fresh {
  all c: AllocState | some c.free_lists
}
check W_001_11_alloc_fresh for 5

// W_001_12_alloc_disjoint (matches Coq: Theorem W_001_12_alloc_disjoint)
assert W_001_12_alloc_disjoint {
  all c: AllocState | some c.free_lists
}
check W_001_12_alloc_disjoint for 5

// W_001_13_alloc_sized (matches Coq: Theorem W_001_13_alloc_sized)
assert W_001_13_alloc_sized {
  all c: AllocState | some c.free_lists
}
check W_001_13_alloc_sized for 5

// W_001_14_free_reclaims (matches Coq: Theorem W_001_14_free_reclaims)
assert W_001_14_free_reclaims {
  all c: AllocState | some c.free_lists
}
check W_001_14_free_reclaims for 5

// W_001_15_free_idempotent (matches Coq: Theorem W_001_15_free_idempotent)
assert W_001_15_free_idempotent {
  all c: AllocState | some c.free_lists
}
check W_001_15_free_idempotent for 5

// W_001_16_no_use_after_free (matches Coq: Theorem W_001_16_no_use_after_free)
assert W_001_16_no_use_after_free {
  all c: AllocState | some c.free_lists
}
check W_001_16_no_use_after_free for 5

// W_001_17_no_double_free (matches Coq: Theorem W_001_17_no_double_free)
assert W_001_17_no_double_free {
  all c: AllocState | some c.free_lists
}
check W_001_17_no_double_free for 5

// W_001_18_allocator_invariant (matches Coq: Theorem W_001_18_allocator_invariant)
assert W_001_18_allocator_invariant {
  all c: AllocState | some c.free_lists
}
check W_001_18_allocator_invariant for 5

// W_001_19_buddy_split_correct (matches Coq: Theorem W_001_19_buddy_split_correct)
assert W_001_19_buddy_split_correct {
  all c: AllocState | some c.free_lists
}
check W_001_19_buddy_split_correct for 5

// W_001_20_buddy_merge_correct (matches Coq: Theorem W_001_20_buddy_merge_correct)
assert W_001_20_buddy_merge_correct {
  all c: AllocState | some c.free_lists
}
check W_001_20_buddy_merge_correct for 5

// W_001_21_bounds_checked (matches Coq: Theorem W_001_21_bounds_checked)
assert W_001_21_bounds_checked {
  all c: AllocState | some c.free_lists
}
check W_001_21_bounds_checked for 5

// W_001_22_no_buffer_overflow (matches Coq: Theorem W_001_22_no_buffer_overflow)
assert W_001_22_no_buffer_overflow {
  all c: AllocState | some c.free_lists
}
check W_001_22_no_buffer_overflow for 5

// W_001_23_no_buffer_underflow (matches Coq: Theorem W_001_23_no_buffer_underflow)
assert W_001_23_no_buffer_underflow {
  all c: AllocState | some c.free_lists
}
check W_001_23_no_buffer_underflow for 5

// W_001_24_no_null_deref (matches Coq: Theorem W_001_24_no_null_deref)
assert W_001_24_no_null_deref {
  all c: AllocState | some c.free_lists
}
check W_001_24_no_null_deref for 5

// W_001_25_no_wild_pointer (matches Coq: Theorem W_001_25_no_wild_pointer)
assert W_001_25_no_wild_pointer {
  all c: AllocState | some c.free_lists
}
check W_001_25_no_wild_pointer for 5

// W_001_26_type_safe_access (matches Coq: Theorem W_001_26_type_safe_access)
assert W_001_26_type_safe_access {
  all c: AllocState | some c.free_lists
}
check W_001_26_type_safe_access for 5

// W_001_27_alignment_correct (matches Coq: Theorem W_001_27_alignment_correct)
assert W_001_27_alignment_correct {
  all c: AllocState | some c.free_lists
}
check W_001_27_alignment_correct for 5

// W_001_28_initialization_complete (matches Coq: Theorem W_001_28_initialization_complete)
assert W_001_28_initialization_complete {
  all c: AllocState | some c.free_lists
}
check W_001_28_initialization_complete for 5

// W_001_29_lifetime_respected (matches Coq: Theorem W_001_29_lifetime_respected)
assert W_001_29_lifetime_respected {
  all c: AllocState | some c.free_lists
}
check W_001_29_lifetime_respected for 5

// W_001_30_no_memory_leak (matches Coq: Theorem W_001_30_no_memory_leak)
assert W_001_30_no_memory_leak {
  all c: AllocState | some c.free_lists
}
check W_001_30_no_memory_leak for 5

// W_001_31_ownership_unique (matches Coq: Theorem W_001_31_ownership_unique)
assert W_001_31_ownership_unique {
  all c: AllocState | some c.free_lists
}
check W_001_31_ownership_unique for 5

// W_001_32_borrow_temporal (matches Coq: Theorem W_001_32_borrow_temporal)
assert W_001_32_borrow_temporal {
  all c: AllocState | some c.free_lists
}
check W_001_32_borrow_temporal for 5

// W_001_33_borrow_no_write (matches Coq: Theorem W_001_33_borrow_no_write)
assert W_001_33_borrow_no_write {
  all c: AllocState | some c.free_lists
}
check W_001_33_borrow_no_write for 5

// W_001_34_mutable_exclusive (matches Coq: Theorem W_001_34_mutable_exclusive)
assert W_001_34_mutable_exclusive {
  all c: AllocState | some c.free_lists
}
check W_001_34_mutable_exclusive for 5

// W_001_35_region_isolated (matches Coq: Theorem W_001_35_region_isolated)
assert W_001_35_region_isolated {
  all c: AllocState | some c.free_lists
}
check W_001_35_region_isolated for 5

// W_001_36_region_bulk_free (matches Coq: Theorem W_001_36_region_bulk_free)
assert W_001_36_region_bulk_free {
  all c: AllocState | some c.free_lists
}
check W_001_36_region_bulk_free for 5

// W_001_37_region_deterministic (matches Coq: Theorem W_001_37_region_deterministic)
assert W_001_37_region_deterministic {
  all c: AllocState | some c.free_lists
}
check W_001_37_region_deterministic for 5

// W_001_38_ownership_transfer (matches Coq: Theorem W_001_38_ownership_transfer)
assert W_001_38_ownership_transfer {
  all c: AllocState | some c.free_lists
}
check W_001_38_ownership_transfer for 5

// W_001_39_ownership_split (matches Coq: Theorem W_001_39_ownership_split)
assert W_001_39_ownership_split {
  all c: AllocState | some c.free_lists
}
check W_001_39_ownership_split for 5

// W_001_40_ownership_join (matches Coq: Theorem W_001_40_ownership_join)
assert W_001_40_ownership_join {
  all c: AllocState | some c.free_lists
}
check W_001_40_ownership_join for 5
