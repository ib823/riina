// SPDX-License-Identifier: MPL-2.0
// Copyright (c) 2026 The RIINA Authors.
// Auto-generated from 02_FORMAL/coq/domains/AntiJamming.v (25 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/anti_jamming

open util/boolean

// JammerType (matches Coq: Inductive JammerType)
abstract sig JammerType {}
one sig ConstantJammer extends JammerType {} // Always transmitting
one sig ReactiveJammer extends JammerType {} // Jams on activity detection
one sig SweepJammer extends JammerType {} // Sweeps frequencies
one sig SmartJammer extends JammerType {}

// JamDetection (matches Coq: Inductive JamDetection)
abstract sig JamDetection {}
one sig NoJamming extends JamDetection {}
one sig SuspectedJamming extends JamDetection {}
one sig ConfirmedJamming extends JamDetection {}

// AdaptAction (matches Coq: Inductive AdaptAction)
abstract sig AdaptAction {}
one sig IncreasePower extends AdaptAction {}
one sig ChangeFrequency extends AdaptAction {}
one sig ReduceRate extends AdaptAction {}
one sig EnableFEC extends AdaptAction {}
one sig SwitchMode extends AdaptAction {}

// sequence_length_ok (matches Coq: Definition sequence_length_ok)
pred sequence_length_ok[pattern: HoppingPattern, min_length: nat] {
  some pattern
}

// dwell_time_bounded (matches Coq: Definition dwell_time_bounded)
pred dwell_time_bounded[pattern: HoppingPattern, max_dwell: nat] {
  some pattern
}

// processing_gain_sufficient (matches Coq: Definition processing_gain_sufficient)
pred processing_gain_sufficient[ss: SpreadSpectrum, min_gain: nat] {
  some ss
}

// jammer_overcome (matches Coq: Definition jammer_overcome)
pred jammer_overcome {}

// channels_diverse (matches Coq: Definition channels_diverse)
pred channels_diverse[pattern: HoppingPattern, min_channels: nat] {
  some pattern
}

// detect_jamming (matches Coq: Definition detect_jamming)
pred detect_jamming {}

// adaptation_applied (matches Coq: Definition adaptation_applied)
pred adaptation_applied[action: AdaptAction] {
  some action
}

// power_increase_bounded (matches Coq: Definition power_increase_bounded)
pred power_increase_bounded {}

// avoids_jammed (matches Coq: Definition avoids_jammed)
pred avoids_jammed[channel: nat] {
  some channel
}

// rate_above_minimum (matches Coq: Definition rate_above_minimum)
pred rate_above_minimum {}

// fec_gain_sufficient (matches Coq: Definition fec_gain_sufficient)
pred fec_gain_sufficient {}

// switch_latency_ok (matches Coq: Definition switch_latency_ok)
pred switch_latency_ok {}

// hops_synchronized (matches Coq: Definition hops_synchronized)
pred hops_synchronized {}

// key_valid (matches Coq: Definition key_valid)
pred key_valid {}

// sweep_jammer_pattern (matches Coq: Definition sweep_jammer_pattern)
pred sweep_jammer_pattern[threshold: nat] {
  some threshold
}

// silence_period_ok (matches Coq: Definition silence_period_ok)
pred silence_period_ok {}

// adaptation_fast_enough (matches Coq: Definition adaptation_fast_enough)
pred adaptation_fast_enough {}

// quality_acceptable (matches Coq: Definition quality_acceptable)
pred quality_acceptable {}

// degradation_graceful (matches Coq: Definition degradation_graceful)
pred degradation_graceful {}

// fallback_bands_available (matches Coq: Definition fallback_bands_available)
pred fallback_bands_available[min_bands: nat] {
  some min_bands
}

// interference_localized (matches Coq: Definition interference_localized)
pred interference_localized {}

// paths_redundant (matches Coq: Definition paths_redundant)
pred paths_redundant {}

// antijam_layers (matches Coq: Definition antijam_layers)
pred antijam_layers {}

// jam_001_sequence_length (matches Coq: Theorem jam_001_sequence_length)
assert jam_001_sequence_length {
  #univ >= 0
}
check jam_001_sequence_length for 5

// jam_002_dwell_bounded (matches Coq: Theorem jam_002_dwell_bounded)
assert jam_002_dwell_bounded {
  #univ >= 0
}
check jam_002_dwell_bounded for 5

// jam_003_processing_gain (matches Coq: Theorem jam_003_processing_gain)
assert jam_003_processing_gain {
  #univ >= 0
}
check jam_003_processing_gain for 5

// jam_004_code_length (matches Coq: Theorem jam_004_code_length)
assert jam_004_code_length {
  #univ >= 0
}
check jam_004_code_length for 5

// jam_005_jammer_overcome (matches Coq: Theorem jam_005_jammer_overcome)
assert jam_005_jammer_overcome {
  #univ >= 0
}
check jam_005_jammer_overcome for 5

// jam_006_channel_diversity (matches Coq: Theorem jam_006_channel_diversity)
assert jam_006_channel_diversity {
  #univ >= 0
}
check jam_006_channel_diversity for 5

// jam_007_detection_threshold (matches Coq: Theorem jam_007_detection_threshold)
assert jam_007_detection_threshold {
  #univ >= 0
}
check jam_007_detection_threshold for 5

// jam_008_no_false_positive (matches Coq: Theorem jam_008_no_false_positive)
assert jam_008_no_false_positive {
  #univ >= 0
}
check jam_008_no_false_positive for 5

// jam_009_adaptation_improves (matches Coq: Theorem jam_009_adaptation_improves)
assert jam_009_adaptation_improves {
  #univ >= 0
}
check jam_009_adaptation_improves for 5

// jam_010_power_bounded (matches Coq: Theorem jam_010_power_bounded)
assert jam_010_power_bounded {
  #univ >= 0
}
check jam_010_power_bounded for 5

// jam_011_avoids_jammed (matches Coq: Theorem jam_011_avoids_jammed)
assert jam_011_avoids_jammed {
  #univ >= 0
}
check jam_011_avoids_jammed for 5

// jam_012_rate_minimum (matches Coq: Theorem jam_012_rate_minimum)
assert jam_012_rate_minimum {
  #univ >= 0
}
check jam_012_rate_minimum for 5

// jam_013_fec_gain (matches Coq: Theorem jam_013_fec_gain)
assert jam_013_fec_gain {
  #univ >= 0
}
check jam_013_fec_gain for 5

// jam_014_switch_latency (matches Coq: Theorem jam_014_switch_latency)
assert jam_014_switch_latency {
  #univ >= 0
}
check jam_014_switch_latency for 5

// jam_015_synchronized (matches Coq: Theorem jam_015_synchronized)
assert jam_015_synchronized {
  #univ >= 0
}
check jam_015_synchronized for 5

// jam_016_key_required (matches Coq: Theorem jam_016_key_required)
assert jam_016_key_required {
  #univ >= 0
}
check jam_016_key_required for 5

// jam_017_sweep_detected (matches Coq: Theorem jam_017_sweep_detected)
assert jam_017_sweep_detected {
  #univ >= 0
}
check jam_017_sweep_detected for 5

// jam_018_reactive_mitigation (matches Coq: Theorem jam_018_reactive_mitigation)
assert jam_018_reactive_mitigation {
  #univ >= 0
}
check jam_018_reactive_mitigation for 5

// jam_019_adaptation_speed (matches Coq: Theorem jam_019_adaptation_speed)
assert jam_019_adaptation_speed {
  #univ >= 0
}
check jam_019_adaptation_speed for 5

// jam_020_quality_acceptable (matches Coq: Theorem jam_020_quality_acceptable)
assert jam_020_quality_acceptable {
  #univ >= 0
}
check jam_020_quality_acceptable for 5

// jam_021_graceful_degradation (matches Coq: Theorem jam_021_graceful_degradation)
assert jam_021_graceful_degradation {
  #univ >= 0
}
check jam_021_graceful_degradation for 5

// jam_022_fallback_available (matches Coq: Theorem jam_022_fallback_available)
assert jam_022_fallback_available {
  #univ >= 0
}
check jam_022_fallback_available for 5

// jam_023_interference_localized (matches Coq: Theorem jam_023_interference_localized)
assert jam_023_interference_localized {
  #univ >= 0
}
check jam_023_interference_localized for 5

// jam_024_redundant_paths (matches Coq: Theorem jam_024_redundant_paths)
assert jam_024_redundant_paths {
  #univ >= 0
}
check jam_024_redundant_paths for 5

// jam_025_defense_in_depth (matches Coq: Theorem jam_025_defense_in_depth)
assert jam_025_defense_in_depth {
  #univ >= 0
}
check jam_025_defense_in_depth for 5
