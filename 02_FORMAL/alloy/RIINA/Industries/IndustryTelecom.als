// Copyright (c) 2026 The RIINA Authors. All rights reserved.
// Auto-generated from 02_FORMAL/coq/Industries/IndustryTelecom.v (24 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/industry_telecom

open util/boolean

// TelecomDomain (matches Coq: Inductive TelecomDomain)
abstract sig TelecomDomain {}
one sig RAN extends TelecomDomain {} // Radio Access Network
one sig Core extends TelecomDomain {} // Core Network
one sig Transport extends TelecomDomain {} // Transport/Backhaul
one sig Service extends TelecomDomain {} // Service Layer
one sig Management extends TelecomDomain {}
one sig AMF extends TelecomDomain {} // Access and Mobility Management
one sig SMF extends TelecomDomain {} // Session Management
one sig UPF extends TelecomDomain {} // User Plane Function
one sig AUSF extends TelecomDomain {} // Authentication Server
one sig UDM extends TelecomDomain {}

// TelecomEffect (matches Coq: Inductive TelecomEffect)
abstract sig TelecomEffect {}
one sig SignalingIO extends TelecomEffect {}
one sig UserPlaneIO extends TelecomEffect {}
one sig SubscriberData extends TelecomEffect {}
one sig NetworkConfig extends TelecomEffect {}
one sig BillingRecord extends TelecomEffect {}

// Security_5G (matches Coq: Record Security_5G)
sig Security_5G {
  primary_authentication: one Bool // 5G-AKA or EAP-AKA',
  nas_security: one Bool // NAS signaling protection,
  as_security: one Bool // AS layer protection,
  user_plane_integrity: one Bool // UP integrity - optional in 4G,
  service_based_security: one Bool // Service-based architecture security,
  network_slicing_isolation: one Bool // Slice isolation
}

// NetworkSlice (matches Coq: Record NetworkSlice)
sig NetworkSlice {
  slice_id: one Int,
  slice_domain: one TelecomDomain,
  slice_encrypted: one Bool,
  slice_isolated: one Bool,
  slice_sla_latency_ms: one Int
}

// LawfulIntercept (matches Coq: Record LawfulIntercept)
sig LawfulIntercept {
  li_target: one Int,
  li_warrant_id: one Int,
  li_authorized: one Bool,
  li_logged: one Bool
}

// domain_to_nat (matches Coq: Definition domain_to_nat)
pred domain_to_nat[d: TelecomDomain] {
  some d
}

// domain_criticality (matches Coq: Definition domain_criticality)
pred domain_criticality[d: TelecomDomain] {
  some d
}

// is_auth_function (matches Coq: Definition is_auth_function)
pred is_auth_function[nf: NetworkFunction] {
  some nf
}

// security_5g_all (matches Coq: Definition security_5g_all)
pred security_5g_all[s: Security_5G] {
  some s
}

// slices_isolated (matches Coq: Definition slices_isolated)
pred slices_isolated {}

// latency_acceptable (matches Coq: Definition latency_acceptable)
pred latency_acceptable[s: NetworkSlice, max_latency: nat] {
  some s
}

// supi_concealed (matches Coq: Definition supi_concealed)
pred supi_concealed[encrypted: bool, domain: TelecomDomain] {
  some encrypted
}

// key_derivation_depth (matches Coq: Definition key_derivation_depth)
pred key_derivation_depth[domain: TelecomDomain] {
  some domain
}

// roaming_security_level (matches Coq: Definition roaming_security_level)
pred roaming_security_level {}

// li_valid (matches Coq: Definition li_valid)
pred li_valid[li: LawfulIntercept] {
  some li
}

// security_5g_compliance (matches Coq: Theorem security_5g_compliance)
assert security_5g_compliance {
  all c: Security_5G | some c.primary_authentication
}
check security_5g_compliance for 5

// gsma_security (matches Coq: Theorem gsma_security)
assert gsma_security {
  all c: Security_5G | some c.primary_authentication
}
check gsma_security for 5

// slice_isolation (matches Coq: Theorem slice_isolation)
assert slice_isolation {
  all c: Security_5G | some c.primary_authentication
}
check slice_isolation for 5

// signaling_security (matches Coq: Theorem signaling_security)
assert signaling_security {
  all c: Security_5G | some c.primary_authentication
}
check signaling_security for 5

// nfv_security (matches Coq: Theorem nfv_security)
assert nfv_security {
  all c: Security_5G | some c.primary_authentication
}
check nfv_security for 5

// integrity_mandatory_5g (matches Coq: Theorem integrity_mandatory_5g)
assert integrity_mandatory_5g {
  all c: Security_5G | some c.primary_authentication
}
check integrity_mandatory_5g for 5

// up_integrity_available (matches Coq: Theorem up_integrity_available)
assert up_integrity_available {
  all c: Security_5G | some c.primary_authentication
}
check up_integrity_available for 5

// core_most_critical (matches Coq: Theorem core_most_critical)
assert core_most_critical {
  all c: Security_5G | some c.primary_authentication
}
check core_most_critical for 5

// domain_criticality_positive (matches Coq: Theorem domain_criticality_positive)
assert domain_criticality_positive {
  all c: Security_5G | some c.primary_authentication
}
check domain_criticality_positive for 5

// ausf_is_auth (matches Coq: Theorem ausf_is_auth)
assert ausf_is_auth {
  all c: Security_5G | some c.primary_authentication
}
check ausf_is_auth for 5

// amf_not_auth (matches Coq: Theorem amf_not_auth)
assert amf_not_auth {
  all c: Security_5G | some c.primary_authentication
}
check amf_not_auth for 5

// all_sec_requires_auth (matches Coq: Theorem all_sec_requires_auth)
assert all_sec_requires_auth {
  all c: Security_5G | some c.primary_authentication
}
check all_sec_requires_auth for 5

// all_sec_requires_nas (matches Coq: Theorem all_sec_requires_nas)
assert all_sec_requires_nas {
  all c: Security_5G | some c.primary_authentication
}
check all_sec_requires_nas for 5

// all_sec_requires_slicing (matches Coq: Theorem all_sec_requires_slicing)
assert all_sec_requires_slicing {
  all c: Security_5G | some c.primary_authentication
}
check all_sec_requires_slicing for 5

// same_slice_not_isolated (matches Coq: Theorem same_slice_not_isolated)
assert same_slice_not_isolated {
  all c: Security_5G | some c.primary_authentication
}
check same_slice_not_isolated for 5

// latency_bounded (matches Coq: Theorem latency_bounded)
assert latency_bounded {
  all c: Security_5G | some c.primary_authentication
}
check latency_bounded for 5

// supi_always_concealed_in_core (matches Coq: Theorem supi_always_concealed_in_core)
assert supi_always_concealed_in_core {
  all c: Security_5G | some c.primary_authentication
}
check supi_always_concealed_in_core for 5

// supi_concealed_ran_requires_encryption (matches Coq: Theorem supi_concealed_ran_requires_encryption)
assert supi_concealed_ran_requires_encryption {
  all c: Security_5G | some c.primary_authentication
}
check supi_concealed_ran_requires_encryption for 5

// supi_concealed_ran_with_encryption (matches Coq: Theorem supi_concealed_ran_with_encryption)
assert supi_concealed_ran_with_encryption {
  all c: Security_5G | some c.primary_authentication
}
check supi_concealed_ran_with_encryption for 5

// ran_deepest_key_hierarchy (matches Coq: Theorem ran_deepest_key_hierarchy)
assert ran_deepest_key_hierarchy {
  all c: Security_5G | some c.primary_authentication
}
check ran_deepest_key_hierarchy for 5

// roaming_no_upgrade (matches Coq: Theorem roaming_no_upgrade)
assert roaming_no_upgrade {
  all c: Security_5G | some c.primary_authentication
}
check roaming_no_upgrade for 5

// roaming_bounded_by_visited (matches Coq: Theorem roaming_bounded_by_visited)
assert roaming_bounded_by_visited {
  all c: Security_5G | some c.primary_authentication
}
check roaming_bounded_by_visited for 5

// li_requires_authorization (matches Coq: Theorem li_requires_authorization)
assert li_requires_authorization {
  all c: Security_5G | some c.primary_authentication
}
check li_requires_authorization for 5

// li_requires_logging (matches Coq: Theorem li_requires_logging)
assert li_requires_logging {
  all c: Security_5G | some c.primary_authentication
}
check li_requires_logging for 5
