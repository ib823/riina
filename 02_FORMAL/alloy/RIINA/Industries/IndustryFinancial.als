// SPDX-License-Identifier: MPL-2.0
// Copyright (c) 2026 The RIINA Authors.
// Auto-generated from 02_FORMAL/coq/Industries/IndustryFinancial.v (30 assertions)
// Generated by scripts/generate-full-stack.py
module riina/domains/industry_financial

open util/boolean

// FinancialData (matches Coq: Inductive FinancialData)
abstract sig FinancialData {}
one sig PAN extends FinancialData {} // Primary Account Number
one sig CVV extends FinancialData {} // Card Verification Value
one sig PIN extends FinancialData {} // Personal Identification Number
one sig AccountNumber extends FinancialData {}
one sig RoutingNumber extends FinancialData {}
one sig SSN extends FinancialData {} // Social Security Number
one sig NPI extends FinancialData {}
one sig PAN extends FinancialData {}
one sig CVV extends FinancialData {}

// FinancialEffect (matches Coq: Inductive FinancialEffect)
abstract sig FinancialEffect {}
one sig PaymentProcess extends FinancialEffect {}
one sig AccountAccess extends FinancialEffect {}
one sig FundsTransfer extends FinancialEffect {}
one sig TradeExecution extends FinancialEffect {}
one sig AuditLog extends FinancialEffect {}

// TxStatus (matches Coq: Inductive TxStatus)
abstract sig TxStatus {}
one sig TxPending extends TxStatus {}
one sig TxCommitted extends TxStatus {}
one sig TxRolledBack extends TxStatus {}

// PCI_DSS_Controls (matches Coq: Record PCI_DSS_Controls)
sig PCI_DSS_Controls {
  firewall_config: one Bool // Req 1,
  no_default_passwords: one Bool // Req 2,
  protect_stored_data: one Bool // Req 3,
  encrypt_transmission: one Bool // Req 4,
  antivirus: one Bool // Req 5,
  secure_systems: one Bool // Req 6,
  restrict_access: one Bool // Req 7,
  unique_ids: one Bool // Req 8,
  physical_access: one Bool // Req 9,
  track_access: one Bool // Req 10,
  test_security: one Bool // Req 11,
  security_policy: one Bool // Req 12
}

// KYC_Record (matches Coq: Record KYC_Record)
sig KYC_Record {
  identity_verified: one Bool,
  address_verified: one Bool,
  dob_verified: one Bool,
  sanctions_checked: one Bool,
  pep_screened: one Bool
}

// WireTransfer (matches Coq: Record WireTransfer)
sig WireTransfer {
  wire_amount: one Int,
  wire_auth1: one Bool,
  wire_auth2: one Bool,
  wire_timestamp: one Int
}

// pci_cardholder_data (matches Coq: Definition pci_cardholder_data)
pred pci_cardholder_data[d: FinancialData] {
  some d
}

// pci_compliant (matches Coq: Definition pci_compliant)
pred pci_compliant[controls: PCI_DSS_Controls] {
  some controls
}

// tx_final (matches Coq: Definition tx_final)
pred tx_final[s: TxStatus] {
  some s
}

// balance_valid (matches Coq: Definition balance_valid)
pred balance_valid[balance: nat] {
  some balance
}

// audit_log_monotone (matches Coq: Definition audit_log_monotone)
pred audit_log_monotone {}

// kyc_complete (matches Coq: Definition kyc_complete)
pred kyc_complete[k: KYC_Record] {
  some k
}

// aml_risk_acceptable (matches Coq: Definition aml_risk_acceptable)
pred aml_risk_acceptable {}

// convert_and_back (matches Coq: Definition convert_and_back)
pred convert_and_back {}

// fraud_score_valid (matches Coq: Definition fraud_score_valid)
pred fraud_score_valid[score: nat] {
  some score
}

// wire_authorized (matches Coq: Definition wire_authorized)
pred wire_authorized[w: WireTransfer] {
  some w
}

// account_active (matches Coq: Definition account_active)
pred account_active[frozen: bool] {
  some frozen
}

// capital_adequate (matches Coq: Definition capital_adequate)
pred capital_adequate {}

// pci_dss_compliance (matches Coq: Theorem pci_dss_compliance)
assert pci_dss_compliance {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check pci_dss_compliance for 5

// swift_csp_compliance (matches Coq: Theorem swift_csp_compliance)
assert swift_csp_compliance {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check swift_csp_compliance for 5

// sox_404_compliance (matches Coq: Theorem sox_404_compliance)
assert sox_404_compliance {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check sox_404_compliance for 5

// glba_safeguards (matches Coq: Theorem glba_safeguards)
assert glba_safeguards {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check glba_safeguards for 5

// dora_resilience (matches Coq: Theorem dora_resilience)
assert dora_resilience {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check dora_resilience for 5

// cvv_not_stored (matches Coq: Theorem cvv_not_stored)
assert cvv_not_stored {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check cvv_not_stored for 5

// pan_masking (matches Coq: Theorem pan_masking)
assert pan_masking {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check pan_masking for 5

// strong_crypto_required (matches Coq: Theorem strong_crypto_required)
assert strong_crypto_required {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check strong_crypto_required for 5

// pci_cardholder_data_dec (matches Coq: Lemma pci_cardholder_data_dec)
assert pci_cardholder_data_dec {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check pci_cardholder_data_dec for 5

// pan_is_cardholder (matches Coq: Lemma pan_is_cardholder)
assert pan_is_cardholder {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check pan_is_cardholder for 5

// cvv_is_cardholder (matches Coq: Lemma cvv_is_cardholder)
assert cvv_is_cardholder {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check cvv_is_cardholder for 5

// pin_is_cardholder (matches Coq: Lemma pin_is_cardholder)
assert pin_is_cardholder {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check pin_is_cardholder for 5

// non_card_data_not_pci (matches Coq: Lemma non_card_data_not_pci)
assert non_card_data_not_pci {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check non_card_data_not_pci for 5

// tx_final_not_pending (matches Coq: Theorem tx_final_not_pending)
assert tx_final_not_pending {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check tx_final_not_pending for 5

// tx_pending_not_final (matches Coq: Theorem tx_pending_not_final)
assert tx_pending_not_final {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check tx_pending_not_final for 5

// balance_always_valid (matches Coq: Theorem balance_always_valid)
assert balance_always_valid {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check balance_always_valid for 5

// all_unique_nil (matches Coq: Lemma all_unique_nil)
assert all_unique_nil {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check all_unique_nil for 5

// all_unique_singleton (matches Coq: Lemma all_unique_singleton)
assert all_unique_singleton {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check all_unique_singleton for 5

// audit_log_never_shrinks (matches Coq: Theorem audit_log_never_shrinks)
assert audit_log_never_shrinks {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check audit_log_never_shrinks for 5

// kyc_requires_identity (matches Coq: Theorem kyc_requires_identity)
assert kyc_requires_identity {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check kyc_requires_identity for 5

// kyc_requires_sanctions (matches Coq: Theorem kyc_requires_sanctions)
assert kyc_requires_sanctions {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check kyc_requires_sanctions for 5

// aml_risk_bounded (matches Coq: Theorem aml_risk_bounded)
assert aml_risk_bounded {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check aml_risk_bounded for 5

// compound_zero_periods (matches Coq: Theorem compound_zero_periods)
assert compound_zero_periods {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check compound_zero_periods for 5

// compound_monotone (matches Coq: Theorem compound_monotone)
assert compound_monotone {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check compound_monotone for 5

// conversion_bounded (matches Coq: Theorem conversion_bounded)
assert conversion_bounded {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check conversion_bounded for 5

// fraud_score_max_1000 (matches Coq: Theorem fraud_score_max_1000)
assert fraud_score_max_1000 {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check fraud_score_max_1000 for 5

// wire_requires_dual_auth (matches Coq: Theorem wire_requires_dual_auth)
assert wire_requires_dual_auth {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check wire_requires_dual_auth for 5

// frozen_account_inactive (matches Coq: Theorem frozen_account_inactive)
assert frozen_account_inactive {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check frozen_account_inactive for 5

// unfrozen_account_active (matches Coq: Theorem unfrozen_account_active)
assert unfrozen_account_active {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check unfrozen_account_active for 5

// capital_ratio_check (matches Coq: Theorem capital_ratio_check)
assert capital_ratio_check {
  all c: PCI_DSS_Controls | some c.firewall_config
}
check capital_ratio_check for 5
