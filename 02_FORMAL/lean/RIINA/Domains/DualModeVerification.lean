-- Copyright (c) 2026 The RIINA Authors. All rights reserved.

/-!
# RIINA DualModeVerification - Lean 4 Port

Auto-generated port of 02_FORMAL/coq/domains/DualModeVerification.v (22 theorems).

Generated by scripts/generate-multiprover.py

## Correspondence Table

| Coq Definition | Lean Definition | Status |
|----------------|-----------------|--------|
| expr | expr | OK |
| RefinementPred | RefinementPred | OK |
| lightweight_check | lightweight_check | OK |
| full_check | full_check | OK |
| decidable_refinement | decidable_refinement | OK |
| refine_subtype | refine_subtype | OK |
| refine_conj | refine_conj | OK |
| lightweight_sound | lightweight_sound | OK |
| lightweight_complete_decidable | lightweight_complete_decidable | OK |
| refine_subtype_refl | refine_subtype_refl | OK |
| refine_subtype_trans | refine_subtype_trans | OK |
| checked_values_satisfy | checked_values_satisfy | OK |
| dual_mode_agreement | dual_mode_agreement | OK |
| refinement_weakening | refinement_weakening | OK |
| conj_subtype_left | conj_subtype_left | OK |
| conj_subtype_right | conj_subtype_right | OK |
| conj_greatest_lower_bound | conj_greatest_lower_bound | OK |
| conj_full_pred_comm | conj_full_pred_comm | OK |
| conj_full_pred_assoc | conj_full_pred_assoc | OK |
| conj_light_is_andb | conj_light_is_andb | OK |
| eval_const | eval_const | OK |
| eval_plus | eval_plus | OK |
| lightweight_false_implies_not_full | lightweight_false_implies_not_full | OK |
| subtype_lightweight_sound | subtype_lightweight_sound | OK |
| conj_decidable | conj_decidable | OK |
| refine_subtype_antisym_eq | refine_subtype_antisym_eq | OK |
| eval_if_false | eval_if_false | OK |
| eval_if_true | eval_if_true | OK |
| conj_sub_both | conj_sub_both | OK |
-/

namespace RIINA

/-- Boolean conjunction iff (matches Coq: andb_true_iff) -/
private theorem andb_true_iff (a b : Bool) :
    (a && b) = true ↔ a = true ∧ b = true := by
  constructor
  · intro h; cases a <;> cases b <;> simp_all
  · intro ⟨ha, hb⟩; simp [ha, hb]

/-- expr (matches Coq: Inductive expr) -/
inductive expr where
  | eConst : expr
  | ePlus : expr
  | eIf : expr
  deriving DecidableEq, Repr

/-- RefinementPred (matches Coq: Record RefinementPred) -/
structure RefinementPred where
  full_pred : Nat
  light_pred : Nat
  light_sound : forall
  deriving DecidableEq, Repr

/-- lightweight_check (matches Coq: Definition lightweight_check) -/
def lightweight_check (rt : RefinedType) (v : Nat) : Bool :=
  light_pred rt v

/-- full_check (matches Coq: Definition full_check) -/
def full_check (rt : RefinedType) (v : Nat) : Prop :=
  full_pred rt v

/-- decidable_refinement (matches Coq: Definition decidable_refinement) -/
def decidable_refinement (rt : RefinedType) : Prop :=
  forall n, full_pred rt n <-> light_pred rt n = true

/-- refine_subtype (matches Coq: Definition refine_subtype) -/
def refine_subtype (r1 r2 : RefinedType) : Prop :=
  forall n, full_pred r1 n -> full_pred r2 n

/-- refine_conj (matches Coq: Definition refine_conj) -/
def refine_conj (r1 r2 : RefinedType) : RefinedType := mkRefinement
    (fun n => full_pred r1 n /\ full_pred r2 n)
    (fun n => light_pred r1 n && light_pred r2 n)
    (fun n H =>
       let P := andb_prop _ _ H in
       conj (light_sound r1 n (proj1 P)) (light_sound r2 n (proj2 P)))

/-- Theorem 1: Lightweight checking is sound. -/
/-- lightweight_sound (matches Coq) -/
theorem lightweight_sound : ∀ (rt : RefinedType) (v : nat), lightweight_check rt v = true → full_check rt v := by
  simp_all

/-- Theorem 2: For decidable predicates, lightweight is complete. -/
/-- lightweight_complete_decidable (matches Coq) -/
theorem lightweight_complete_decidable : ∀ (rt : RefinedType) (v : nat), decidable_refinement rt → full_check rt v → lightweight_check rt v = true := by
  simp_all [Bool.and_eq_true]

/-- Theorem 3: Refinement subtyping is reflexive. -/
/-- refine_subtype_refl (matches Coq) -/
theorem refine_subtype_refl : ∀ (rt : RefinedType), refine_subtype rt rt := by
  intro h; exact h

/-- Theorem 4: Refinement subtyping is transitive. -/
/-- refine_subtype_trans (matches Coq) -/
theorem refine_subtype_trans : ∀ (r1 r2 r3 : RefinedType), refine_subtype r1 r2 → refine_subtype r2 r3 → refine_subtype r1 r3 := by
  simp_all [Bool.and_eq_true]

/-- Theorem 5: Checked values satisfy their refinements. -/
/-- checked_values_satisfy (matches Coq) -/
theorem checked_values_satisfy : ∀ (rt : RefinedType) (e : expr), lightweight_check rt (eval e) = true → full_check rt (eval e) := by
  simp_all [Bool.and_eq_true]

/-- Theorem 6: Dual-mode agrees on decidable predicates. -/
/-- dual_mode_agreement (matches Coq) -/
theorem dual_mode_agreement : ∀ (rt : RefinedType) (v : nat), decidable_refinement rt → (lightweight_check rt v = true <-> full_check rt v) := by
  simp_all [Bool.and_eq_true]

/-- Theorem 7: Weakening — stronger refinement implies weaker. -/
/-- refinement_weakening (matches Coq) -/
theorem refinement_weakening : ∀ (r1 r2 : RefinedType) (v : nat), refine_subtype r1 r2 → full_check r1 v → full_check r2 v := by
  simp_all [Bool.and_eq_true]

/-- Theorem 8: Conjunction subtype left projection. -/
/-- conj_subtype_left (matches Coq) -/
theorem conj_subtype_left : ∀ (r1 r2 : RefinedType), refine_subtype (refine_conj r1 r2) r1 := by
  intro h; exact h

/-- Theorem 9: Conjunction subtype right projection. -/
/-- conj_subtype_right (matches Coq) -/
theorem conj_subtype_right : ∀ (r1 r2 : RefinedType), refine_subtype (refine_conj r1 r2) r2 := by
  intro h; exact h

/-- Theorem 10: Conjunction is the greatest lower bound. -/
/-- conj_greatest_lower_bound (matches Coq) -/
theorem conj_greatest_lower_bound : ∀ (r1 r2 r3 : RefinedType), refine_subtype r3 r1 → refine_subtype r3 r2 → refine_subtype r3 (refine_conj r1 r2) := by
  simp_all [Bool.and_eq_true]

/-- Theorem 11: Conjunction is commutative on full_pred -/
/-- conj_full_pred_comm (matches Coq) -/
theorem conj_full_pred_comm : ∀ (r1 r2 : RefinedType) (v : nat), full_pred (refine_conj r1 r2) v <-> full_pred (refine_conj r2 r1) v := by
  simp_all [Bool.and_eq_true]

/-- Theorem 12: Conjunction is associative on full_pred -/
/-- conj_full_pred_assoc (matches Coq) -/
theorem conj_full_pred_assoc : ∀ (r1 r2 r3 : RefinedType) (v : nat), full_pred (refine_conj (refine_conj r1 r2) r3) v <-> full_pred (refine_conj r1 (refine_conj r2 r3)) v := by
  simp_all [Bool.and_eq_true]

/-- Theorem 13: Conjunction light_pred is AND -/
/-- conj_light_is_andb (matches Coq) -/
theorem conj_light_is_andb : ∀ (r1 r2 : RefinedType) (v : nat), light_pred (refine_conj r1 r2) v = (light_pred r1 v && light_pred r2 v)%bool := by
  rfl

/-- Theorem 14: Eval of EConst is the constant itself -/
/-- eval_const (matches Coq) -/
theorem eval_const : ∀ n, eval (EConst n) = n := by
  rfl

/-- Theorem 15: Eval of EPlus is sum of evaluations -/
/-- eval_plus (matches Coq) -/
theorem eval_plus : ∀ e1 e2, eval (EPlus e1 e2) = eval e1 + eval e2 := by
  rfl

/-- Theorem 16: Lightweight check false implies not full_check for decidable -/
/-- lightweight_false_implies_not_full (matches Coq) -/
theorem lightweight_false_implies_not_full : ∀ (rt : RefinedType) (v : nat), decidable_refinement rt → lightweight_check rt v = false → ~ full_check rt v := by
  simp_all [Bool.and_eq_true]

/-- Theorem 17: Subtype preserves lightweight soundness -/
/-- subtype_lightweight_sound (matches Coq) -/
theorem subtype_lightweight_sound : ∀ (r1 r2 : RefinedType) (v : nat), refine_subtype r1 r2 → lightweight_check r1 v = true → full_check r2 v := by
  simp_all [Bool.and_eq_true]

/-- Theorem 18: Conjunction of decidable refinements is decidable -/
/-- conj_decidable (matches Coq) -/
theorem conj_decidable : ∀ (r1 r2 : RefinedType), decidable_refinement r1 → decidable_refinement r2 → decidable_refinement (refine_conj r1 r2) := by
  simp_all [Bool.and_eq_true]

/-- Theorem 19: Refine_subtype is antisymmetric under full_pred equality -/
/-- refine_subtype_antisym_eq (matches Coq) -/
theorem refine_subtype_antisym_eq : ∀ (r1 r2 : RefinedType), refine_subtype r1 r2 → refine_subtype r2 r1 → ∀ n, full_pred r1 n <-> full_pred r2 n := by
  constructor <;> simp_all [Bool.and_eq_true]

/-- Theorem 20: Eval of EIf with 0 guard takes else branch -/
/-- eval_if_false (matches Coq) -/
theorem eval_if_false : ∀ et ef, eval (EIf (EConst 0) et ef) = eval ef := by
  rfl

/-- Theorem 21: Eval of EIf with nonzero guard takes then branch -/
/-- eval_if_true (matches Coq) -/
theorem eval_if_true : ∀ n et ef, n ≠ 0 → eval (EIf (EConst n) et ef) = eval et := by
  cases ‹_› <;> simp

/-- Theorem 22: Conjunction subtyping both ways -/
/-- conj_sub_both (matches Coq) -/
theorem conj_sub_both : ∀ (r1 r2 : RefinedType) (v : nat), full_check (refine_conj r1 r2) v → full_check r1 v ∧ full_check r2 v := by
  intro h; exact h

end RIINA
