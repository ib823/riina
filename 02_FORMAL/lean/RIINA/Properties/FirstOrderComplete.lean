-- Copyright (c) 2026 The RIINA Authors. All rights reserved.

/-!
# RIINA FirstOrderComplete - Lean 4 Port

Auto-generated port of 02_FORMAL/coq/properties/FirstOrderComplete.v (7 theorems).

Generated by scripts/generate-multiprover.py

## Correspondence Table

| Coq Definition | Lean Definition | Status |
|----------------|-----------------|--------|
| is_base_type | is_base_type | OK |
| store_independent | store_independent | OK |
| first_order_subtype | first_order_subtype | OK |
| first_order_subtypes_fo | first_order_subtypes_fo | OK |
| base_type_first_order | base_type_first_order | OK |
| base_type_size_one | base_type_size_one | OK |
| first_order_value_structure | first_order_value_structure | OK |
| first_order_induction_simple | first_order_induction_simple | OK |
| ty_eqb_refl | ty_eqb_refl | OK |
-/

namespace RIINA

/-- Boolean conjunction iff (matches Coq: andb_true_iff) -/
private theorem andb_true_iff (a b : Bool) :
    (a && b) = true ↔ a = true ∧ b = true := by
  constructor
  · intro h; cases a <;> cases b <;> simp_all
  · intro ⟨ha, hb⟩; simp [ha, hb]

/-- is_base_type (matches Coq: Definition is_base_type) -/
def is_base_type (T : ty) : Bool :=
  match T with
  | .tBytes => true
  | ._ => false

/-- store_independent (matches Coq: Definition store_independent) -/
def store_independent (P : ty -> Prop) : Prop :=
  forall T, first_order_type T = true -> P T

/-- First-order types are closed under subtyping -/
/-- first_order_subtype (matches Coq) -/
theorem first_order_subtype : ∀ T, first_order_type T = true → match T with | TProd T1 T2 => first_order_type T1 = true ∧ first_order_type T2 = true | TSum T1 T2 => first_order_type T1 = true ∧ first_order_type T2 = true | TList T' => first_order_type T' = true | TOption T' => first_order_type T' = true | TRef T' _ => first_order_type T' = true | TSecret T' => first_order_type T' = true | TLabeled T' _ => first_order_type T' = true | TTainted T' _ => first_order_type T' = true | TSanitized T' _ => first_order_type T' = true | TProof T' => first_order_type T' = true | TConstantTime T' => first_order_type T' = true | TZeroizing T' => first_order_type T' = true | _ => True end := by
  simp_all [Bool.and_eq_true]

/-- All immediate subtypes of a first-order type are first-order -/
/-- first_order_subtypes_fo (matches Coq) -/
theorem first_order_subtypes_fo : ∀ T, first_order_type T = true → ∀ T', (∃ T2, T = TProd T' T2) ∨ (∃ T1, T = TProd T1 T') ∨ (∃ T2, T = TSum T' T2) ∨ (∃ T1, T = TSum T1 T') ∨ T = TList T' ∨ T = TOption T' ∨ (∃ sl, T = TRef T' sl) ∨ T = TSecret T' ∨ (∃ sl, T = TLabeled T' sl) ∨ (∃ src, T = TTainted T' src) ∨ (∃ san, T = TSanitized T' san) ∨ T = TProof T' ∨ T = TConstantTime T' ∨ T = TZeroizing T' → first_order_type T' = true := by
  simp_all [Bool.and_eq_true]

/-- base_type_first_order (matches Coq) -/
theorem base_type_first_order : ∀ T, is_base_type T = true → first_order_type T = true := by
  simp_all [Bool.and_eq_true]

/-- base_type_size_one (matches Coq) -/
theorem base_type_size_one : ∀ T, is_base_type T = true → ty_size T = 1 := by
  simp_all [Bool.and_eq_true]

/-- First-order value relations are structurally determined -/
/-- first_order_value_structure (matches Coq) -/
theorem first_order_value_structure : ∀ T, first_order_type T = true → match T with (* Primitive types *) | TUnit => True | TBool => True | TInt => True | TString => True | TBytes => True (* Capability types *) | TCapability _ => True | TCapabilityFull _ => True (* Compound types *) | TProd T1 T2 => first_order_type T1 = true ∧ first_order_type T2 = true | TSum T1 T2 => first_order_type T1 = true ∧ first_order_type T2 = true | TList T' => first_order_type T' = true | TOption T' => first_order_type T' = true (* Reference types *) | TRef T' _ => first_order_type T' = true (* Security types *) | TSecret T' => first_order_type T' = true | TLabeled T' _ => first_order_type T' = true | TTainted T' _ => first_order_type T' = true | TSanitized T' _ => first_order_type T' = true | TProof T' => first_order_type T' = true (* Constant-time and zeroizing *) | TConstantTime T' => first_order_type T' = true | TZeroizing T' => first_order_type T' = true (* Higher-order types *) | TFn _ _ _ => False | TChan _ => False | TSecureChan _ _ => False end := by
  simp_all [Bool.and_eq_true]

/-- first_order_induction_simple (matches Coq) -/
theorem first_order_induction_simple : ∀ (P : ty → Prop), (* Primitive types *) P TUnit → P TBool → P TInt → P TString → P TBytes → (* Capability types *) (∀ k, P (TCapability k)) → (∀ cap, P (TCapabilityFull cap)) → (* Recursive cases - assume P holds for subtypes *) (∀ T1 T2, first_order_type T1 = true → first_order_type T2 = true → P (TProd T1 T2)) → (∀ T1 T2, first_order_type T1 = true → first_order_type T2 = true → P (TSum T1 T2)) → (∀ T, first_order_type T = true → P (TList T)) → (∀ T, first_order_type T = true → P (TOption T)) → (∀ T sl, first_order_type T = true → P (TRef T sl)) → (∀ T, first_order_type T = true → P (TSecret T)) → (∀ T sl, first_order_type T = true → P (TLabeled T sl)) → (∀ T src, first_order_type T = true → P (TTainted T src)) → (∀ T san, first_order_type T = true → P (TSanitized T san)) → (∀ T, first_order_type T = true → P (TProof T)) → (∀ T, first_order_type T = true → P (TConstantTime T)) → (∀ T, first_order_type T = true → P (TZeroizing T)) → ∀ T, first_order_type T = true → P T := by
  simp_all [Bool.and_eq_true]

/-- ty_eqb_refl (matches Coq) -/
theorem ty_eqb_refl : ∀ T, ty_eqb T T = true := by
  rfl

end RIINA
