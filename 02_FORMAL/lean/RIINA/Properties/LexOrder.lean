-- SPDX-License-Identifier: MPL-2.0
-- Copyright (c) 2026 The RIINA Authors. See AUTHORS file.

/-!
# RIINA LexOrder - Lean 4 Port

Auto-generated port of 02_FORMAL/coq/properties/LexOrder.v (16 theorems).

Generated by scripts/generate-multiprover.py

## Correspondence Table

| Coq Definition | Lean Definition | Status |
|----------------|-----------------|--------|
| lex_lt | lex_lt | OK |
| step_ty_lt | step_ty_lt | OK |
| triple_lt | triple_lt | OK |
| lex_lt_wf | lex_lt_wf | OK |
| lex_induction | lex_induction | OK |
| lex_lt_left | lex_lt_left | OK |
| lex_lt_right | lex_lt_right | OK |
| step_ty_lt_wf | step_ty_lt_wf | OK |
| step_ty_induction | step_ty_induction | OK |
| step_ty_lt_step | step_ty_lt_step | OK |
| step_ty_lt_ty | step_ty_lt_ty | OK |
| step_ty_lt_fn_arg | step_ty_lt_fn_arg | OK |
| step_ty_lt_fn_res | step_ty_lt_fn_res | OK |
| step_ty_lt_prod_left | step_ty_lt_prod_left | OK |
| step_ty_lt_prod_right | step_ty_lt_prod_right | OK |
| step_ty_lt_sum_left | step_ty_lt_sum_left | OK |
| step_ty_lt_sum_right | step_ty_lt_sum_right | OK |
| step_ty_lt_step_any | step_ty_lt_step_any | OK |
| triple_lt_wf | triple_lt_wf | OK |
-/

namespace RIINA

/-- lex_lt (matches Coq: Definition lex_lt) -/
def lex_lt (p1 p2 : Nat * Nat) : Prop :=
  let (m1, m2) := p1 in
  let (n1, n2) := p2 in
  m1 < n1 \/ (m1 = n1 /\ m2 < n2)

/-- step_ty_lt (matches Coq: Definition step_ty_lt) -/
def step_ty_lt (p1 p2 : Nat * ty) : Prop :=
  let (n1, T1) := p1 in
  let (n2, T2) := p2 in
  n1 < n2 \/ (n1 = n2 /\ ty_size T1 < ty_size T2)

/-- triple_lt (matches Coq: Definition triple_lt) -/
def triple_lt (p1 p2 : Nat * Nat * Nat) : Prop :=
  let '(a1, b1, c1) := p1 in
  let '(a2, b2, c2) := p2 in
  a1 < a2 \/
  (a1 = a2 /\ b1 < b2) \/
  (a1 = a2 /\ b1 = b2 /\ c1 < c2)

/-- Direct proof using nested well-founded induction -/
/-- lex_lt_wf (matches Coq) -/
theorem lex_lt_wf : well_founded lex_lt := by
  simp_all [Bool.and_eq_true]

/-- lex_induction (matches Coq) -/
theorem lex_induction : ∀ (P : nat → nat → Prop), (∀ n m, (∀ n' m', lex_lt (n', m') (n, m) → P n' m') → P n m) → ∀ n m, P n m := by
  simp_all [Bool.and_eq_true]

/-- lex_lt_left (matches Coq) -/
theorem lex_lt_left : ∀ n m n' m', n' < n → lex_lt (n', m') (n, m) := by
  intro h; exact h

/-- lex_lt_right (matches Coq) -/
theorem lex_lt_right : ∀ n m m', m' < m → lex_lt (n, m') (n, m) := by
  intro h; exact h

/-- step_ty_lt is well-founded -/
/-- step_ty_lt_wf (matches Coq) -/
theorem step_ty_lt_wf : well_founded step_ty_lt := by
  simp_all [Bool.and_eq_true]

/-- Induction principle for step-type pairs -/
/-- step_ty_induction (matches Coq) -/
theorem step_ty_induction : ∀ (P : nat → ty → Prop), (∀ n T, (∀ n' T', step_ty_lt (n', T') (n, T) → P n' T') → P n T) → ∀ n T, P n T := by
  simp_all [Bool.and_eq_true]

/-- Decreasing step index (the primary decrease for TFn) -/
/-- step_ty_lt_step (matches Coq) -/
theorem step_ty_lt_step : ∀ n T T', step_ty_lt (n, T') (S n, T) := by
  omega

/-- Decreasing type size at same step (for recursive types) -/
/-- step_ty_lt_ty (matches Coq) -/
theorem step_ty_lt_ty : ∀ n T T', ty_size T' < ty_size T → step_ty_lt (n, T') (n, T) := by
  intro h; exact h

/-- TFn argument is smaller -/
/-- step_ty_lt_fn_arg (matches Coq) -/
theorem step_ty_lt_fn_arg : ∀ n T1 T2 eff, step_ty_lt (n, T1) (n, TFn T1 T2 eff) := by
  simp_all [Bool.and_eq_true]

/-- TFn result is smaller -/
/-- step_ty_lt_fn_res (matches Coq) -/
theorem step_ty_lt_fn_res : ∀ n T1 T2 eff, step_ty_lt (n, T2) (n, TFn T1 T2 eff) := by
  simp_all [Bool.and_eq_true]

/-- TProd components are smaller -/
/-- step_ty_lt_prod_left (matches Coq) -/
theorem step_ty_lt_prod_left : ∀ n T1 T2, step_ty_lt (n, T1) (n, TProd T1 T2) := by
  simp_all [Bool.and_eq_true]

/-- step_ty_lt_prod_right (matches Coq) -/
theorem step_ty_lt_prod_right : ∀ n T1 T2, step_ty_lt (n, T2) (n, TProd T1 T2) := by
  simp_all [Bool.and_eq_true]

/-- TSum components are smaller -/
/-- step_ty_lt_sum_left (matches Coq) -/
theorem step_ty_lt_sum_left : ∀ n T1 T2, step_ty_lt (n, T1) (n, TSum T1 T2) := by
  simp_all [Bool.and_eq_true]

/-- step_ty_lt_sum_right (matches Coq) -/
theorem step_ty_lt_sum_right : ∀ n T1 T2, step_ty_lt (n, T2) (n, TSum T1 T2) := by
  simp_all [Bool.and_eq_true]

/-- Step decrease combined with type -/
/-- step_ty_lt_step_any (matches Coq) -/
theorem step_ty_lt_step_any : ∀ n n' T T', n' < n → step_ty_lt (n', T') (n, T) := by
  intro h; exact h

/-- triple_lt_wf (matches Coq) -/
theorem triple_lt_wf : well_founded triple_lt := by
  simp_all [Bool.and_eq_true]

end RIINA
