-- SPDX-License-Identifier: MPL-2.0
-- Copyright (c) 2026 The RIINA Authors. See AUTHORS file.

/-!
# RIINA SubstitutionCommute - Lean 4 Port

Auto-generated port of 02_FORMAL/coq/properties/SubstitutionCommute.v (11 theorems).

Generated by scripts/generate-multiprover.py

## Correspondence Table

| Coq Definition | Lean Definition | Status |
|----------------|-----------------|--------|
| id_rho_sc | id_rho_sc | OK |
| extend_rho_sc | extend_rho_sc | OK |
| closed_expr_sc | closed_expr_sc | OK |
| closed_rho_sc | closed_rho_sc | OK |
| extend_rho_sc_same | extend_rho_sc_same | OK |
| extend_rho_sc_diff | extend_rho_sc_diff | OK |
| extend_rho_sc_shadow | extend_rho_sc_shadow | OK |
| extend_rho_sc_comm | extend_rho_sc_comm | OK |
| subst_not_free_sc | subst_not_free_sc | OK |
| subst_closed_sc | subst_closed_sc | OK |
| closed_unit_sub | closed_unit_sub | OK |
| closed_bool_sub | closed_bool_sub | OK |
| closed_int_sub | closed_int_sub | OK |
| closed_string_sub | closed_string_sub | OK |
| closed_loc_sub | closed_loc_sub | OK |
-/

namespace RIINA

/-- id_rho_sc (matches Coq: Definition id_rho_sc) -/
def id_rho_sc : subst_rho_sc :=
  fun x => EVar x

/-- extend_rho_sc (matches Coq: Definition extend_rho_sc) -/
def extend_rho_sc (ρ : subst_rho_sc) (x : ident) (v : expr) : subst_rho_sc :=
  fun y => if String

/-- closed_expr_sc (matches Coq: Definition closed_expr_sc) -/
def closed_expr_sc (e : expr) : Prop :=
  forall x, ~ free_in x e

/-- closed_rho_sc (matches Coq: Definition closed_rho_sc) -/
def closed_rho_sc (ρ : subst_rho_sc) : Prop :=
  forall x, closed_expr_sc (ρ x)

/-- ----------------------------------------------------------------- -/
/-- extend_rho_sc_same (matches Coq) -/
theorem extend_rho_sc_same : ∀ ρ x v, extend_rho_sc ρ x v x = v := by
  rfl

/-- extend_rho_sc_diff (matches Coq) -/
theorem extend_rho_sc_diff : ∀ ρ x y v, x ≠ y → extend_rho_sc ρ x v y = ρ y := by
  rfl

/-- extend_rho_sc_shadow (matches Coq) -/
theorem extend_rho_sc_shadow : ∀ ρ x v1 v2, extend_rho_sc (extend_rho_sc ρ x v1) x v2 = extend_rho_sc ρ x v2 := by
  rfl

/-- extend_rho_sc_comm (matches Coq) -/
theorem extend_rho_sc_comm : ∀ ρ x y vx vy, x ≠ y → extend_rho_sc (extend_rho_sc ρ x vx) y vy = extend_rho_sc (extend_rho_sc ρ y vy) x vx := by
  rfl

/-- ----------------------------------------------------------------- -/
/-- subst_not_free_sc (matches Coq) -/
theorem subst_not_free_sc : ∀ x v e, ~ free_in x e → [x := v] e = e := by
  cases ‹_› <;> simp

/-- subst_closed_sc (matches Coq) -/
theorem subst_closed_sc : ∀ x v e, closed_expr_sc e → [x := v] e = e := by
  simp_all [Bool.and_eq_true]

/-- Base type closed lemmas -/
/-- closed_unit_sub (matches Coq) -/
theorem closed_unit_sub : closed_expr_sc EUnit := by
  intro h; exact h

/-- closed_bool_sub (matches Coq) -/
theorem closed_bool_sub : ∀ b, closed_expr_sc (EBool b) := by
  intro h; exact h

/-- closed_int_sub (matches Coq) -/
theorem closed_int_sub : ∀ n, closed_expr_sc (EInt n) := by
  intro h; exact h

/-- closed_string_sub (matches Coq) -/
theorem closed_string_sub : ∀ s, closed_expr_sc (EString s) := by
  intro h; exact h

/-- closed_loc_sub (matches Coq) -/
theorem closed_loc_sub : ∀ l, closed_expr_sc (ELoc l) := by
  intro h; exact h

end RIINA
