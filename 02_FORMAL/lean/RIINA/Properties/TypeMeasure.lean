-- SPDX-License-Identifier: MPL-2.0
-- Copyright (c) 2026 The RIINA Authors. See AUTHORS file.

/-!
# RIINA TypeMeasure - Lean 4 Port

Auto-generated port of 02_FORMAL/coq/properties/TypeMeasure.v (29 theorems).

Generated by scripts/generate-multiprover.py

## Correspondence Table

| Coq Definition | Lean Definition | Status |
|----------------|-----------------|--------|
| ty_size_lt | ty_size_lt | OK |
| ty_size_pos | ty_size_pos | OK |
| ty_size_fn_arg | ty_size_fn_arg | OK |
| ty_size_fn_res | ty_size_fn_res | OK |
| ty_size_prod_left | ty_size_prod_left | OK |
| ty_size_prod_right | ty_size_prod_right | OK |
| ty_size_sum_left | ty_size_sum_left | OK |
| ty_size_sum_right | ty_size_sum_right | OK |
| ty_size_ref_content | ty_size_ref_content | OK |
| ty_size_secret_content | ty_size_secret_content | OK |
| ty_size_proof_content | ty_size_proof_content | OK |
| ty_size_lt_wf | ty_size_lt_wf | OK |
| ty_size_induction | ty_size_induction | OK |
| first_order_no_fn | first_order_no_fn | OK |
| first_order_decidable | first_order_decidable | OK |
| first_order_prod_inv | first_order_prod_inv | OK |
| first_order_sum_inv | first_order_sum_inv | OK |
| first_order_ref_inv | first_order_ref_inv | OK |
| first_order_secret_inv | first_order_secret_inv | OK |
| first_order_proof_inv | first_order_proof_inv | OK |
| fo_compound_depth_prod | fo_compound_depth_prod | OK |
| fo_compound_depth_sum | fo_compound_depth_sum | OK |
| fo_compound_depth_prod_left | fo_compound_depth_prod_left | OK |
| fo_compound_depth_prod_right | fo_compound_depth_prod_right | OK |
| fo_compound_depth_sum_left | fo_compound_depth_sum_left | OK |
| fo_compound_depth_sum_right | fo_compound_depth_sum_right | OK |
| fo_compound_depth_primitive | fo_compound_depth_primitive | OK |
| ty_depth_fn_arg | ty_depth_fn_arg | OK |
| ty_depth_fn_res | ty_depth_fn_res | OK |
| first_order_base_depth | first_order_base_depth | OK |
-/

namespace RIINA

/-- Boolean conjunction iff (matches Coq: andb_true_iff) -/
private theorem andb_true_iff (a b : Bool) :
    (a && b) = true ↔ a = true ∧ b = true := by
  constructor
  · intro h; cases a <;> cases b <;> simp_all
  · intro ⟨ha, hb⟩; simp [ha, hb]

/-- ty_size_lt (matches Coq: Definition ty_size_lt) -/
def ty_size_lt (T1 T2 : ty) : Prop :=
  ty_size T1 < ty_size T2

/-- ty_size_pos (matches Coq) -/
theorem ty_size_pos : ∀ T, ty_size T > 0 := by
  omega

/-- TFn argument is strictly smaller -/
/-- ty_size_fn_arg (matches Coq) -/
theorem ty_size_fn_arg : ∀ T1 T2 eff, ty_size T1 < ty_size (TFn T1 T2 eff) := by
  omega

/-- TFn result is strictly smaller -/
/-- ty_size_fn_res (matches Coq) -/
theorem ty_size_fn_res : ∀ T1 T2 eff, ty_size T2 < ty_size (TFn T1 T2 eff) := by
  omega

/-- TProd left is strictly smaller -/
/-- ty_size_prod_left (matches Coq) -/
theorem ty_size_prod_left : ∀ T1 T2, ty_size T1 < ty_size (TProd T1 T2) := by
  omega

/-- TProd right is strictly smaller -/
/-- ty_size_prod_right (matches Coq) -/
theorem ty_size_prod_right : ∀ T1 T2, ty_size T2 < ty_size (TProd T1 T2) := by
  omega

/-- TSum left is strictly smaller -/
/-- ty_size_sum_left (matches Coq) -/
theorem ty_size_sum_left : ∀ T1 T2, ty_size T1 < ty_size (TSum T1 T2) := by
  omega

/-- TSum right is strictly smaller -/
/-- ty_size_sum_right (matches Coq) -/
theorem ty_size_sum_right : ∀ T1 T2, ty_size T2 < ty_size (TSum T1 T2) := by
  omega

/-- TRef content is strictly smaller -/
/-- ty_size_ref_content (matches Coq) -/
theorem ty_size_ref_content : ∀ T sl, ty_size T < ty_size (TRef T sl) := by
  omega

/-- TSecret content is strictly smaller -/
/-- ty_size_secret_content (matches Coq) -/
theorem ty_size_secret_content : ∀ T, ty_size T < ty_size (TSecret T) := by
  omega

/-- TProof content is strictly smaller -/
/-- ty_size_proof_content (matches Coq) -/
theorem ty_size_proof_content : ∀ T, ty_size T < ty_size (TProof T) := by
  omega

/-- ty_size_lt is well-founded (inherits from lt on nat) -/
/-- ty_size_lt_wf (matches Coq) -/
theorem ty_size_lt_wf : well_founded ty_size_lt := by
  simp_all [Bool.and_eq_true]

/-- Induction principle based on type size -/
/-- ty_size_induction (matches Coq) -/
theorem ty_size_induction : ∀ (P : ty → Prop), (∀ T, (∀ T', ty_size T' < ty_size T → P T') → P T) → ∀ T, P T := by
  simp_all [Bool.and_eq_true]

/-- First-order types contain no TFn -/
/-- first_order_no_fn (matches Coq) -/
theorem first_order_no_fn : ∀ T T1 T2 eff, first_order_type T = true → T ≠ TFn T1 T2 eff := by
  simp_all [Bool.and_eq_true]

/-- First-order is decidable -/
/-- first_order_decidable (matches Coq) -/
theorem first_order_decidable : ∀ T, {first_order_type T = true} + {first_order_type T = false} := by
  simp_all [Bool.and_eq_true]

/-- First-order subtypes of first-order types -/
/-- first_order_prod_inv (matches Coq) -/
theorem first_order_prod_inv : ∀ T1 T2, first_order_type (TProd T1 T2) = true → first_order_type T1 = true ∧ first_order_type T2 = true := by
  simp_all [Bool.and_eq_true]

/-- first_order_sum_inv (matches Coq) -/
theorem first_order_sum_inv : ∀ T1 T2, first_order_type (TSum T1 T2) = true → first_order_type T1 = true ∧ first_order_type T2 = true := by
  simp_all [Bool.and_eq_true]

/-- first_order_ref_inv (matches Coq) -/
theorem first_order_ref_inv : ∀ T sl, first_order_type (TRef T sl) = true → first_order_type T = true := by
  intro h; exact h

/-- first_order_secret_inv (matches Coq) -/
theorem first_order_secret_inv : ∀ T, first_order_type (TSecret T) = true → first_order_type T = true := by
  intro h; exact h

/-- first_order_proof_inv (matches Coq) -/
theorem first_order_proof_inv : ∀ T, first_order_type (TProof T) = true → first_order_type T = true := by
  intro h; exact h

/-- fo_compound_depth for TProd -/
/-- fo_compound_depth_prod (matches Coq) -/
theorem fo_compound_depth_prod : ∀ T1 T2, fo_compound_depth (TProd T1 T2) = 1 + Nat.max (fo_compound_depth T1) (fo_compound_depth T2) := by
  rfl

/-- fo_compound_depth for TSum -/
/-- fo_compound_depth_sum (matches Coq) -/
theorem fo_compound_depth_sum : ∀ T1 T2, fo_compound_depth (TSum T1 T2) = 1 + Nat.max (fo_compound_depth T1) (fo_compound_depth T2) := by
  rfl

/-- Component depths are less than parent -/
/-- fo_compound_depth_prod_left (matches Coq) -/
theorem fo_compound_depth_prod_left : ∀ T1 T2, fo_compound_depth T1 < fo_compound_depth (TProd T1 T2) := by
  omega

/-- fo_compound_depth_prod_right (matches Coq) -/
theorem fo_compound_depth_prod_right : ∀ T1 T2, fo_compound_depth T2 < fo_compound_depth (TProd T1 T2) := by
  omega

/-- fo_compound_depth_sum_left (matches Coq) -/
theorem fo_compound_depth_sum_left : ∀ T1 T2, fo_compound_depth T1 < fo_compound_depth (TSum T1 T2) := by
  omega

/-- fo_compound_depth_sum_right (matches Coq) -/
theorem fo_compound_depth_sum_right : ∀ T1 T2, fo_compound_depth T2 < fo_compound_depth (TSum T1 T2) := by
  omega

/-- Primitive and simple types have depth 0 -/
/-- fo_compound_depth_primitive (matches Coq) -/
theorem fo_compound_depth_primitive : ∀ T, match T with | TProd _ _ | TSum _ _ => False | _ => True end → fo_compound_depth T = 0 := by
  cases ‹_› <;> simp

/-- Depth subtype lemmas -/
/-- ty_depth_fn_arg (matches Coq) -/
theorem ty_depth_fn_arg : ∀ T1 T2 eff, ty_depth T1 < ty_depth (TFn T1 T2 eff) := by
  omega

/-- ty_depth_fn_res (matches Coq) -/
theorem ty_depth_fn_res : ∀ T1 T2 eff, ty_depth T2 < ty_depth (TFn T1 T2 eff) := by
  omega

/-- First-order types have depth 0 for base types -/
/-- first_order_base_depth (matches Coq) -/
theorem first_order_base_depth : ∀ T, first_order_type T = true → ty_depth T ≥ 0 := by
  omega

end RIINA
