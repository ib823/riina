-- Copyright (c) 2026 The RIINA Authors. All rights reserved.

/-!
# RIINA Semantics - Lean 4 Port

Auto-generated port of 02_FORMAL/coq/foundations/Semantics.v (13 theorems).

Generated by scripts/generate-multiprover.py

## Correspondence Table

| Coq Definition | Lean Definition | Status |
|----------------|-----------------|--------|
| fresh_loc | fresh_loc | OK |
| has_effect | has_effect | OK |
| store_has_values | store_has_values | OK |
| store_lookup_above_max | store_lookup_above_max | OK |
| store_lookup_fresh | store_lookup_fresh | OK |
| value_not_step | value_not_step | OK |
| value_does_not_step | value_does_not_step | OK |
| step_deterministic_cfg | step_deterministic_cfg | OK |
| step_deterministic | step_deterministic | OK |
| store_update_lookup_eq | store_update_lookup_eq | OK |
| store_update_lookup_neq | store_update_lookup_neq | OK |
| store_has_values_empty | store_has_values_empty | OK |
| store_update_preserves_values | store_update_preserves_values | OK |
| step_preserves_store_values_aux | step_preserves_store_values_aux | OK |
| step_preserves_store_values | step_preserves_store_values | OK |
| multi_step_preserves_store_values | multi_step_preserves_store_values | OK |
-/

namespace RIINA

/-- fresh_loc (matches Coq: Definition fresh_loc) -/
def fresh_loc (st : store) : loc :=
  S (store_max st)

/-- has_effect (matches Coq: Definition has_effect) -/
def has_effect (eff : effect) (ctx : effect_ctx) : Prop :=
  In eff ctx

/-- store_has_values (matches Coq: Definition store_has_values) -/
def store_has_values (st : store) : Prop :=
  forall l v, store_lookup l st = Some v -> value v

/-- store_lookup_above_max (matches Coq) -/
theorem store_lookup_above_max : ∀ st l, store_max st < l → store_lookup l st = None := by
  cases ‹_› <;> simp

/-- store_lookup_fresh (matches Coq) -/
theorem store_lookup_fresh : ∀ st, store_lookup (fresh_loc st) st = None := by
  simp_all [Bool.and_eq_true]

/-- value_not_step (matches Coq) -/
theorem value_not_step : ∀ v st ctx cfg, value v → ~ ((v, st, ctx) --> cfg) := by
  simp_all [Bool.and_eq_true]

/-- value_does_not_step (matches Coq) -/
theorem value_does_not_step : ∀ v st ctx e' st' ctx', value v → (v, st, ctx) --> (e', st', ctx') → False := by
  simp_all [Bool.and_eq_true]

/-- step_deterministic_cfg (matches Coq) -/
theorem step_deterministic_cfg : ∀ cfg cfg1 cfg2, step cfg cfg1 → step cfg cfg2 → cfg1 = cfg2 := by
  simp_all [Bool.and_eq_true]

/-- step_deterministic (matches Coq) -/
theorem step_deterministic : ∀ t st ctx t1 st1 ctx1 t2 st2 ctx2, (t, st, ctx) --> (t1, st1, ctx1) → (t, st, ctx) --> (t2, st2, ctx2) → t1 = t2 ∧ st1 = st2 ∧ ctx1 = ctx2 := by
  rfl

/-- store_update_lookup_eq (matches Coq) -/
theorem store_update_lookup_eq : ∀ st l v, store_lookup l (store_update l v st) = Some v := by
  cases ‹_› <;> simp

/-- store_update_lookup_neq (matches Coq) -/
theorem store_update_lookup_neq : ∀ st l l' v, l ≠ l' → store_lookup l' (store_update l v st) = store_lookup l' st := by
  cases ‹_› <;> simp

/-- Empty store has the values property -/
/-- store_has_values_empty (matches Coq) -/
theorem store_has_values_empty : store_has_values nil := by
  simp_all [Bool.and_eq_true]

/-- store_update preserves store_has_values when updating with a value -/
/-- store_update_preserves_values (matches Coq) -/
theorem store_update_preserves_values : ∀ st l v, store_has_values st → value v → store_has_values (store_update l v st) := by
  simp_all [Bool.and_eq_true]

/-- Step preserves store_has_values - auxiliary for proving by induction -/
/-- step_preserves_store_values_aux (matches Coq) -/
theorem step_preserves_store_values_aux : ∀ cfg1 cfg2, cfg1 --> cfg2 → store_has_values (snd (fst cfg1)) → store_has_values (snd (fst cfg2)) := by
  simp_all [Bool.and_eq_true]

/-- Step preserves store_has_values -/
/-- step_preserves_store_values (matches Coq) -/
theorem step_preserves_store_values : ∀ e st ctx e' st' ctx', (e, st, ctx) --> (e', st', ctx') → store_has_values st → store_has_values st' := by
  simp_all

/-- Multi-step preserves store_has_values -/
/-- multi_step_preserves_store_values (matches Coq) -/
theorem multi_step_preserves_store_values : ∀ cfg1 cfg2, multi_step cfg1 cfg2 → store_has_values (snd (fst cfg1)) → store_has_values (snd (fst cfg2)) := by
  simp_all [Bool.and_eq_true]

end RIINA
