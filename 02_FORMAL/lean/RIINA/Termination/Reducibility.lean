-- Copyright (c) 2026 The RIINA Authors. All rights reserved.

/-!
# RIINA Reducibility - Lean 4 Port

Auto-generated port of 02_FORMAL/coq/termination/Reducibility.v (9 theorems).

Generated by scripts/generate-multiprover.py

## Correspondence Table

| Coq Definition | Lean Definition | Status |
|----------------|-----------------|--------|
| strongly_normalizing | strongly_normalizing | OK |
| value_SN | value_SN | OK |
| SN_step | SN_step | OK |
| fst_typed_steps_to_value | fst_typed_steps_to_value | OK |
| snd_typed_steps_to_value | snd_typed_steps_to_value | OK |
| case_typed_steps_once | case_typed_steps_once | OK |
| if_typed_steps_once | if_typed_steps_once | OK |
| let_typed_steps_once | let_typed_steps_once | OK |
| handle_typed_steps_once | handle_typed_steps_once | OK |
| app_typed_steps_once | app_typed_steps_once | OK |
-/

namespace RIINA

/-- strongly_normalizing (matches Coq: Definition strongly_normalizing) -/
def strongly_normalizing (e : expr) (st : store) (ctx : effect_ctx) : Prop :=
  SN st ctx e

/-- Values are strongly normalizing (no reduction possible) -/
/-- value_SN (matches Coq) -/
theorem value_SN : ∀ v st ctx, value v → SN st ctx v := by
  simp_all [Bool.and_eq_true]

/-- SN is closed under single-step reduction -/
/-- SN_step (matches Coq) -/
theorem SN_step : ∀ e e' st st' ctx ctx', SN st ctx e → (e, st, ctx) --> (e', st', ctx') → SN st' ctx' e' := by
  simp_all [Bool.and_eq_true]

/-- Fst on typed product value steps to a value in one step -/
/-- fst_typed_steps_to_value (matches Coq) -/
theorem fst_typed_steps_to_value : ∀ v T1 T2 ε Σ st ctx, has_type nil Σ Public v (TProd T1 T2) ε → value v → ∃ v1 st' ctx', (EFst v, st, ctx) --> (v1, st', ctx') ∧ value v1 ∧ st' = st ∧ ctx' = ctx := by
  constructor <;> simp_all [Bool.and_eq_true]

/-- Snd on typed product value steps to a value in one step -/
/-- snd_typed_steps_to_value (matches Coq) -/
theorem snd_typed_steps_to_value : ∀ v T1 T2 ε Σ st ctx, has_type nil Σ Public v (TProd T1 T2) ε → value v → ∃ v2 st' ctx', (ESnd v, st, ctx) --> (v2, st', ctx') ∧ value v2 ∧ st' = st ∧ ctx' = ctx := by
  constructor <;> simp_all [Bool.and_eq_true]

/-- Case on typed sum value steps in one step -/
/-- case_typed_steps_once (matches Coq) -/
theorem case_typed_steps_once : ∀ v T1 T2 ε Σ x1 e1 x2 e2 st ctx, has_type nil Σ Public v (TSum T1 T2) ε → value v → ∃ e' st' ctx', (ECase v x1 e1 x2 e2, st, ctx) --> (e', st', ctx') ∧ st' = st ∧ ctx' = ctx := by
  constructor <;> simp_all [Bool.and_eq_true]

/-- If on typed bool value steps in one step -/
/-- if_typed_steps_once (matches Coq) -/
theorem if_typed_steps_once : ∀ v ε Σ e2 e3 st ctx, has_type nil Σ Public v TBool ε → value v → ∃ e' st' ctx', (EIf v e2 e3, st, ctx) --> (e', st', ctx') ∧ st' = st ∧ ctx' = ctx := by
  constructor <;> simp_all [Bool.and_eq_true]

/-- Let with value steps in one step -/
/-- let_typed_steps_once (matches Coq) -/
theorem let_typed_steps_once : ∀ v x e2 st ctx, value v → ∃ e' st' ctx', (ELet x v e2, st, ctx) --> (e', st', ctx') ∧ st' = st ∧ ctx' = ctx := by
  constructor <;> simp_all [Bool.and_eq_true]

/-- Handle with value steps in one step -/
/-- handle_typed_steps_once (matches Coq) -/
theorem handle_typed_steps_once : ∀ v x h st ctx, value v → ∃ e' st' ctx', (EHandle v x h, st, ctx) --> (e', st', ctx') ∧ st' = st ∧ ctx' = ctx := by
  constructor <;> simp_all [Bool.and_eq_true]

/-- App with typed function value steps in one step -/
/-- app_typed_steps_once (matches Coq) -/
theorem app_typed_steps_once : ∀ f T1 T2 ε ε' Σ a st ctx, has_type nil Σ Public f (TFn T1 T2 ε) ε' → value f → value a → ∃ e' st' ctx', (EApp f a, st, ctx) --> (e', st', ctx') ∧ st' = st ∧ ctx' = ctx := by
  constructor <;> simp_all [Bool.and_eq_true]

end RIINA
