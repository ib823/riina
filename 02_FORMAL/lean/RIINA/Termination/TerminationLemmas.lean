-- SPDX-License-Identifier: MPL-2.0
-- Copyright (c) 2026 The RIINA Authors. See AUTHORS file.

/-!
# RIINA TerminationLemmas - Lean 4 Port

Auto-generated port of 02_FORMAL/coq/termination/TerminationLemmas.v (7 theorems).

Generated by scripts/generate-multiprover.py

## Correspondence Table

| Coq Definition | Lean Definition | Status |
|----------------|-----------------|--------|
| val_rel_0 | val_rel_0 | OK |
| store_rel_0 | store_rel_0 | OK |
| exp_rel_step1_fst_typed | exp_rel_step1_fst_typed | OK |
| exp_rel_step1_snd_typed | exp_rel_step1_snd_typed | OK |
| exp_rel_step1_case_typed | exp_rel_step1_case_typed | OK |
| exp_rel_step1_if_typed | exp_rel_step1_if_typed | OK |
| exp_rel_step1_let_typed | exp_rel_step1_let_typed | OK |
| exp_rel_step1_handle_typed | exp_rel_step1_handle_typed | OK |
| exp_rel_step1_app_typed | exp_rel_step1_app_typed | OK |
-/

namespace RIINA

/-- val_rel_0 (matches Coq: Definition val_rel_0) -/
def val_rel_0 (Σ : store_ty) (T : ty) (v1 v2 : expr) : Prop :=
  True

/-- store_rel_0 (matches Coq: Definition store_rel_0) -/
def store_rel_0 (Σ : store_ty) (st1 st2 : store) : Prop :=
  True

/-- exp_rel_step1_fst_typed (matches Coq) -/
theorem exp_rel_step1_fst_typed : ∀ Σ T1 T2 v v' st1 st2 ctx Σ' ε, has_type nil Σ' Public v (TProd T1 T2) ε → has_type nil Σ' Public v' (TProd T1 T2) ε → value v → value v' → store_rel_0 Σ' st1 st2 → store_ty_extends Σ Σ' → ∃ a1 a2 st1' st2' ctx1' ctx2' Σ'', store_ty_extends Σ' Σ'' ∧ (EFst v, st1, ctx) -->* (a1, st1', ctx1') ∧ (EFst v', st2, ctx) -->* (a2, st2', ctx2') ∧ value a1 ∧ value a2 ∧ val_rel_0 Σ'' T1 a1 a2 ∧ store_rel_0 Σ'' st1' st2' := by
  simp_all [Bool.and_eq_true]

/-- exp_rel_step1_snd_typed (matches Coq) -/
theorem exp_rel_step1_snd_typed : ∀ Σ T1 T2 v v' st1 st2 ctx Σ' ε, has_type nil Σ' Public v (TProd T1 T2) ε → has_type nil Σ' Public v' (TProd T1 T2) ε → value v → value v' → store_rel_0 Σ' st1 st2 → store_ty_extends Σ Σ' → ∃ b1 b2 st1' st2' ctx1' ctx2' Σ'', store_ty_extends Σ' Σ'' ∧ (ESnd v, st1, ctx) -->* (b1, st1', ctx1') ∧ (ESnd v', st2, ctx) -->* (b2, st2', ctx2') ∧ value b1 ∧ value b2 ∧ val_rel_0 Σ'' T2 b1 b2 ∧ store_rel_0 Σ'' st1' st2' := by
  simp_all [Bool.and_eq_true]

/-- exp_rel_step1_case_typed (matches Coq) -/
theorem exp_rel_step1_case_typed : ∀ Σ T T1 T2 v v' x1 e1 e1' x2 e2 e2' st1 st2 ctx Σ' ε, has_type nil Σ' Public v (TSum T1 T2) ε → has_type nil Σ' Public v' (TSum T1 T2) ε → value v → value v' → store_rel_0 Σ' st1 st2 → store_ty_extends Σ Σ' → (∀ v1, value v1 → terminates ([x1 := v1] e1) st1 ctx) → (∀ v2, value v2 → terminates ([x2 := v2] e2) st1 ctx) → (∀ v1', value v1' → terminates ([x1 := v1'] e1') st2 ctx) → (∀ v2', value v2' → terminates ([x2 := v2'] e2') st2 ctx) → ∃ r1 r2 st1' st2' ctx1' ctx2' Σ'', store_ty_extends Σ' Σ'' ∧ (ECase v x1 e1 x2 e2, st1, ctx) -->* (r1, st1', ctx1') ∧ (ECase v' x1 e1' x2 e2', st2, ctx) -->* (r2, st2', ctx2') ∧ value r1 ∧ value r2 ∧ val_rel_0 Σ'' T r1 r2 ∧ store_rel_0 Σ'' st1' st2' := by
  simp_all [Bool.and_eq_true]

/-- exp_rel_step1_if_typed (matches Coq) -/
theorem exp_rel_step1_if_typed : ∀ Σ T v v' e2 e2' e3 e3' st1 st2 ctx Σ' ε, has_type nil Σ' Public v TBool ε → has_type nil Σ' Public v' TBool ε → value v → value v' → store_rel_0 Σ' st1 st2 → store_ty_extends Σ Σ' → terminates e2 st1 ctx → terminates e3 st1 ctx → terminates e2' st2 ctx → terminates e3' st2 ctx → ∃ r1 r2 st1' st2' ctx1' ctx2' Σ'', store_ty_extends Σ' Σ'' ∧ (EIf v e2 e3, st1, ctx) -->* (r1, st1', ctx1') ∧ (EIf v' e2' e3', st2, ctx) -->* (r2, st2', ctx2') ∧ value r1 ∧ value r2 ∧ val_rel_0 Σ'' T r1 r2 ∧ store_rel_0 Σ'' st1' st2' := by
  simp_all [Bool.and_eq_true]

/-- exp_rel_step1_let_typed (matches Coq) -/
theorem exp_rel_step1_let_typed : ∀ Σ T v v' x e2 e2' st1 st2 ctx Σ', value v → value v' → store_rel_0 Σ' st1 st2 → store_ty_extends Σ Σ' → terminates ([x := v] e2) st1 ctx → terminates ([x := v'] e2') st2 ctx → ∃ r1 r2 st1' st2' ctx1' ctx2' Σ'', store_ty_extends Σ' Σ'' ∧ (ELet x v e2, st1, ctx) -->* (r1, st1', ctx1') ∧ (ELet x v' e2', st2, ctx) -->* (r2, st2', ctx2') ∧ value r1 ∧ value r2 ∧ val_rel_0 Σ'' T r1 r2 ∧ store_rel_0 Σ'' st1' st2' := by
  simp_all [Bool.and_eq_true]

/-- exp_rel_step1_handle_typed (matches Coq) -/
theorem exp_rel_step1_handle_typed : ∀ Σ T v v' x h h' st1 st2 ctx Σ', value v → value v' → store_rel_0 Σ' st1 st2 → store_ty_extends Σ Σ' → terminates ([x := v] h) st1 ctx → terminates ([x := v'] h') st2 ctx → ∃ r1 r2 st1' st2' ctx1' ctx2' Σ'', store_ty_extends Σ' Σ'' ∧ (EHandle v x h, st1, ctx) -->* (r1, st1', ctx1') ∧ (EHandle v' x h', st2, ctx) -->* (r2, st2', ctx2') ∧ value r1 ∧ value r2 ∧ val_rel_0 Σ'' T r1 r2 ∧ store_rel_0 Σ'' st1' st2' := by
  simp_all [Bool.and_eq_true]

/-- exp_rel_step1_app_typed (matches Coq) -/
theorem exp_rel_step1_app_typed : ∀ Σ T1 T2 f f' a a' st1 st2 ctx Σ' ε ε', has_type nil Σ' Public f (TFn T1 T2 ε) ε' → has_type nil Σ' Public f' (TFn T1 T2 ε) ε' → value f → value f' → value a → value a' → store_rel_0 Σ' st1 st2 → store_ty_extends Σ Σ' → (∀ x body, f = ELam x T1 body → terminates ([x := a] body) st1 ctx) → (∀ x body, f' = ELam x T1 body → terminates ([x := a'] body) st2 ctx) → ∃ r1 r2 st1' st2' ctx1' ctx2' Σ'', store_ty_extends Σ' Σ'' ∧ (EApp f a, st1, ctx) -->* (r1, st1', ctx1') ∧ (EApp f' a', st2, ctx) -->* (r2, st2', ctx2') ∧ value r1 ∧ value r2 ∧ val_rel_0 Σ'' T2 r1 r2 ∧ store_rel_0 Σ'' st1' st2' := by
  simp_all [Bool.and_eq_true]

end RIINA
