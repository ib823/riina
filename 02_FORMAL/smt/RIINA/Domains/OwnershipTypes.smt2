; Copyright (c) 2026 The RIINA Authors. All rights reserved.
; Copyright (c) 2026 The RIINA Authors.
; Auto-generated from 02_FORMAL/coq/domains/OwnershipTypes.v (20 assertions)
; Generated by scripts/generate-full-stack.py
; Module: OwnershipTypes

(set-logic ALL)
(set-option :produce-models true)

; OwnState (matches Coq: Inductive OwnState)
(declare-datatypes ((OwnState 0)) (((Owned) (Moved) (Borrowed) (MutBorrowed) (Dropped))))

; RefCellState (matches Coq: Inductive RefCellState)
(declare-datatypes ((RefCellState 0)) (((RCUnborrowed) (RCSharedBorrow) (RCMutBorrow))))

; OwnedVar (matches Coq: Record OwnedVar)
(declare-datatypes ((OwnedVar 0))
  (((mk-owned_var (ov_id Int) (ov_state OwnState) (ov_lifetime Lifetime) (ov_is_copy Bool)))))

; Borrow (matches Coq: Record Borrow)
(declare-datatypes ((Borrow 0))
  (((mk-borrow (br_source Int) (br_target Int) (br_mutable Bool) (br_lifetime Lifetime)))))

; OwnCtx (matches Coq: Record OwnCtx)
(declare-datatypes ((OwnCtx 0))
  (((mk-own_ctx (oc_vars list) (oc_borrows list) (oc_current_lifetime Lifetime)))))

; RefCell (matches Coq: Record RefCell)
(declare-datatypes ((RefCell 0))
  (((mk-ref_cell (rc_id Int) (rc_state RefCellState) (rc_lifetime Lifetime)))))

; BoxAlloc (matches Coq: Record BoxAlloc)
(declare-datatypes ((BoxAlloc 0))
  (((mk-box_alloc (box_id Int) (box_allocated Bool) (box_dropped Bool)))))

; lifetime_outlives (matches Coq: Definition lifetime_outlives)
(define-fun lifetime_outlives () Bool Nat)

; is_usable (matches Coq: Definition is_usable)
(define-fun is_usable ((v OwnedVar)) Bool
  true)

; can_mut_borrow (matches Coq: Definition can_mut_borrow)
(define-fun can_mut_borrow ((ctx OwnCtx) (id Int)) Bool
  true)

; can_shared_borrow (matches Coq: Definition can_shared_borrow)
(define-fun can_shared_borrow ((ctx OwnCtx) (id Int)) Bool
  true)

; count_borrows (matches Coq: Definition count_borrows)
(define-fun count_borrows ((ctx OwnCtx) (id Int)) Int
  true)

; count_mut_borrows (matches Coq: Definition count_mut_borrows)
(define-fun count_mut_borrows ((ctx OwnCtx) (id Int)) Int
  true)

; borrow_lifetime_valid (matches Coq: Definition borrow_lifetime_valid)
(define-fun borrow_lifetime_valid ((ctx OwnCtx) (b Borrow)) Bool
  true)

; is_moved (matches Coq: Definition is_moved)
(define-fun is_moved ((v OwnedVar)) Bool
  true)

; is_dropped (matches Coq: Definition is_dropped)
(define-fun is_dropped ((v OwnedVar)) Bool
  true)

; box_new (matches Coq: Definition box_new)
(define-fun box_new ((id Int)) BoxAlloc
  true)

; well_formed_ctx (matches Coq: Definition well_formed_ctx)
(define-fun well_formed_ctx ((ctx OwnCtx)) Prop
  true)

; no_active_borrows (matches Coq: Definition no_active_borrows)
(define-fun no_active_borrows ((ctx OwnCtx) (id Int)) Prop
  true)

; memory_safe (matches Coq: Definition memory_safe)
(define-fun memory_safe ((ctx OwnCtx)) Prop
  true)

; existsb_false_forall (matches Coq: Lemma existsb_false_forall)
(assert (= true true)) ; existsb_false_forall [untranslatable]

; find_var_map_moved (matches Coq: Lemma find_var_map_moved)
(assert (= true true)) ; find_var_map_moved [untranslatable]

; MEM_001_01 (matches Coq: Theorem MEM_001_01)
(assert (= true true)) ; MEM_001_01 [untranslatable]

; MEM_001_02 (matches Coq: Theorem MEM_001_02)
(assert (= true true)) ; MEM_001_02 [untranslatable]

; MEM_001_03 (matches Coq: Theorem MEM_001_03)
(assert (= true true)) ; MEM_001_03 [untranslatable]

; filter_all_false_empty (matches Coq: Lemma filter_all_false_empty)
(assert (= true true)) ; filter_all_false_empty [untranslatable]

; MEM_001_04 (matches Coq: Theorem MEM_001_04)
(assert (= true true)) ; MEM_001_04 [untranslatable]

; MEM_001_05 (matches Coq: Theorem MEM_001_05)
(assert (= true true)) ; MEM_001_05 [untranslatable]

; MEM_001_06 (matches Coq: Theorem MEM_001_06)
(assert (forall ((v OwnedVar)) (=> (= (ov_state v) Moved) (= (is_usable v) false)))) ; MEM_001_06

; MEM_001_07 (matches Coq: Theorem MEM_001_07)
(assert (= true true)) ; MEM_001_07 [untranslatable]

; MEM_001_08 (matches Coq: Theorem MEM_001_08)
(assert (= true true)) ; MEM_001_08 [untranslatable]

; MEM_001_09 (matches Coq: Theorem MEM_001_09)
(assert (= true true)) ; MEM_001_09 [untranslatable]

; find_var_map_dropped (matches Coq: Lemma find_var_map_dropped)
(assert (= true true)) ; find_var_map_dropped [untranslatable]

; MEM_001_10 (matches Coq: Theorem MEM_001_10)
(assert (= true true)) ; MEM_001_10 [untranslatable]

; MEM_001_11 (matches Coq: Theorem MEM_001_11)
(assert (= true true)) ; MEM_001_11 [untranslatable]

; MEM_001_12 (matches Coq: Theorem MEM_001_12)
(assert (forall ((rc RefCell)) (=> (= (rc_state rc) RCMutBorrow) (and (= (refcell_try_borrow rc) None) (= (refcell_try_borrow_mut rc) None))))) ; MEM_001_12

; MEM_001_13 (matches Coq: Theorem MEM_001_13)
(assert (= true true)) ; MEM_001_13 [untranslatable]

; MEM_001_14 (matches Coq: Theorem MEM_001_14)
(assert (= true true)) ; MEM_001_14 [untranslatable]

; MEM_001_15 (matches Coq: Theorem MEM_001_15)
(assert (= true true)) ; MEM_001_15 [untranslatable]

; lifetime_outlives_refl (matches Coq: Theorem lifetime_outlives_refl)
(assert (= true true)) ; lifetime_outlives_refl [untranslatable]

; Verify all assertions are satisfiable
(check-sat)
(exit)
