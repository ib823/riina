; Copyright (c) 2026 The RIINA Authors. All rights reserved.
; Copyright (c) 2026 The RIINA Authors.
; Auto-generated from 02_FORMAL/coq/foundations/Syntax.v (5 assertions)
; Generated by scripts/generate-full-stack.py
; Module: Syntax

(set-logic ALL)
(set-option :produce-models true)

; security_level (matches Coq: Inductive security_level)
(declare-datatypes ((security_level 0)) (((LPublic) (LInternal) (LSession) (LUser) (LSystem) (LSecret))))

; effect (matches Coq: Inductive effect)
(declare-datatypes ((effect 0)) (((EffPure) (EffRead) (EffWrite) (EffFileSystem) (EffNetwork) (EffNetSecure) (EffCrypto) (EffRandom) (EffSystem) (EffTime) (EffProcess) (EffPanel) (EffZirah) (EffBenteng) (EffSandi) (EffMenara) (EffGapura) (CatPure) (CatIO) (CatNetwork) (CatCrypto) (CatSystem) (CatProduct))))

; taint_source (matches Coq: Inductive taint_source)
(declare-datatypes ((taint_source 0)) (((TaintNetworkExternal) (TaintNetworkInternal) (TaintUserInput) (TaintFileSystem) (TaintDatabase) (TaintEnvironment) (TaintGapuraRequest) (TaintZirahEvent) (TaintZirahEndpoint) (TaintBentengBiometric) (TaintSandiSignature) (TaintMenaraDevice))))

; sanitizer (matches Coq: Inductive sanitizer)
(declare-datatypes ((sanitizer 0)) (((SanHtmlEscape) (SanUrlEncode) (SanJsEscape) (SanCssEscape) (SanSqlEscape) (SanSqlParam) (SanXssFilter) (SanPathTraversal) (SanCommandEscape) (SanLdapEscape) (SanXmlEscape) (SanJsonValidation) (SanXmlValidation) (SanEmailValidation) (SanPhoneValidation) (SanLengthBound) (SanRangeBound) (SanRegexMatch) (SanWhitelist) (SanHashVerify) (SanSignatureVerify) (SanMacVerify) (SanGapuraAuth) (SanZirahSession) (SanBentengBiometric) (SanSandiDecrypt) (SanMenaraAttestation) (SanSingle) (SanAnd) (SanSeq))))

; capability_kind (matches Coq: Inductive capability_kind)
(declare-datatypes ((capability_kind 0)) (((CapFileRead) (CapFileWrite) (CapFileExecute) (CapFileDelete) (CapNetConnect) (CapNetListen) (CapNetBind) (CapProcSpawn) (CapProcSignal) (CapSysTime) (CapSysRandom) (CapSysEnv) (CapRootProduct) (CapProductAccess) (CapBasic) (CapRevocable) (CapTimeBound) (CapDelegated))))

; ty (matches Coq: Inductive ty)
(declare-datatypes ((ty 0)) (((TUnit) (TBool) (TInt) (TString) (TBytes) (TFn) (TProd) (TSum) (TList) (TOption) (TRef) (TSecret) (TLabeled) (TTainted) (TSanitized) (TProof) (TCapability) (TCapabilityFull) (TChan) (TSecureChan) (TConstantTime) (TZeroizing) (SessEnd) (SessSend) (SessRecv) (SessSelect) (SessBranch) (SessRec) (SessVar))))

; expr (matches Coq: Inductive expr)
(declare-datatypes ((expr 0)) (((EUnit) (EBool) (EInt) (EString) (ELoc) (EVar) (ELam) (EApp) (EPair) (EFst) (ESnd) (EInl) (EInr) (ECase) (EIf) (ELet) (EPerform) (EHandle) (ERef) (EDeref) (EAssign) (EClassify) (EDeclassify) (EProve) (ERequire) (EGrant))))

; sec_level_num (matches Coq: Definition sec_level_num)
(define-fun sec_level_num ((l security_level)) Int
  true)

; sec_leq (matches Coq: Definition sec_leq)
(define-fun sec_leq () Prop true)

; sec_leq_dec (matches Coq: Definition sec_leq_dec)
(define-fun sec_leq_dec () Bool Nat)

; sec_join (matches Coq: Definition sec_join)
(define-fun sec_join () security_level true)

; sec_meet (matches Coq: Definition sec_meet)
(define-fun sec_meet () security_level true)

; effect_cat (matches Coq: Definition effect_cat)
(define-fun effect_cat ((e effect)) effect_category
  true)

; effect_level (matches Coq: Definition effect_level)
(define-fun effect_level ((e effect)) Int
  true)

; effect_join (matches Coq: Definition effect_join)
(define-fun effect_join () effect true)

; taint_combine (matches Coq: Definition taint_combine)
(define-fun taint_combine () taint_source true)

; TCapabilityOld (matches Coq: Definition TCapabilityOld)
(define-fun TCapabilityOld ((e effect)) ty
  true)

; declass_ok (matches Coq: Definition declass_ok)
(define-fun declass_ok () Prop true)

; effect_join_pure_l (matches Coq: Lemma effect_join_pure_l)
(assert (= true true)) ; effect_join_pure_l [untranslatable]

; effect_join_pure_r (matches Coq: Lemma effect_join_pure_r)
(assert (= true true)) ; effect_join_pure_r [untranslatable]

; value_subst (matches Coq: Lemma value_subst)
(assert (= true true)) ; value_subst [untranslatable]

; declass_ok_subst (matches Coq: Lemma declass_ok_subst)
(assert (= true true)) ; declass_ok_subst [untranslatable]

; value_not_stuck (matches Coq: Lemma value_not_stuck)
(assert (= true true)) ; value_not_stuck [untranslatable]

; Verify all assertions are satisfiable
(check-sat)
(exit)
