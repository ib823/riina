---- MODULE NonInterference_v2_LogicalRelation ----
\* Copyright (c) 2026 The RIINA Authors. All rights reserved.
\* Auto-generated from 02_FORMAL/coq/properties/NonInterference_v2_LogicalRelation.v (147 invariants)
\* Generated by scripts/generate-full-stack.py

EXTENDS Naturals, FiniteSets, Sequences

VARIABLES state

\* Type invariant
TypeOK ==
  /\ state \in BOOLEAN

\* Initial state
Init ==
  /\ state = TRUE

\* closed_except (matches Coq: Definition closed_except)
closed_except(x, e) == TRUE

\* env_rel_n (matches Coq: Definition env_rel_n)
env_rel_n(n, Σ, G) == TRUE

\* env_rel (matches Coq: Definition env_rel)
env_rel(Σ, G) == TRUE

\* rho_closed_on (matches Coq: Definition rho_closed_on)
rho_closed_on(G) == TRUE

\* rho_no_free_all (matches Coq: Definition rho_no_free_all)
rho_no_free_all == TRUE

\* env_typed (matches Coq: Definition env_typed)
env_typed(Σ, Γ) == TRUE

\* fundamental_at_step (matches Coq: Definition fundamental_at_step)
fundamental_at_step(n) == TRUE

\* step_up_at (matches Coq: Definition step_up_at)
step_up_at(n) == TRUE

\* step_up_and_fundamental (matches Coq: Definition step_up_and_fundamental)
step_up_and_fundamental(n) == TRUE

\* closed_expr_lam (matches Coq: Lemma closed_expr_lam)
THEOREM closed_expr_lam == Init => TypeOK

\* closed_expr_pair (matches Coq: Lemma closed_expr_pair)
THEOREM closed_expr_pair == Init => TypeOK

\* closed_expr_pair_inv (matches Coq: Lemma closed_expr_pair_inv)
THEOREM closed_expr_pair_inv == Init => TypeOK

\* closed_expr_inl (matches Coq: Lemma closed_expr_inl)
THEOREM closed_expr_inl == Init => TypeOK

\* closed_expr_inr (matches Coq: Lemma closed_expr_inr)
THEOREM closed_expr_inr == Init => TypeOK

\* val_rel_closed_left_n (matches Coq: Lemma val_rel_closed_left_n)
THEOREM val_rel_closed_left_n == Init => TypeOK

\* val_rel_closed_right_n (matches Coq: Lemma val_rel_closed_right_n)
THEOREM val_rel_closed_right_n == Init => TypeOK

\* val_rel_value_left_n (matches Coq: Lemma val_rel_value_left_n)
THEOREM val_rel_value_left_n == Init => TypeOK

\* val_rel_value_right_n (matches Coq: Lemma val_rel_value_right_n)
THEOREM val_rel_value_right_n == Init => TypeOK

\* val_rel_closed_left (matches Coq: Lemma val_rel_closed_left)
THEOREM val_rel_closed_left == Init => TypeOK

\* val_rel_closed_right (matches Coq: Lemma val_rel_closed_right)
THEOREM val_rel_closed_right == Init => TypeOK

\* val_rel_value_left (matches Coq: Lemma val_rel_value_left)
THEOREM val_rel_value_left == Init => TypeOK

\* val_rel_value_right (matches Coq: Lemma val_rel_value_right)
THEOREM val_rel_value_right == Init => TypeOK

\* free_in_subst_rho (matches Coq: Lemma free_in_subst_rho)
THEOREM free_in_subst_rho == Init => TypeOK

\* env_rel_n_mono_store (matches Coq: Lemma env_rel_n_mono_store)
THEOREM env_rel_n_mono_store == Init => TypeOK

\* env_rel_mono_store (matches Coq: Lemma env_rel_mono_store)
THEOREM env_rel_mono_store == Init => TypeOK

\* env_typed_lookup (matches Coq: Lemma env_typed_lookup)
THEOREM env_typed_lookup == Init => TypeOK

\* typing_nil_closed (matches Coq: Lemma typing_nil_closed)
THEOREM typing_nil_closed == Init => TypeOK

\* env_typed_closed (matches Coq: Lemma env_typed_closed)
THEOREM env_typed_closed == Init => TypeOK

\* env_typed_extend (matches Coq: Lemma env_typed_extend)
THEOREM env_typed_extend == Init => TypeOK

\* value_subst_rho (matches Coq: Lemma value_subst_rho)
THEOREM value_subst_rho == Init => TypeOK

\* declass_ok_subst_rho (matches Coq: Lemma declass_ok_subst_rho)
THEOREM declass_ok_subst_rho == Init => TypeOK

\* subst_rho_typing_general (matches Coq: Lemma subst_rho_typing_general)
THEOREM subst_rho_typing_general == Init => TypeOK

\* subst_rho_preserves_typing (matches Coq: Lemma subst_rho_preserves_typing)
THEOREM subst_rho_preserves_typing == Init => TypeOK

\* env_rel_implies_env_typed (matches Coq: Lemma env_rel_implies_env_typed)
THEOREM env_rel_implies_env_typed == Init => TypeOK

\* lam_typing_from_env_rel (matches Coq: Lemma lam_typing_from_env_rel)
THEOREM lam_typing_from_env_rel == Init => TypeOK

\* val_rel_at_type_store_weaken (matches Coq: Lemma val_rel_at_type_store_weaken)
THEOREM val_rel_at_type_store_weaken == Init => TypeOK

\* val_rel_n_store_weaken (matches Coq: Lemma val_rel_n_store_weaken)
THEOREM val_rel_n_store_weaken == Init => TypeOK

\* closed_expr_unit_early (matches Coq: Lemma closed_expr_unit_early)
THEOREM closed_expr_unit_early == Init => TypeOK

\* closed_expr_loc_early (matches Coq: Lemma closed_expr_loc_early)
THEOREM closed_expr_loc_early == Init => TypeOK

\* val_rel_n_loc_general (matches Coq: Lemma val_rel_n_loc_general)
THEOREM val_rel_n_loc_general == Init => TypeOK

\* val_rel_n_unit_general (matches Coq: Lemma val_rel_n_unit_general)
THEOREM val_rel_n_unit_general == Init => TypeOK

\* store_max_update_single (matches Coq: Lemma store_max_update_single)
THEOREM store_max_update_single == Init => TypeOK

\* store_max_update_eq (matches Coq: Lemma store_max_update_eq)
THEOREM store_max_update_eq == Init => TypeOK

\* store_rel_n_alloc_fresh (matches Coq: Lemma store_rel_n_alloc_fresh)
THEOREM store_rel_n_alloc_fresh == Init => TypeOK

\* store_vals_rel_alloc_fresh (matches Coq: Lemma store_vals_rel_alloc_fresh)
THEOREM store_vals_rel_alloc_fresh == Init => TypeOK

\* val_rel_n_fo_extract (matches Coq: Lemma val_rel_n_fo_extract)
THEOREM val_rel_n_fo_extract == Init => TypeOK

\* stores_agree_low_fo_alloc_fresh (matches Coq: Lemma stores_agree_low_fo_alloc_fresh)
THEOREM stores_agree_low_fo_alloc_fresh == Init => TypeOK

\* store_rel_n_update_existing (matches Coq: Lemma store_rel_n_update_existing)
THEOREM store_rel_n_update_existing == Init => TypeOK

\* store_vals_rel_update_existing (matches Coq: Lemma store_vals_rel_update_existing)
THEOREM store_vals_rel_update_existing == Init => TypeOK

\* stores_agree_low_fo_update_existing (matches Coq: Lemma stores_agree_low_fo_update_existing)
THEOREM stores_agree_low_fo_update_existing == Init => TypeOK

\* val_rel_n_to_val_rel (matches Coq: Lemma val_rel_n_to_val_rel)
THEOREM val_rel_n_to_val_rel == Init => TypeOK

\* val_rel_n_to_val_rel_any (matches Coq: Lemma val_rel_n_to_val_rel_any)
THEOREM val_rel_n_to_val_rel_any == Init => TypeOK

\* env_rel_rho_closed (matches Coq: Lemma env_rel_rho_closed)
THEOREM env_rel_rho_closed == Init => TypeOK

\* lam_closedness_contradiction (matches Coq: Lemma lam_closedness_contradiction)
THEOREM lam_closedness_contradiction == Init => TypeOK

\* lam_closedness_contradiction2 (matches Coq: Lemma lam_closedness_contradiction2)
THEOREM lam_closedness_contradiction2 == Init => TypeOK

\* rho_no_free_all_single (matches Coq: Lemma rho_no_free_all_single)
THEOREM rho_no_free_all_single == Init => TypeOK

\* env_rel_closed_left (matches Coq: Lemma env_rel_closed_left)
THEOREM env_rel_closed_left == Init => TypeOK

\* env_rel_closed_right (matches Coq: Lemma env_rel_closed_right)
THEOREM env_rel_closed_right == Init => TypeOK

\* closed_except_subst_rho_shadow (matches Coq: Lemma closed_except_subst_rho_shadow)
THEOREM closed_except_subst_rho_shadow == Init => TypeOK

\* subst_not_free (matches Coq: Lemma subst_not_free)
THEOREM subst_not_free == Init => TypeOK

\* rho_shadow_id (matches Coq: Lemma rho_shadow_id)
THEOREM rho_shadow_id == Init => TypeOK

\* rho_shadow_identity (matches Coq: Lemma rho_shadow_identity)
THEOREM rho_shadow_identity == Init => TypeOK

\* subst_rho_identity (matches Coq: Lemma subst_rho_identity)
THEOREM subst_rho_identity == Init => TypeOK

\* subst_rho_id (matches Coq: Lemma subst_rho_id)
THEOREM subst_rho_id == Init => TypeOK

\* rho_shadow_single_eq (matches Coq: Lemma rho_shadow_single_eq)
THEOREM rho_shadow_single_eq == Init => TypeOK

\* rho_shadow_single_id (matches Coq: Lemma rho_shadow_single_id)
THEOREM rho_shadow_single_id == Init => TypeOK

\* subst_rho_single (matches Coq: Lemma subst_rho_single)
THEOREM subst_rho_single == Init => TypeOK

\* rho_shadow_extend_same (matches Coq: Lemma rho_shadow_extend_same)
THEOREM rho_shadow_extend_same == Init => TypeOK

\* rho_shadow_shadow_same (matches Coq: Lemma rho_shadow_shadow_same)
THEOREM rho_shadow_shadow_same == Init => TypeOK

\* rho_shadow_shadow_comm (matches Coq: Lemma rho_shadow_shadow_comm)
THEOREM rho_shadow_shadow_comm == Init => TypeOK

\* rho_shadow_extend_comm (matches Coq: Lemma rho_shadow_extend_comm)
THEOREM rho_shadow_extend_comm == Init => TypeOK

\* rho_no_free_extend (matches Coq: Lemma rho_no_free_extend)
THEOREM rho_no_free_extend == Init => TypeOK

\* rho_no_free_shadow (matches Coq: Lemma rho_no_free_shadow)
THEOREM rho_no_free_shadow == Init => TypeOK

\* subst_rho_extend (matches Coq: Lemma subst_rho_extend)
THEOREM subst_rho_extend == Init => TypeOK

\* env_rel_empty_n (matches Coq: Lemma env_rel_empty_n)
THEOREM env_rel_empty_n == Init => TypeOK

\* env_rel_empty (matches Coq: Lemma env_rel_empty)
THEOREM env_rel_empty == Init => TypeOK

\* env_rel_extend_n (matches Coq: Lemma env_rel_extend_n)
THEOREM env_rel_extend_n == Init => TypeOK

\* env_rel_extend (matches Coq: Lemma env_rel_extend)
THEOREM env_rel_extend == Init => TypeOK

\* multi_step_trans (matches Coq: Lemma multi_step_trans)
THEOREM multi_step_trans == Init => TypeOK

\* multi_step_app1 (matches Coq: Lemma multi_step_app1)
THEOREM multi_step_app1 == Init => TypeOK

\* multi_step_app2 (matches Coq: Lemma multi_step_app2)
THEOREM multi_step_app2 == Init => TypeOK

\* multi_step_pair1 (matches Coq: Lemma multi_step_pair1)
THEOREM multi_step_pair1 == Init => TypeOK

\* multi_step_pair2 (matches Coq: Lemma multi_step_pair2)
THEOREM multi_step_pair2 == Init => TypeOK

\* multi_step_fst (matches Coq: Lemma multi_step_fst)
THEOREM multi_step_fst == Init => TypeOK

\* multi_step_snd (matches Coq: Lemma multi_step_snd)
THEOREM multi_step_snd == Init => TypeOK

\* multi_step_inl (matches Coq: Lemma multi_step_inl)
THEOREM multi_step_inl == Init => TypeOK

\* multi_step_inr (matches Coq: Lemma multi_step_inr)
THEOREM multi_step_inr == Init => TypeOK

\* multi_step_case (matches Coq: Lemma multi_step_case)
THEOREM multi_step_case == Init => TypeOK

\* multi_step_if (matches Coq: Lemma multi_step_if)
THEOREM multi_step_if == Init => TypeOK

\* multi_step_let (matches Coq: Lemma multi_step_let)
THEOREM multi_step_let == Init => TypeOK

\* multi_step_classify (matches Coq: Lemma multi_step_classify)
THEOREM multi_step_classify == Init => TypeOK

\* multi_step_prove (matches Coq: Lemma multi_step_prove)
THEOREM multi_step_prove == Init => TypeOK

\* multi_step_require (matches Coq: Lemma multi_step_require)
THEOREM multi_step_require == Init => TypeOK

\* multi_step_grant (matches Coq: Lemma multi_step_grant)
THEOREM multi_step_grant == Init => TypeOK

\* multi_step_perform (matches Coq: Lemma multi_step_perform)
THEOREM multi_step_perform == Init => TypeOK

\* multi_step_handle (matches Coq: Lemma multi_step_handle)
THEOREM multi_step_handle == Init => TypeOK

\* multi_step_ref (matches Coq: Lemma multi_step_ref)
THEOREM multi_step_ref == Init => TypeOK

\* multi_step_deref (matches Coq: Lemma multi_step_deref)
THEOREM multi_step_deref == Init => TypeOK

\* multi_step_assign1 (matches Coq: Lemma multi_step_assign1)
THEOREM multi_step_assign1 == Init => TypeOK

\* multi_step_assign2 (matches Coq: Lemma multi_step_assign2)
THEOREM multi_step_assign2 == Init => TypeOK

\* exp_rel_of_val_rel (matches Coq: Lemma exp_rel_of_val_rel)
THEOREM exp_rel_of_val_rel == Init => TypeOK

\* exp_rel_of_val_rel_step (matches Coq: Lemma exp_rel_of_val_rel_step)
THEOREM exp_rel_of_val_rel_step == Init => TypeOK

\* exp_rel_of_val_rel_n (matches Coq: Lemma exp_rel_of_val_rel_n)
THEOREM exp_rel_of_val_rel_n == Init => TypeOK

\* value_pair_inv (matches Coq: Lemma value_pair_inv)
THEOREM value_pair_inv == Init => TypeOK

\* value_inl_inv (matches Coq: Lemma value_inl_inv)
THEOREM value_inl_inv == Init => TypeOK

\* value_inr_inv (matches Coq: Lemma value_inr_inv)
THEOREM value_inr_inv == Init => TypeOK

\* closed_expr_inl_inv (matches Coq: Lemma closed_expr_inl_inv)
THEOREM closed_expr_inl_inv == Init => TypeOK

\* closed_expr_inr_inv (matches Coq: Lemma closed_expr_inr_inv)
THEOREM closed_expr_inr_inv == Init => TypeOK

\* val_rel_n_prod_decompose (matches Coq: Lemma val_rel_n_prod_decompose)
THEOREM val_rel_n_prod_decompose == Init => TypeOK

\* val_rel_n_of_first_order (matches Coq: Lemma val_rel_n_of_first_order)
THEOREM val_rel_n_of_first_order == Init => TypeOK

\* val_rel_n_to_val_rel_fo (matches Coq: Lemma val_rel_n_to_val_rel_fo)
THEOREM val_rel_n_to_val_rel_fo == Init => TypeOK

\* val_rel_at_type_to_val_rel_fo (matches Coq: Lemma val_rel_at_type_to_val_rel_fo)
THEOREM val_rel_at_type_to_val_rel_fo == Init => TypeOK

\* has_type_pair_inv (matches Coq: Lemma has_type_pair_inv)
THEOREM has_type_pair_inv == Init => TypeOK

\* val_rel_n_prod_fst (matches Coq: Lemma val_rel_n_prod_fst)
THEOREM val_rel_n_prod_fst == Init => TypeOK

\* val_rel_n_prod_snd (matches Coq: Lemma val_rel_n_prod_snd)
THEOREM val_rel_n_prod_snd == Init => TypeOK

\* val_rel_n_typing_ho (matches Coq: Lemma val_rel_n_typing_ho)
THEOREM val_rel_n_typing_ho == Init => TypeOK

\* has_type_inl_inv (matches Coq: Lemma has_type_inl_inv)
THEOREM has_type_inl_inv == Init => TypeOK

\* has_type_inr_inv (matches Coq: Lemma has_type_inr_inv)
THEOREM has_type_inr_inv == Init => TypeOK

\* has_type_classify_inv (matches Coq: Lemma has_type_classify_inv)
THEOREM has_type_classify_inv == Init => TypeOK

\* has_type_prove_inv (matches Coq: Lemma has_type_prove_inv)
THEOREM has_type_prove_inv == Init => TypeOK

\* val_rel_n_prod_compose (matches Coq: Lemma val_rel_n_prod_compose)
THEOREM val_rel_n_prod_compose == Init => TypeOK

\* val_rel_n_from_prod_fst (matches Coq: Lemma val_rel_n_from_prod_fst)
THEOREM val_rel_n_from_prod_fst == Init => TypeOK

\* val_rel_n_from_prod_snd (matches Coq: Lemma val_rel_n_from_prod_snd)
THEOREM val_rel_n_from_prod_snd == Init => TypeOK

\* val_rel_n_sum_inl (matches Coq: Lemma val_rel_n_sum_inl)
THEOREM val_rel_n_sum_inl == Init => TypeOK

\* val_rel_n_sum_inr (matches Coq: Lemma val_rel_n_sum_inr)
THEOREM val_rel_n_sum_inr == Init => TypeOK

\* val_rel_n_sum_decompose (matches Coq: Lemma val_rel_n_sum_decompose)
THEOREM val_rel_n_sum_decompose == Init => TypeOK

\* val_rel_n_from_sum_inl (matches Coq: Lemma val_rel_n_from_sum_inl)
THEOREM val_rel_n_from_sum_inl == Init => TypeOK

\* val_rel_n_from_sum_inr (matches Coq: Lemma val_rel_n_from_sum_inr)
THEOREM val_rel_n_from_sum_inr == Init => TypeOK

\* val_rel_n_prod_fst_at (matches Coq: Lemma val_rel_n_prod_fst_at)
THEOREM val_rel_n_prod_fst_at == Init => TypeOK

\* val_rel_n_prod_snd_at (matches Coq: Lemma val_rel_n_prod_snd_at)
THEOREM val_rel_n_prod_snd_at == Init => TypeOK

\* closed_expr_unit (matches Coq: Lemma closed_expr_unit)
THEOREM closed_expr_unit == Init => TypeOK

\* closed_expr_bool (matches Coq: Lemma closed_expr_bool)
THEOREM closed_expr_bool == Init => TypeOK

\* closed_expr_int (matches Coq: Lemma closed_expr_int)
THEOREM closed_expr_int == Init => TypeOK

\* closed_expr_string (matches Coq: Lemma closed_expr_string)
THEOREM closed_expr_string == Init => TypeOK

\* closed_expr_loc (matches Coq: Lemma closed_expr_loc)
THEOREM closed_expr_loc == Init => TypeOK

\* val_rel_unit (matches Coq: Lemma val_rel_unit)
THEOREM val_rel_unit == Init => TypeOK

\* val_rel_bool (matches Coq: Lemma val_rel_bool)
THEOREM val_rel_bool == Init => TypeOK

\* val_rel_n_bool_eq (matches Coq: Lemma val_rel_n_bool_eq)
THEOREM val_rel_n_bool_eq == Init => TypeOK

\* val_rel_int (matches Coq: Lemma val_rel_int)
THEOREM val_rel_int == Init => TypeOK

\* val_rel_n_classify (matches Coq: Lemma val_rel_n_classify)
THEOREM val_rel_n_classify == Init => TypeOK

\* val_rel_n_prove (matches Coq: Lemma val_rel_n_prove)
THEOREM val_rel_n_prove == Init => TypeOK

\* val_rel_string (matches Coq: Lemma val_rel_string)
THEOREM val_rel_string == Init => TypeOK

\* val_rel_loc (matches Coq: Lemma val_rel_loc)
THEOREM val_rel_loc == Init => TypeOK

\* fundamental_at_0 (matches Coq: Lemma fundamental_at_0)
THEOREM fundamental_at_0 == Init => TypeOK

\* step_up_at_0 (matches Coq: Lemma step_up_at_0)
THEOREM step_up_at_0 == Init => TypeOK

\* multi_step_preservation_aux (matches Coq: Lemma multi_step_preservation_aux)
THEOREM multi_step_preservation_aux == Init => TypeOK

\* multi_step_preservation (matches Coq: Lemma multi_step_preservation)
THEOREM multi_step_preservation == Init => TypeOK

\* has_type_level_irrelevant (matches Coq: Lemma has_type_level_irrelevant)
THEOREM has_type_level_irrelevant == Init => TypeOK

\* store_wf_fresh_not_in_ty (matches Coq: Lemma store_wf_fresh_not_in_ty)
THEOREM store_wf_fresh_not_in_ty == Init => TypeOK

\* store_rel_n_same_fresh (matches Coq: Lemma store_rel_n_same_fresh)
THEOREM store_rel_n_same_fresh == Init => TypeOK

\* logical_relation (matches Coq: Theorem logical_relation)
THEOREM logical_relation == Init => TypeOK

\* step_up_and_fundamental_mutual (matches Coq: Theorem step_up_and_fundamental_mutual)
THEOREM step_up_and_fundamental_mutual == Init => TypeOK

\* val_rel_closed (matches Coq: Lemma val_rel_closed)
THEOREM val_rel_closed == Init => TypeOK

\* env_rel_single (matches Coq: Lemma env_rel_single)
THEOREM env_rel_single == Init => TypeOK

\* non_interference_stmt (matches Coq: Theorem non_interference_stmt)
THEOREM non_interference_stmt == Init => TypeOK

\* subst_rho_declassify_dist (matches Coq: Lemma subst_rho_declassify_dist)
THEOREM subst_rho_declassify_dist == Init => TypeOK

\* Next-state relation
Next == UNCHANGED <<state>>

\* Specification
Spec == Init /\ [][Next]_<<state>>

====
