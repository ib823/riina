---- MODULE MaximumAxiomElimination ----
\* SPDX-License-Identifier: MPL-2.0
\* Copyright (c) 2026 The RIINA Authors.
\* Auto-generated from 02_FORMAL/coq/properties/MaximumAxiomElimination.v (53 invariants)
\* Generated by scripts/generate-full-stack.py

EXTENDS Naturals, FiniteSets, Sequences

\* sec_label (matches Coq: Inductive sec_label)
CONSTANTS L, H

\* ty (matches Coq: Inductive ty)
CONSTANTS TUnit, TBool, TNat, TRef, TProd, TSum, TArrow

\* expr (matches Coq: Inductive expr)
CONSTANTS EVar, EUnit, EBool, ENat, ELoc, EPair, EFst, ESnd, EInl, EInr, ELam, EApp, ERef, EDeref, EAssign, EIf, ELet

VARIABLES state

\* Type invariant
TypeOK ==
  /\ state \in BOOLEAN

\* Initial state
Init ==
  /\ state = TRUE

\* label_leq (matches Coq: Definition label_leq)
label_leq == TRUE

\* store_empty (matches Coq: Definition store_empty)
store_empty == TRUE

\* store_ty_empty (matches Coq: Definition store_ty_empty)
store_ty_empty == TRUE

\* store_update (matches Coq: Definition store_update)
store_update(σ, l, v) == TRUE

\* store_ty_update (matches Coq: Definition store_ty_update)
store_ty_update(Σ, l, T, lab) == TRUE

\* store_ty_extends (matches Coq: Definition store_ty_extends)
store_ty_extends == TRUE

\* store_rel_n (matches Coq: Definition store_rel_n)
store_rel_n(n, Σ) == TRUE

\* exp_rel_n (matches Coq: Definition exp_rel_n)
exp_rel_n(n, Σ, T) == TRUE

\* label_join (matches Coq: Definition label_join)
label_join == TRUE

\* label_leq_refl (matches Coq: Lemma label_leq_refl)
THEOREM label_leq_refl == Init => TypeOK

\* label_leq_trans (matches Coq: Lemma label_leq_trans)
THEOREM label_leq_trans == Init => TypeOK

\* label_leq_antisym (matches Coq: Lemma label_leq_antisym)
THEOREM label_leq_antisym == Init => TypeOK

\* ty_size_pos (matches Coq: Lemma ty_size_pos)
THEOREM ty_size_pos == Init => TypeOK

\* ty_size_prod_left (matches Coq: Lemma ty_size_prod_left)
THEOREM ty_size_prod_left == Init => TypeOK

\* ty_size_prod_right (matches Coq: Lemma ty_size_prod_right)
THEOREM ty_size_prod_right == Init => TypeOK

\* ty_size_sum_left (matches Coq: Lemma ty_size_sum_left)
THEOREM ty_size_sum_left == Init => TypeOK

\* ty_size_sum_right (matches Coq: Lemma ty_size_sum_right)
THEOREM ty_size_sum_right == Init => TypeOK

\* store_update_lookup_eq (matches Coq: Lemma store_update_lookup_eq)
THEOREM store_update_lookup_eq == Init => TypeOK

\* store_update_lookup_neq (matches Coq: Lemma store_update_lookup_neq)
THEOREM store_update_lookup_neq == Init => TypeOK

\* store_ty_update_lookup_eq (matches Coq: Lemma store_ty_update_lookup_eq)
THEOREM store_ty_update_lookup_eq == Init => TypeOK

\* store_ty_update_lookup_neq (matches Coq: Lemma store_ty_update_lookup_neq)
THEOREM store_ty_update_lookup_neq == Init => TypeOK

\* store_ty_extends_refl (matches Coq: Lemma store_ty_extends_refl)
THEOREM store_ty_extends_refl == Init => TypeOK

\* store_ty_extends_trans (matches Coq: Lemma store_ty_extends_trans)
THEOREM store_ty_extends_trans == Init => TypeOK

\* val_rel_n_zero (matches Coq: Lemma val_rel_n_zero)
THEOREM val_rel_n_zero == Init => TypeOK

\* val_rel_n_unit (matches Coq: Lemma val_rel_n_unit)
THEOREM val_rel_n_unit == Init => TypeOK

\* val_rel_n_bool (matches Coq: Lemma val_rel_n_bool)
THEOREM val_rel_n_bool == Init => TypeOK

\* val_rel_n_nat (matches Coq: Lemma val_rel_n_nat)
THEOREM val_rel_n_nat == Init => TypeOK

\* val_rel_n_ref (matches Coq: Lemma val_rel_n_ref)
THEOREM val_rel_n_ref == Init => TypeOK

\* val_rel_n_ref_same_loc (matches Coq: Lemma val_rel_n_ref_same_loc)
THEOREM val_rel_n_ref_same_loc == Init => TypeOK

\* val_rel_n_cumulative (matches Coq: Lemma val_rel_n_cumulative)
THEOREM val_rel_n_cumulative == Init => TypeOK

\* val_rel_n_step_down (matches Coq: Lemma val_rel_n_step_down)
THEOREM val_rel_n_step_down == Init => TypeOK

\* val_rel_n_value_left (matches Coq: Lemma val_rel_n_value_left)
THEOREM val_rel_n_value_left == Init => TypeOK

\* val_rel_n_value_right (matches Coq: Lemma val_rel_n_value_right)
THEOREM val_rel_n_value_right == Init => TypeOK

\* val_rel_n_prod (matches Coq: Lemma val_rel_n_prod)
THEOREM val_rel_n_prod == Init => TypeOK

\* val_rel_n_inl (matches Coq: Lemma val_rel_n_inl)
THEOREM val_rel_n_inl == Init => TypeOK

\* val_rel_n_inr (matches Coq: Lemma val_rel_n_inr)
THEOREM val_rel_n_inr == Init => TypeOK

\* val_rel_n_lam (matches Coq: Lemma val_rel_n_lam)
THEOREM val_rel_n_lam == Init => TypeOK

\* val_rel_n_fo_step_independent (matches Coq: Lemma val_rel_n_fo_step_independent)
THEOREM val_rel_n_fo_step_independent == Init => TypeOK

\* store_rel_n_zero (matches Coq: Lemma store_rel_n_zero)
THEOREM store_rel_n_zero == Init => TypeOK

\* store_rel_n_step_down (matches Coq: Lemma store_rel_n_step_down)
THEOREM store_rel_n_step_down == Init => TypeOK

\* store_rel_n_empty (matches Coq: Lemma store_rel_n_empty)
THEOREM store_rel_n_empty == Init => TypeOK

\* store_update_preserves_rel (matches Coq: Lemma store_update_preserves_rel)
THEOREM store_update_preserves_rel == Init => TypeOK

\* store_ty_extends_antisym (matches Coq: Lemma store_ty_extends_antisym)
THEOREM store_ty_extends_antisym == Init => TypeOK

\* store_ty_update_extends (matches Coq: Lemma store_ty_update_extends)
THEOREM store_ty_update_extends == Init => TypeOK

\* store_lookup_deterministic (matches Coq: Lemma store_lookup_deterministic)
THEOREM store_lookup_deterministic == Init => TypeOK

\* store_ty_lookup_deterministic (matches Coq: Lemma store_ty_lookup_deterministic)
THEOREM store_ty_lookup_deterministic == Init => TypeOK

\* store_update_idem (matches Coq: Lemma store_update_idem)
THEOREM store_update_idem == Init => TypeOK

\* store_update_comm (matches Coq: Lemma store_update_comm)
THEOREM store_update_comm == Init => TypeOK

\* exp_rel_n_zero (matches Coq: Lemma exp_rel_n_zero)
THEOREM exp_rel_n_zero == Init => TypeOK

\* exp_rel_n_unit_expr (matches Coq: Lemma exp_rel_n_unit_expr)
THEOREM exp_rel_n_unit_expr == Init => TypeOK

\* exp_rel_n_step_down (matches Coq: Lemma exp_rel_n_step_down)
THEOREM exp_rel_n_step_down == Init => TypeOK

\* val_rel_implies_exp_rel (matches Coq: Lemma val_rel_implies_exp_rel)
THEOREM val_rel_implies_exp_rel == Init => TypeOK

\* exp_rel_n_bool_expr (matches Coq: Lemma exp_rel_n_bool_expr)
THEOREM exp_rel_n_bool_expr == Init => TypeOK

\* label_join_comm (matches Coq: Lemma label_join_comm)
THEOREM label_join_comm == Init => TypeOK

\* label_join_assoc (matches Coq: Lemma label_join_assoc)
THEOREM label_join_assoc == Init => TypeOK

\* label_join_idem (matches Coq: Lemma label_join_idem)
THEOREM label_join_idem == Init => TypeOK

\* ty_eq_dec (matches Coq: Lemma ty_eq_dec)
THEOREM ty_eq_dec == Init => TypeOK

\* first_order_prod_components (matches Coq: Lemma first_order_prod_components)
THEOREM first_order_prod_components == Init => TypeOK

\* first_order_sum_components (matches Coq: Lemma first_order_sum_components)
THEOREM first_order_sum_components == Init => TypeOK

\* fo_depth_prod (matches Coq: Lemma fo_depth_prod)
THEOREM fo_depth_prod == Init => TypeOK

\* fo_depth_sum (matches Coq: Lemma fo_depth_sum)
THEOREM fo_depth_sum == Init => TypeOK

\* fo_depth_primitive (matches Coq: Lemma fo_depth_primitive)
THEOREM fo_depth_primitive == Init => TypeOK

\* Next-state relation
Next == UNCHANGED <<state>>

\* Specification
Spec == Init /\ [][Next]_<<state>>

====
