---- MODULE InterruptVirtualization ----
\* Copyright (c) 2026 The RIINA Authors. All rights reserved.
\* Auto-generated from 02_FORMAL/coq/domains/security_foundation/InterruptVirtualization.v (21 invariants)
\* Generated by scripts/generate-full-stack.py

EXTENDS Naturals, FiniteSets, Sequences

\* VMId (matches Coq: Inductive VMId)
CONSTANTS VM

\* Interrupt (matches Coq: Inductive Interrupt)
CONSTANTS IRQ

\* InterruptSource (matches Coq: Inductive InterruptSource)
CONSTANTS DeviceSource, TimerSource, IPISource

\* VirtualMachine (matches Coq: Record VirtualMachine)
VARIABLES vm_id, vm_assigned_irqs

\* InterruptState (matches Coq: Record InterruptState)
VARIABLES irq_assignments, ipi_allowed

\* InterruptPriority (matches Coq: Record InterruptPriority)
VARIABLES irq_number, irq_priority, irq_enabled, irq_pending

\* InterruptController (matches Coq: Record InterruptController)
VARIABLES ctrl_irqs, ctrl_mask_threshold

\* Type invariant
TypeOK ==
  /\ vm_id \in BOOLEAN
  /\ vm_assigned_irqs \in BOOLEAN
  /\ irq_assignments \in BOOLEAN
  /\ ipi_allowed \in BOOLEAN
  /\ irq_number \in BOOLEAN
  /\ irq_priority \in BOOLEAN
  /\ irq_enabled \in BOOLEAN
  /\ irq_pending \in BOOLEAN
  /\ ctrl_irqs \in BOOLEAN
  /\ ctrl_mask_threshold \in BOOLEAN

\* Initial state
Init ==
  /\ vm_id = TRUE
  /\ vm_assigned_irqs = TRUE
  /\ irq_assignments = TRUE
  /\ ipi_allowed = TRUE
  /\ irq_number = TRUE
  /\ irq_priority = TRUE
  /\ irq_enabled = TRUE
  /\ irq_pending = TRUE
  /\ ctrl_irqs = TRUE
  /\ ctrl_mask_threshold = TRUE

\* vm_owns_irq (matches Coq: Definition vm_owns_irq)
vm_owns_irq(st, vm, irq) == TRUE

\* ipi_authorized (matches Coq: Definition ipi_authorized)
ipi_authorized(st) == TRUE

\* authorized_injection (matches Coq: Definition authorized_injection)
authorized_injection(st, source, target) == TRUE

\* can_inject (matches Coq: Definition can_inject)
can_inject(st, vm1, irq, vm2) == TRUE

\* irq_deliverable (matches Coq: Definition irq_deliverable)
irq_deliverable(ctrl, irq) == TRUE

\* interrupt_injection_authorized (matches Coq: Theorem interrupt_injection_authorized)
THEOREM interrupt_injection_authorized == Init => TypeOK

\* interrupt_isolation (matches Coq: Theorem interrupt_isolation)
THEOREM interrupt_isolation == Init => TypeOK

\* device_irq_unique_owner (matches Coq: Theorem device_irq_unique_owner)
THEOREM device_irq_unique_owner == Init => TypeOK

\* timer_interrupt_local (matches Coq: Theorem timer_interrupt_local)
THEOREM timer_interrupt_local == Init => TypeOK

\* ipi_requires_authorization (matches Coq: Theorem ipi_requires_authorization)
THEOREM ipi_requires_authorization == Init => TypeOK

\* unauthorized_ipi_blocked (matches Coq: Theorem unauthorized_ipi_blocked)
THEOREM unauthorized_ipi_blocked == Init => TypeOK

\* self_injection_allowed (matches Coq: Theorem self_injection_allowed)
THEOREM self_injection_allowed == Init => TypeOK

\* masked_irq_not_deliverable (matches Coq: Theorem masked_irq_not_deliverable)
THEOREM masked_irq_not_deliverable == Init => TypeOK

\* disabled_irq_not_deliverable (matches Coq: Theorem disabled_irq_not_deliverable)
THEOREM disabled_irq_not_deliverable == Init => TypeOK

\* non_pending_irq_not_deliverable (matches Coq: Theorem non_pending_irq_not_deliverable)
THEOREM non_pending_irq_not_deliverable == Init => TypeOK

\* unknown_irq_not_deliverable (matches Coq: Theorem unknown_irq_not_deliverable)
THEOREM unknown_irq_not_deliverable == Init => TypeOK

\* no_auth_no_injection (matches Coq: Theorem no_auth_no_injection)
THEOREM no_auth_no_injection == Init => TypeOK

\* device_irq_requires_ownership (matches Coq: Theorem device_irq_requires_ownership)
THEOREM device_irq_requires_ownership == Init => TypeOK

\* cross_vm_requires_ipi (matches Coq: Theorem cross_vm_requires_ipi)
THEOREM cross_vm_requires_ipi == Init => TypeOK

\* ipi_authorization_directional (matches Coq: Theorem ipi_authorization_directional)
THEOREM ipi_authorization_directional == Init => TypeOK

\* empty_ipi_blocks_cross_vm (matches Coq: Theorem empty_ipi_blocks_cross_vm)
THEOREM empty_ipi_blocks_cross_vm == Init => TypeOK

\* empty_assignments_blocks_device_irqs (matches Coq: Theorem empty_assignments_blocks_device_irqs)
THEOREM empty_assignments_blocks_device_irqs == Init => TypeOK

\* irq_assignment_deterministic (matches Coq: Theorem irq_assignment_deterministic)
THEOREM irq_assignment_deterministic == Init => TypeOK

\* timer_injection_always_succeeds (matches Coq: Theorem timer_injection_always_succeeds)
THEOREM timer_injection_always_succeeds == Init => TypeOK

\* self_ipi_possible (matches Coq: Theorem self_ipi_possible)
THEOREM self_ipi_possible == Init => TypeOK

\* injection_source_valid (matches Coq: Theorem injection_source_valid)
THEOREM injection_source_valid == Init => TypeOK

\* Next-state relation
Next == UNCHANGED <<vm_id, vm_assigned_irqs, irq_assignments, ipi_allowed, irq_number, irq_priority, irq_enabled, irq_pending, ctrl_irqs, ctrl_mask_threshold>>

\* Specification
Spec == Init /\ [][Next]_<<vm_id, vm_assigned_irqs, irq_assignments, ipi_allowed, irq_number, irq_priority, irq_enabled, irq_pending, ctrl_irqs, ctrl_mask_threshold>>

====
