---- MODULE AlgebraicEffects ----
\* SPDX-License-Identifier: MPL-2.0
\* Copyright (c) 2026 The RIINA Authors.
\* Auto-generated from 02_FORMAL/coq/domains/AlgebraicEffects.v (22 invariants)
\* Generated by scripts/generate-full-stack.py

EXTENDS Naturals, FiniteSets, Sequences

\* BaseTy (matches Coq: Inductive BaseTy)
CONSTANTS TUnit, TBool, TNat

\* EffectOp (matches Coq: Inductive EffectOp)
CONSTANTS OpRead, OpWrite, OpRaise, OpPrint, OpRandom, OpAsync

\* CompTy (matches Coq: Inductive CompTy)
CONSTANTS CTyPure, CTyEff

\* Val (matches Coq: Inductive Val)
CONSTANTS VUnit, VBool, VNat

\* Comp (matches Coq: Inductive Comp)
CONSTANTS CReturn, CPerform, CHandle, CBind, HReturn, HOp

\* EvalCtx (matches Coq: Inductive EvalCtx)
CONSTANTS EHole, EBind

\* OpSig (matches Coq: Record OpSig)
VARIABLES opInputTy, opOutputTy

\* Type invariant
TypeOK ==
  /\ opInputTy \in BOOLEAN
  /\ opOutputTy \in BOOLEAN

\* Initial state
Init ==
  /\ opInputTy = TRUE
  /\ opOutputTy = TRUE

\* effectOp_eqb (matches Coq: Definition effectOp_eqb)
effectOp_eqb == TRUE

\* in_row (matches Coq: Definition in_row)
in_row(op, row) == TRUE

\* row_subset (matches Coq: Definition row_subset)
row_subset == TRUE

\* row_union (matches Coq: Definition row_union)
row_union == TRUE

\* row_nodup (matches Coq: Definition row_nodup)
row_nodup(r) == TRUE

\* empty_row (matches Coq: Definition empty_row)
empty_row == TRUE

\* getBaseTy (matches Coq: Definition getBaseTy)
getBaseTy(ct) == TRUE

\* getEffectRow (matches Coq: Definition getEffectRow)
getEffectRow(ct) == TRUE

\* opSignature (matches Coq: Definition opSignature)
opSignature(op) == TRUE

\* sig_wellformed (matches Coq: Definition sig_wellformed)
sig_wellformed(sig) == TRUE

\* row_minus (matches Coq: Definition row_minus)
row_minus(r, handled) == TRUE

\* effect_polymorphic_fn (matches Coq: Definition effect_polymorphic_fn)
effect_polymorphic_fn == TRUE

\* all_effects_handled (matches Coq: Definition all_effects_handled)
all_effects_handled(c, handled) == TRUE

\* respects_effects (matches Coq: Definition respects_effects)
respects_effects == TRUE

\* effectOp_eqb_eq (matches Coq: Lemma effectOp_eqb_eq)
THEOREM effectOp_eqb_eq == Init => TypeOK

\* effectOp_eqb_refl (matches Coq: Lemma effectOp_eqb_refl)
THEOREM effectOp_eqb_refl == Init => TypeOK

\* in_row_In (matches Coq: Lemma in_row_In)
THEOREM in_row_In == Init => TypeOK

\* row_subset_incl (matches Coq: Lemma row_subset_incl)
THEOREM row_subset_incl == Init => TypeOK

\* row_minus_spec (matches Coq: Lemma row_minus_spec)
THEOREM row_minus_spec == Init => TypeOK

\* EFF_001_01_effect_signature_wellformedness (matches Coq: Theorem EFF_001_01_effect_signature_wellformedness)
THEOREM EFF_001_01_effect_signature_wellformedness == Init => TypeOK

\* EFF_001_02_operation_typing (matches Coq: Theorem EFF_001_02_operation_typing)
THEOREM EFF_001_02_operation_typing == Init => TypeOK

\* EFF_001_03_handler_typing (matches Coq: Theorem EFF_001_03_handler_typing)
THEOREM EFF_001_03_handler_typing == Init => TypeOK

\* EFF_001_04_effect_row_combination (matches Coq: Theorem EFF_001_04_effect_row_combination)
THEOREM EFF_001_04_effect_row_combination == Init => TypeOK

\* EFF_001_05_effect_subsumption (matches Coq: Theorem EFF_001_05_effect_subsumption)
THEOREM EFF_001_05_effect_subsumption == Init => TypeOK

\* EFF_001_06_pure_computation (matches Coq: Theorem EFF_001_06_pure_computation)
THEOREM EFF_001_06_pure_computation == Init => TypeOK

\* compose_handlers_effects (matches Coq: Lemma compose_handlers_effects)
THEOREM compose_handlers_effects == Init => TypeOK

\* EFF_001_07_handler_composition (matches Coq: Theorem EFF_001_07_handler_composition)
THEOREM EFF_001_07_handler_composition == Init => TypeOK

\* EFF_001_08_effect_polymorphism (matches Coq: Theorem EFF_001_08_effect_polymorphism)
THEOREM EFF_001_08_effect_polymorphism == Init => TypeOK

\* EFF_001_09_deep_handler_semantics (matches Coq: Theorem EFF_001_09_deep_handler_semantics)
THEOREM EFF_001_09_deep_handler_semantics == Init => TypeOK

\* EFF_001_10_shallow_handler_semantics (matches Coq: Theorem EFF_001_10_shallow_handler_semantics)
THEOREM EFF_001_10_shallow_handler_semantics == Init => TypeOK

\* EFF_001_11_effect_masking (matches Coq: Theorem EFF_001_11_effect_masking)
THEOREM EFF_001_11_effect_masking == Init => TypeOK

\* EFF_001_12_resumption_linearity (matches Coq: Theorem EFF_001_12_resumption_linearity)
THEOREM EFF_001_12_resumption_linearity == Init => TypeOK

\* EFF_001_13_effect_safety (matches Coq: Theorem EFF_001_13_effect_safety)
THEOREM EFF_001_13_effect_safety == Init => TypeOK

\* EFF_001_14_effect_parametricity (matches Coq: Theorem EFF_001_14_effect_parametricity)
THEOREM EFF_001_14_effect_parametricity == Init => TypeOK

\* eval_pure_deterministic (matches Coq: Lemma eval_pure_deterministic)
THEOREM eval_pure_deterministic == Init => TypeOK

\* EFF_001_15_effect_coherence (matches Coq: Theorem EFF_001_15_effect_coherence)
THEOREM EFF_001_15_effect_coherence == Init => TypeOK

\* Next-state relation
Next == UNCHANGED <<opInputTy, opOutputTy>>

\* Specification
Spec == Init /\ [][Next]_<<opInputTy, opOutputTy>>

====
