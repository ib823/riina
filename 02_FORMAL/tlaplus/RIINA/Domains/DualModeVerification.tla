---- MODULE DualModeVerification ----
\* SPDX-License-Identifier: MPL-2.0
\* Copyright (c) 2026 The RIINA Authors.
\* Auto-generated from 02_FORMAL/coq/domains/DualModeVerification.v (22 invariants)
\* Generated by scripts/generate-full-stack.py

EXTENDS Naturals, FiniteSets, Sequences

\* expr (matches Coq: Inductive expr)
CONSTANTS EConst, EPlus, EIf

\* RefinementPred (matches Coq: Record RefinementPred)
VARIABLES full_pred, light_pred, light_sound

\* Type invariant
TypeOK ==
  /\ full_pred \in BOOLEAN
  /\ light_pred \in BOOLEAN
  /\ light_sound \in BOOLEAN

\* Initial state
Init ==
  /\ full_pred = TRUE
  /\ light_pred = TRUE
  /\ light_sound = TRUE

\* lightweight_check (matches Coq: Definition lightweight_check)
lightweight_check(rt, v) == TRUE

\* full_check (matches Coq: Definition full_check)
full_check(rt, v) == TRUE

\* decidable_refinement (matches Coq: Definition decidable_refinement)
decidable_refinement(rt) == TRUE

\* refine_subtype (matches Coq: Definition refine_subtype)
refine_subtype == TRUE

\* refine_conj (matches Coq: Definition refine_conj)
refine_conj == TRUE

\* lightweight_sound (matches Coq: Theorem lightweight_sound)
THEOREM lightweight_sound == Init => TypeOK

\* lightweight_complete_decidable (matches Coq: Theorem lightweight_complete_decidable)
THEOREM lightweight_complete_decidable == Init => TypeOK

\* refine_subtype_refl (matches Coq: Theorem refine_subtype_refl)
THEOREM refine_subtype_refl == Init => TypeOK

\* refine_subtype_trans (matches Coq: Theorem refine_subtype_trans)
THEOREM refine_subtype_trans == Init => TypeOK

\* checked_values_satisfy (matches Coq: Theorem checked_values_satisfy)
THEOREM checked_values_satisfy == Init => TypeOK

\* dual_mode_agreement (matches Coq: Theorem dual_mode_agreement)
THEOREM dual_mode_agreement == Init => TypeOK

\* refinement_weakening (matches Coq: Theorem refinement_weakening)
THEOREM refinement_weakening == Init => TypeOK

\* conj_subtype_left (matches Coq: Theorem conj_subtype_left)
THEOREM conj_subtype_left == Init => TypeOK

\* conj_subtype_right (matches Coq: Theorem conj_subtype_right)
THEOREM conj_subtype_right == Init => TypeOK

\* conj_greatest_lower_bound (matches Coq: Theorem conj_greatest_lower_bound)
THEOREM conj_greatest_lower_bound == Init => TypeOK

\* conj_full_pred_comm (matches Coq: Theorem conj_full_pred_comm)
THEOREM conj_full_pred_comm == Init => TypeOK

\* conj_full_pred_assoc (matches Coq: Theorem conj_full_pred_assoc)
THEOREM conj_full_pred_assoc == Init => TypeOK

\* conj_light_is_andb (matches Coq: Theorem conj_light_is_andb)
THEOREM conj_light_is_andb == Init => TypeOK

\* eval_const (matches Coq: Theorem eval_const)
THEOREM eval_const == Init => TypeOK

\* eval_plus (matches Coq: Theorem eval_plus)
THEOREM eval_plus == Init => TypeOK

\* lightweight_false_implies_not_full (matches Coq: Theorem lightweight_false_implies_not_full)
THEOREM lightweight_false_implies_not_full == Init => TypeOK

\* subtype_lightweight_sound (matches Coq: Theorem subtype_lightweight_sound)
THEOREM subtype_lightweight_sound == Init => TypeOK

\* conj_decidable (matches Coq: Theorem conj_decidable)
THEOREM conj_decidable == Init => TypeOK

\* refine_subtype_antisym_eq (matches Coq: Theorem refine_subtype_antisym_eq)
THEOREM refine_subtype_antisym_eq == Init => TypeOK

\* eval_if_false (matches Coq: Theorem eval_if_false)
THEOREM eval_if_false == Init => TypeOK

\* eval_if_true (matches Coq: Theorem eval_if_true)
THEOREM eval_if_true == Init => TypeOK

\* conj_sub_both (matches Coq: Theorem conj_sub_both)
THEOREM conj_sub_both == Init => TypeOK

\* Next-state relation
Next == UNCHANGED <<full_pred, light_pred, light_sound>>

\* Specification
Spec == Init /\ [][Next]_<<full_pred, light_pred, light_sound>>

====
