---- MODULE FFIAttackResearch ----
\* SPDX-License-Identifier: MPL-2.0
\* Copyright (c) 2026 The RIINA Authors.
\* Auto-generated from 02_FORMAL/coq/domains/FFIAttackResearch.v (20 invariants)
\* Generated by scripts/generate-full-stack.py

EXTENDS Naturals, FiniteSets, Sequences

\* FFIType (matches Coq: Inductive FFIType)
CONSTANTS FFI_Int8, FFI_Int16, FFI_Int32, FFI_Int64, FFI_Ptr, FFI_Array, FFI_Struct, FFI_Void

\* FFICallDescriptor (matches Coq: Record FFICallDescriptor)
VARIABLES ffi_name, ffi_params, ffi_return, ffi_sandboxed, ffi_validated

\* MemRegion (matches Coq: Record MemRegion)
VARIABLES region_base, region_size, region_owner

\* Sandbox (matches Coq: Record Sandbox)
VARIABLES sandbox_id, sandbox_region, sandbox_active, allowed_calls

\* MarshalBuffer (matches Coq: Record MarshalBuffer)
VARIABLES buf_capacity, buf_used

\* Type invariant
TypeOK ==
  /\ ffi_name \in BOOLEAN
  /\ ffi_params \in BOOLEAN
  /\ ffi_return \in BOOLEAN
  /\ ffi_sandboxed \in BOOLEAN
  /\ ffi_validated \in BOOLEAN
  /\ region_base \in BOOLEAN
  /\ region_size \in BOOLEAN
  /\ region_owner \in BOOLEAN
  /\ sandbox_id \in BOOLEAN
  /\ sandbox_region \in BOOLEAN
  /\ sandbox_active \in BOOLEAN
  /\ allowed_calls \in BOOLEAN
  /\ buf_capacity \in BOOLEAN
  /\ buf_used \in BOOLEAN

\* Initial state
Init ==
  /\ ffi_name = TRUE
  /\ ffi_params = TRUE
  /\ ffi_return = TRUE
  /\ ffi_sandboxed = TRUE
  /\ ffi_validated = TRUE
  /\ region_base = TRUE
  /\ region_size = TRUE
  /\ region_owner = TRUE
  /\ sandbox_id = TRUE
  /\ sandbox_region = TRUE
  /\ sandbox_active = TRUE
  /\ allowed_calls = TRUE
  /\ buf_capacity = TRUE
  /\ buf_used = TRUE

\* ffi_call_safe (matches Coq: Definition ffi_call_safe)
ffi_call_safe(call) == TRUE

\* regions_disjoint (matches Coq: Definition regions_disjoint)
regions_disjoint == TRUE

\* addr_in_region (matches Coq: Definition addr_in_region)
addr_in_region(r) == TRUE

\* call_allowed (matches Coq: Definition call_allowed)
call_allowed(sb, call_id) == TRUE

\* buf_remaining (matches Coq: Definition buf_remaining)
buf_remaining(b) == TRUE

\* can_marshal (matches Coq: Definition can_marshal)
can_marshal(b, t) == TRUE

\* ffi_safe_implies_sandboxed (matches Coq: Theorem ffi_safe_implies_sandboxed)
THEOREM ffi_safe_implies_sandboxed == Init => TypeOK

\* ffi_safe_implies_validated (matches Coq: Theorem ffi_safe_implies_validated)
THEOREM ffi_safe_implies_validated == Init => TypeOK

\* ffi_safe_construct (matches Coq: Theorem ffi_safe_construct)
THEOREM ffi_safe_construct == Init => TypeOK

\* int8_alignment_positive (matches Coq: Theorem int8_alignment_positive)
THEOREM int8_alignment_positive == Init => TypeOK

\* ffi_type_align_ge_1 (matches Coq: Lemma ffi_type_align_ge_1)
THEOREM ffi_type_align_ge_1 == Init => TypeOK

\* ptr_size_constant (matches Coq: Theorem ptr_size_constant)
THEOREM ptr_size_constant == Init => TypeOK

\* array_size_correct (matches Coq: Theorem array_size_correct)
THEOREM array_size_correct == Init => TypeOK

\* empty_struct_zero_size (matches Coq: Theorem empty_struct_zero_size)
THEOREM empty_struct_zero_size == Init => TypeOK

\* marshal_preserves_capacity (matches Coq: Theorem marshal_preserves_capacity)
THEOREM marshal_preserves_capacity == Init => TypeOK

\* marshal_increases_used (matches Coq: Theorem marshal_increases_used)
THEOREM marshal_increases_used == Init => TypeOK

\* marshal_never_overflows (matches Coq: Theorem marshal_never_overflows)
THEOREM marshal_never_overflows == Init => TypeOK

\* marshal_failure_means_insufficient (matches Coq: Theorem marshal_failure_means_insufficient)
THEOREM marshal_failure_means_insufficient == Init => TypeOK

\* marshal_void_always_succeeds (matches Coq: Theorem marshal_void_always_succeeds)
THEOREM marshal_void_always_succeeds == Init => TypeOK

\* disjoint_regions_no_overlap (matches Coq: Theorem disjoint_regions_no_overlap)
THEOREM disjoint_regions_no_overlap == Init => TypeOK

\* sandbox_call_allowed_decidable (matches Coq: Theorem sandbox_call_allowed_decidable)
THEOREM sandbox_call_allowed_decidable == Init => TypeOK

\* disjoint_symmetric (matches Coq: Theorem disjoint_symmetric)
THEOREM disjoint_symmetric == Init => TypeOK

\* addr_in_region_bounds (matches Coq: Theorem addr_in_region_bounds)
THEOREM addr_in_region_bounds == Init => TypeOK

\* ffi_void_size_zero (matches Coq: Theorem ffi_void_size_zero)
THEOREM ffi_void_size_zero == Init => TypeOK

\* ffi_int8_size (matches Coq: Theorem ffi_int8_size)
THEOREM ffi_int8_size == Init => TypeOK

\* marshal_void_preserves_used (matches Coq: Theorem marshal_void_preserves_used)
THEOREM marshal_void_preserves_used == Init => TypeOK

\* Next-state relation
Next == UNCHANGED <<ffi_name, ffi_params, ffi_return, ffi_sandboxed, ffi_validated, region_base, region_size, region_owner, sandbox_id, sandbox_region, sandbox_active, allowed_calls, buf_capacity, buf_used>>

\* Specification
Spec == Init /\ [][Next]_<<ffi_name, ffi_params, ffi_return, ffi_sandboxed, ffi_validated, region_base, region_size, region_owner, sandbox_id, sandbox_region, sandbox_active, allowed_calls, buf_capacity, buf_used>>

====
