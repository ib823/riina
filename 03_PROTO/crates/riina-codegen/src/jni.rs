// Copyright (c) 2026 The RIINA Authors. All rights reserved.

//! JNI Bridge Generator
//!
//! Auto-generates Java/Kotlin JNI bindings for RIINA libraries compiled
//! to Android. The generated code loads the native `.so` and exposes
//! RIINA functions as Java methods.
//!
//! Mode: ULTRA KIASU | FUCKING PARANOID | ZERO TRUST

/// Generate a Java JNI bridge class for a RIINA library.
///
/// # Arguments
///
/// * `package` — Java package name (e.g., "com.riina.app")
/// * `class_name` — Java class name (e.g., "RiinaLib")
pub fn generate_jni_bridge(package: &str, class_name: &str) -> String {
    let lib_name = class_name.to_lowercase();
    format!(
        r#"// Auto-generated by riinac for Android target
// Copyright (c) 2026 The RIINA Authors. All rights reserved.
//
// JNI bridge for RIINA native library.
// Do not edit — regenerate with: riinac build --target=android-arm64

package {package};

/**
 * JNI bridge to RIINA native library.
 *
 * <p>All methods in this class call into verified RIINA code compiled
 * to native ARM64 via the C backend. Security properties (non-interference,
 * effect safety, type safety) are preserved by construction.</p>
 */
public class {class_name} {{

    static {{
        System.loadLibrary("{lib_name}");
    }}

    /**
     * Run the RIINA program's main entry point.
     *
     * @return The program's exit code (0 = success).
     */
    public static native int main();

    /**
     * Run RIINA verification on a source string.
     *
     * @param source The RIINA source code to verify.
     * @return true if verification passes.
     */
    public static native boolean verify(String source);

    // ================================================================
    // Runtime support methods (called FROM native code)
    // ================================================================

    /**
     * Called by RIINA's print function (cetak).
     *
     * @param message The message to print.
     */
    @SuppressWarnings("unused") // Called from native code
    private static void riinaLog(String message) {{
        android.util.Log.d("RIINA", message);
    }}

    /**
     * Called by RIINA on panic (unrecoverable error).
     *
     * @param message The panic message.
     */
    @SuppressWarnings("unused") // Called from native code
    private static void riinaPanic(String message) {{
        throw new RuntimeException("RIINA panic: " + message);
    }}
}}
"#
    )
}

/// Generate JNI C header declarations for the bridge methods.
pub fn generate_jni_header(package: &str, class_name: &str) -> String {
    let jni_prefix = format!(
        "Java_{}_{}",
        package.replace('.', "_"),
        class_name
    );
    format!(
        r#"// Auto-generated by riinac for Android target
// Copyright (c) 2026 The RIINA Authors. All rights reserved.

#ifndef RIINA_JNI_H
#define RIINA_JNI_H

#include <jni.h>

#ifdef __cplusplus
extern "C" {{
#endif

JNIEXPORT jint JNICALL {jni_prefix}_main(JNIEnv *env, jclass clazz);

JNIEXPORT jboolean JNICALL {jni_prefix}_verify(JNIEnv *env, jclass clazz, jstring source);

#ifdef __cplusplus
}}
#endif

#endif /* RIINA_JNI_H */
"#
    )
}

/// Generate JNI C implementation file with type marshaling and callbacks.
pub fn generate_jni_impl(package: &str, class_name: &str) -> String {
    let jni_prefix = format!(
        "Java_{}_{}",
        package.replace('.', "_"),
        class_name
    );
    let jni_class = format!("{}/{}", package.replace('.', "/"), class_name);
    format!(
        r#"// Auto-generated by riinac for Android target
// Copyright (c) 2026 The RIINA Authors. All rights reserved.
//
// JNI C implementation for RIINA native library.
// Do not edit — regenerate with: riinac build --target=android-arm64

#include <jni.h>
#include <string.h>
#include <stdint.h>
#include "riina_output.h"
#include "riina_jni.h"

// ================================================================
// Thread-local JNI state for callbacks
// ================================================================

static JavaVM *g_jvm = NULL;
static __thread JNIEnv *g_env = NULL;
static jclass g_riina_class = NULL;
static jmethodID g_log_method = NULL;
static jmethodID g_panic_method = NULL;

// ================================================================
// JNI_OnLoad: cache JVM, class, and method IDs
// ================================================================

JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) {{
    (void)reserved;
    g_jvm = vm;

    JNIEnv *env;
    if ((*vm)->GetEnv(vm, (void **)&env, JNI_VERSION_1_6) != JNI_OK) {{
        return JNI_ERR;
    }}

    jclass cls = (*env)->FindClass(env, "{jni_class}");
    if (cls == NULL) return JNI_ERR;
    g_riina_class = (*env)->NewGlobalRef(env, cls);
    (*env)->DeleteLocalRef(env, cls);

    g_log_method = (*env)->GetStaticMethodID(env, g_riina_class,
        "riinaLog", "(Ljava/lang/String;)V");
    g_panic_method = (*env)->GetStaticMethodID(env, g_riina_class,
        "riinaPanic", "(Ljava/lang/String;)V");

    if (g_log_method == NULL || g_panic_method == NULL) return JNI_ERR;

    return JNI_VERSION_1_6;
}}

// ================================================================
// Type marshaling helpers
// ================================================================

/** Convert jstring to C string (caller must release). */
static const char *jstring_to_cstr(JNIEnv *env, jstring str) {{
    if (str == NULL) return NULL;
    return (*env)->GetStringUTFChars(env, str, NULL);
}}

/** Release C string obtained from jstring_to_cstr. */
static void release_cstr(JNIEnv *env, jstring str, const char *cstr) {{
    if (cstr != NULL) {{
        (*env)->ReleaseStringUTFChars(env, str, cstr);
    }}
}}

/** Convert C string to jstring. */
static jstring cstr_to_jstring(JNIEnv *env, const char *cstr) {{
    if (cstr == NULL) return NULL;
    return (*env)->NewStringUTF(env, cstr);
}}

// ================================================================
// RIINA runtime callbacks (called by compiled C code)
// ================================================================

/** Override riina_cetak to route through Java's riinaLog. */
void riina_cetak(const char *msg) {{
    JNIEnv *env = g_env;
    if (env == NULL) {{
        // Not on JNI thread — attach
        if (g_jvm != NULL) {{
            (*g_jvm)->AttachCurrentThread(g_jvm, (void **)&env, NULL);
        }}
        if (env == NULL) return;
    }}

    jstring jmsg = cstr_to_jstring(env, msg);
    if (jmsg != NULL) {{
        (*env)->CallStaticVoidMethod(env, g_riina_class, g_log_method, jmsg);
        (*env)->DeleteLocalRef(env, jmsg);
    }}
}}

/** Override riina_panic to route through Java's riinaPanic. */
void riina_panic(const char *msg) {{
    JNIEnv *env = g_env;
    if (env == NULL) {{
        if (g_jvm != NULL) {{
            (*g_jvm)->AttachCurrentThread(g_jvm, (void **)&env, NULL);
        }}
        if (env == NULL) return;
    }}

    jstring jmsg = cstr_to_jstring(env, msg);
    if (jmsg != NULL) {{
        (*env)->CallStaticVoidMethod(env, g_riina_class, g_panic_method, jmsg);
        (*env)->DeleteLocalRef(env, jmsg);
    }}
}}

// ================================================================
// JNI entry points
// ================================================================

JNIEXPORT jint JNICALL {jni_prefix}_main(JNIEnv *env, jclass clazz) {{
    (void)clazz;
    g_env = env;
    jint result = (jint)riina_main();
    g_env = NULL;
    return result;
}}

JNIEXPORT jboolean JNICALL {jni_prefix}_verify(JNIEnv *env, jclass clazz, jstring source) {{
    (void)clazz;
    g_env = env;
    const char *src = jstring_to_cstr(env, source);
    // Verification stub — always returns true for now
    (void)src;
    jboolean result = JNI_TRUE;
    release_cstr(env, source, src);
    g_env = NULL;
    return result;
}}
"#
    )
}

/// Generate AndroidManifest.xml from declared RIINA effects.
pub fn generate_android_manifest(package: &str, effects: &[&str]) -> String {
    let mut permissions = String::new();
    for effect in effects {
        match *effect {
            "network" | "Network" | "NetworkSecure" => {
                permissions.push_str("    <uses-permission android:name=\"android.permission.INTERNET\"/>\n");
                permissions.push_str("    <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/>\n");
            }
            "filesystem" | "FileSystem" => {
                permissions.push_str("    <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/>\n");
                permissions.push_str("    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n");
            }
            "crypto" | "Crypto" | "Random" => {
                // No special permission needed on Android
            }
            "biometrics" | "Biometrics" => {
                permissions.push_str("    <uses-permission android:name=\"android.permission.USE_BIOMETRIC\"/>\n");
            }
            _ => {}
        }
    }

    format!(
        r#"<?xml version="1.0" encoding="utf-8"?>
<!-- Auto-generated by riinac for Android target -->
<!-- Copyright (c) 2026 The RIINA Authors. All rights reserved. -->
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="{package}">

{permissions}
    <application>
        <!-- RIINA native library is loaded via RiinaLib.java -->
    </application>

</manifest>
"#
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_jni_bridge() {
        let bridge = generate_jni_bridge("com.riina.app", "RiinaLib");
        assert!(bridge.contains("package com.riina.app;"));
        assert!(bridge.contains("public class RiinaLib"));
        assert!(bridge.contains("System.loadLibrary"));
        assert!(bridge.contains("native int main()"));
        assert!(bridge.contains("riinaLog"));
    }

    #[test]
    fn test_generate_jni_header() {
        let header = generate_jni_header("com.riina.app", "RiinaLib");
        assert!(header.contains("RIINA_JNI_H"));
        assert!(header.contains("Java_com_riina_app_RiinaLib_main"));
        assert!(header.contains("jni.h"));
    }

    #[test]
    fn test_generate_jni_impl() {
        let impl_c = generate_jni_impl("com.riina.app", "RiinaLib");
        assert!(impl_c.contains("JNIEXPORT jint JNICALL Java_com_riina_app_RiinaLib_main"));
        assert!(impl_c.contains("JNI_OnLoad"));
        assert!(impl_c.contains("riina_cetak"));
        assert!(impl_c.contains("riina_panic"));
        assert!(impl_c.contains("jstring_to_cstr"));
        assert!(impl_c.contains("cstr_to_jstring"));
        assert!(impl_c.contains("GetStringUTFChars"));
        assert!(impl_c.contains("NewStringUTF"));
    }

    #[test]
    fn test_jni_impl_has_thread_local_env() {
        let impl_c = generate_jni_impl("com.riina.app", "RiinaLib");
        assert!(impl_c.contains("__thread JNIEnv"));
        assert!(impl_c.contains("g_env = env"));
        assert!(impl_c.contains("g_env = NULL"));
    }

    #[test]
    fn test_jni_impl_has_correct_jni_prefix() {
        let impl_c = generate_jni_impl("my.pkg", "Bridge");
        assert!(impl_c.contains("Java_my_pkg_Bridge_main"));
        assert!(impl_c.contains("Java_my_pkg_Bridge_verify"));
    }

    #[test]
    fn test_generate_android_manifest_with_network() {
        let manifest = generate_android_manifest("com.riina.app", &["network"]);
        assert!(manifest.contains("android.permission.INTERNET"));
        assert!(manifest.contains("android.permission.ACCESS_NETWORK_STATE"));
        assert!(manifest.contains("package=\"com.riina.app\""));
    }

    #[test]
    fn test_generate_android_manifest_with_filesystem() {
        let manifest = generate_android_manifest("com.riina.app", &["filesystem"]);
        assert!(manifest.contains("READ_EXTERNAL_STORAGE"));
        assert!(manifest.contains("WRITE_EXTERNAL_STORAGE"));
    }

    #[test]
    fn test_generate_android_manifest_empty_effects() {
        let manifest = generate_android_manifest("com.riina.app", &[]);
        assert!(manifest.contains("package=\"com.riina.app\""));
        assert!(!manifest.contains("uses-permission"));
    }
}
