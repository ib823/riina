// Copyright (c) 2026 The RIINA Authors. All rights reserved.

//! Mobile Backend
//!
//! Cross-compilation to Android (ARM64) and iOS (ARM64) via the C backend
//! with platform-specific bridge generation.
//!
//! # Architecture
//!
//! ```text
//!   ir::Program
//!       │
//!       ▼
//!   ┌────────────────────┐
//!   │  CBackend::emit    │  Emit C code (reuse existing C emitter)
//!   └────────────────────┘
//!       │
//!       ├── Android: + JNI bridge (jni.rs) → NDK → .so
//!       └── iOS: + Swift bridge (swift_bridge.rs) → Xcode → .a
//! ```
//!
//! Mode: ULTRA KIASU | FUCKING PARANOID | ZERO TRUST

use crate::backend::{AuxFile, Backend, BackendOutput, CBackend, Target};
use crate::ir::Program;
use crate::Result;

/// Mobile backend — emits C code plus platform-specific bridges.
pub struct MobileBackend {
    target: Target,
}

impl MobileBackend {
    pub fn new(target: Target) -> Self {
        Self { target }
    }
}

impl Backend for MobileBackend {
    fn emit(&self, program: &Program) -> Result<BackendOutput> {
        // Step 1: Emit C code using the existing C backend
        let c_backend = CBackend;
        let c_output = c_backend.emit(program)?;

        // Step 2: Generate platform-specific bridge
        let mut auxiliary = c_output.auxiliary;

        match self.target {
            Target::AndroidArm64 => {
                // Generate JNI bridge
                let jni_bridge = crate::jni::generate_jni_bridge("com.riina.app", "RiinaLib");
                auxiliary.push(AuxFile {
                    name: "RiinaLib.java".to_string(),
                    content: jni_bridge.into_bytes(),
                });

                // Generate Android.mk / CMakeLists.txt
                let cmake = generate_android_cmake("riina_native");
                auxiliary.push(AuxFile {
                    name: "CMakeLists.txt".to_string(),
                    content: cmake.into_bytes(),
                });
            }
            Target::IosArm64 => {
                // Generate Swift bridge
                let swift_bridge = crate::swift_bridge::generate_swift_bridge("RiinaLib");
                auxiliary.push(AuxFile {
                    name: "RiinaLib.swift".to_string(),
                    content: swift_bridge.into_bytes(),
                });

                // Generate bridging header
                let header = generate_ios_bridging_header();
                auxiliary.push(AuxFile {
                    name: "RiinaLib-Bridging-Header.h".to_string(),
                    content: header.into_bytes(),
                });
            }
            _ => {} // Native/WASM handled by other backends
        }

        Ok(BackendOutput {
            primary: c_output.primary,
            extension: ".c".to_string(),
            auxiliary,
        })
    }

    fn target(&self) -> Target {
        self.target
    }
}

/// Generate Android CMakeLists.txt for building the native library.
fn generate_android_cmake(lib_name: &str) -> String {
    format!(
        r#"# Auto-generated by riinac for Android target
# Copyright (c) 2026 The RIINA Authors. All rights reserved.

cmake_minimum_required(VERSION 3.18.1)
project({lib_name})

add_library({lib_name} SHARED
    riina_output.c
)

target_compile_options({lib_name} PRIVATE
    -std=c99
    -Wall
    -Wextra
    -Werror
    -O2
    -fstack-protector-strong
)

# Link Android log library for riina_cetak (print)
find_library(log-lib log)
target_link_libraries({lib_name} ${{log-lib}})
"#
    )
}

/// Generate iOS bridging header.
fn generate_ios_bridging_header() -> String {
    r#"// Auto-generated by riinac for iOS target
// Copyright (c) 2026 The RIINA Authors. All rights reserved.
//
// This header bridges RIINA's C output to Swift.

#ifndef RIINA_LIB_BRIDGING_HEADER_H
#define RIINA_LIB_BRIDGING_HEADER_H

#include <stdint.h>

// RIINA runtime entry point
int riina_main(void);

// RIINA value type (tagged union)
typedef struct {
    uint8_t tag;
    union {
        int64_t i;
        double f;
        uint8_t b;
        const char *s;
    } value;
} riina_value_t;

#endif /* RIINA_LIB_BRIDGING_HEADER_H */
"#
    .to_string()
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ir;

    #[test]
    fn test_mobile_backend_android_target() {
        let backend = MobileBackend::new(Target::AndroidArm64);
        assert_eq!(backend.target(), Target::AndroidArm64);
    }

    #[test]
    fn test_mobile_backend_ios_target() {
        let backend = MobileBackend::new(Target::IosArm64);
        assert_eq!(backend.target(), Target::IosArm64);
    }

    #[test]
    fn test_android_backend_emit() {
        let backend = MobileBackend::new(Target::AndroidArm64);
        let program = ir::Program::new();
        let output = backend.emit(&program).unwrap();
        assert_eq!(output.extension, ".c");
        // Should have JNI bridge + CMakeLists.txt
        assert!(output.auxiliary.len() >= 2);
        let names: Vec<&str> = output.auxiliary.iter().map(|a| a.name.as_str()).collect();
        assert!(names.contains(&"RiinaLib.java"));
        assert!(names.contains(&"CMakeLists.txt"));
    }

    #[test]
    fn test_ios_backend_emit() {
        let backend = MobileBackend::new(Target::IosArm64);
        let program = ir::Program::new();
        let output = backend.emit(&program).unwrap();
        assert_eq!(output.extension, ".c");
        // Should have Swift bridge + bridging header
        assert!(output.auxiliary.len() >= 2);
        let names: Vec<&str> = output.auxiliary.iter().map(|a| a.name.as_str()).collect();
        assert!(names.contains(&"RiinaLib.swift"));
        assert!(names.contains(&"RiinaLib-Bridging-Header.h"));
    }

    #[test]
    fn test_android_cmake_content() {
        let cmake = generate_android_cmake("riina_native");
        assert!(cmake.contains("add_library"));
        assert!(cmake.contains("riina_native"));
        assert!(cmake.contains("-std=c99"));
    }

    #[test]
    fn test_ios_bridging_header_content() {
        let header = generate_ios_bridging_header();
        assert!(header.contains("riina_main"));
        assert!(header.contains("riina_value_t"));
    }
}
