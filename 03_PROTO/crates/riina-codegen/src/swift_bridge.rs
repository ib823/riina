// Copyright (c) 2026 The RIINA Authors. All rights reserved.

//! Swift Bridge Generator
//!
//! Auto-generates Swift bindings for RIINA libraries compiled to iOS.
//! The generated Swift code wraps the C interface exposed through the
//! bridging header, providing a type-safe Swift API.
//!
//! Mode: ULTRA KIASU | FUCKING PARANOID | ZERO TRUST

/// Generate a Swift bridge file for a RIINA library.
///
/// # Arguments
///
/// * `module_name` — Swift module name (e.g., "RiinaLib")
pub fn generate_swift_bridge(module_name: &str) -> String {
    format!(
        r#"// Auto-generated by riinac for iOS target
// Copyright (c) 2026 The RIINA Authors. All rights reserved.
//
// Swift bridge for RIINA native library.
// Do not edit — regenerate with: riinac build --target=ios-arm64

import Foundation

/// Swift interface to verified RIINA code.
///
/// All methods call into RIINA compiled native code. Security properties
/// (non-interference, effect safety, type safety) are preserved by construction.
public class {module_name} {{

    /// Shared singleton instance.
    public static let shared = {module_name}()

    private init() {{}}

    /// Run the RIINA program's main entry point.
    ///
    /// - Returns: The program's exit code (0 = success).
    public func run() -> Int32 {{
        return riina_main()
    }}
}}

// MARK: - RIINA Value Types

/// A value returned by RIINA code, preserving type safety across the bridge.
public enum RiinaValue {{
    case unit
    case bool(Bool)
    case int(Int64)
    case float(Double)
    case string(String)

    /// Convert from the C-level `riina_value_t` struct.
    init(cValue: riina_value_t) {{
        switch cValue.tag {{
        case 0: self = .unit
        case 1: self = .bool(cValue.value.b != 0)
        case 2: self = .int(cValue.value.i)
        case 3: self = .float(cValue.value.f)
        case 4:
            if let s = cValue.value.s {{
                self = .string(String(cString: s))
            }} else {{
                self = .string("")
            }}
        default: self = .unit
        }}
    }}

    /// Convert to C-level `riina_value_t` struct for passing back to RIINA.
    func toCValue() -> riina_value_t {{
        var val = riina_value_t()
        switch self {{
        case .unit:
            val.tag = 0
        case .bool(let b):
            val.tag = 1
            val.value.b = b ? 1 : 0
        case .int(let i):
            val.tag = 2
            val.value.i = i
        case .float(let f):
            val.tag = 3
            val.value.f = f
        case .string(let s):
            val.tag = 4
            s.withCString {{ ptr in
                val.value.s = UnsafePointer(strdup(ptr))
            }}
        }}
        return val
    }}
}}

// MARK: - String Conversion Helpers

extension String {{
    /// Create a String from a RIINA C string pointer (UTF-8).
    /// Returns nil if the pointer is null.
    static func fromRiina(_ ptr: UnsafePointer<CChar>?) -> String? {{
        guard let ptr = ptr else {{ return nil }}
        return String(cString: ptr)
    }}
}}

// MARK: - Logging Bridge

/// Called by RIINA's print function (cetak).
@_cdecl("riina_ios_log")
func riinaLog(_ message: UnsafePointer<CChar>) {{
    let msg = String(cString: message)
    NSLog("[RIINA] %@", msg)
}}

/// Called by RIINA on panic (unrecoverable error).
@_cdecl("riina_ios_panic")
func riinaPanic(_ message: UnsafePointer<CChar>) -> Never {{
    let msg = String(cString: message)
    fatalError("RIINA panic: \(msg)")
}}
"#
    )
}

/// Generate the C bridge implementation file that routes callbacks to Swift.
pub fn generate_swift_c_bridge() -> String {
    r#"// Auto-generated by riinac for iOS target
// Copyright (c) 2026 The RIINA Authors. All rights reserved.
//
// C bridge implementation that routes RIINA callbacks to Swift.

#include <stdint.h>

// Forward declarations from Swift
extern void riina_ios_log(const char *message);
extern void riina_ios_panic(const char *message);

// RIINA entry point (from riina_output.c)
extern int riina_main(void);

// Override riina_cetak to route through Swift's riinaLog
void riina_cetak(const char *msg) {
    riina_ios_log(msg);
}

// Override riina_panic to route through Swift's riinaPanic
void riina_panic(const char *msg) {
    riina_ios_panic(msg);
}
"#
    .to_string()
}

/// Generate Info.plist keys from declared RIINA effects.
pub fn generate_info_plist_keys(effects: &[&str]) -> String {
    let mut keys = String::new();
    for effect in effects {
        match *effect {
            "network" | "Network" | "NetworkSecure" => {
                keys.push_str("    <key>NSAppTransportSecurity</key>\n");
                keys.push_str("    <dict>\n");
                keys.push_str("        <key>NSAllowsArbitraryLoads</key>\n");
                keys.push_str("        <false/>\n");
                keys.push_str("    </dict>\n");
            }
            "biometrics" | "Biometrics" => {
                keys.push_str("    <key>NSFaceIDUsageDescription</key>\n");
                keys.push_str("    <string>RIINA uses biometric authentication for secure operations.</string>\n");
            }
            "camera" | "Camera" => {
                keys.push_str("    <key>NSCameraUsageDescription</key>\n");
                keys.push_str("    <string>RIINA requires camera access.</string>\n");
            }
            _ => {}
        }
    }

    format!(
        r#"<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<!-- Auto-generated by riinac for iOS target -->
<!-- Copyright (c) 2026 The RIINA Authors. All rights reserved. -->
<plist version="1.0">
<dict>
    <key>CFBundleIdentifier</key>
    <string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
    <key>CFBundleName</key>
    <string>$(PRODUCT_NAME)</string>
    <key>CFBundleVersion</key>
    <string>1</string>
{keys}</dict>
</plist>
"#
    )
}

/// Generate a podspec for the RIINA iOS library.
pub fn generate_podspec(module_name: &str, version: &str) -> String {
    format!(
        r#"# Auto-generated by riinac for iOS target
# Copyright (c) 2026 The RIINA Authors. All rights reserved.

Pod::Spec.new do |s|
  s.name         = '{module_name}'
  s.version      = '{version}'
  s.summary      = 'RIINA verified native library'
  s.description  = 'Formally verified code compiled from RIINA. Security properties proven in Coq.'
  s.homepage     = 'https://github.com/ib823/riina'
  s.license      = {{ :type => 'Proprietary', :file => 'LICENSE' }}
  s.author       = 'RIINA Authors'
  s.source       = {{ :git => 'https://github.com/ib823/riina.git', :tag => "v#{{s.version}}" }}
  s.platform     = :ios, '15.0'
  s.source_files = '*.{{c,h,swift}}'
  s.swift_version = '5.9'
end
"#
    )
}

/// Generate a Swift Package Manager Package.swift for the RIINA library.
pub fn generate_spm_package(module_name: &str) -> String {
    format!(
        r#"// swift-tools-version: 5.9
// Auto-generated by riinac for iOS target
// Copyright (c) 2026 The RIINA Authors. All rights reserved.

import PackageDescription

let package = Package(
    name: "{module_name}",
    platforms: [.iOS(.v15), .macOS(.v13)],
    products: [
        .library(name: "{module_name}", targets: ["{module_name}"]),
    ],
    targets: [
        .target(
            name: "{module_name}",
            path: ".",
            sources: ["riina_output.c", "riina_swift_bridge.c"],
            publicHeadersPath: ".",
            cSettings: [.headerSearchPath(".")]
        ),
    ]
)
"#
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_swift_bridge() {
        let bridge = generate_swift_bridge("RiinaLib");
        assert!(bridge.contains("public class RiinaLib"));
        assert!(bridge.contains("riina_main()"));
        assert!(bridge.contains("RiinaValue"));
        assert!(bridge.contains("@_cdecl"));
        assert!(bridge.contains("riinaLog"));
        assert!(bridge.contains("riinaPanic"));
    }

    #[test]
    fn test_swift_bridge_has_type_conversion() {
        let bridge = generate_swift_bridge("RiinaLib");
        assert!(bridge.contains("toCValue()"));
        assert!(bridge.contains("init(cValue:"));
        assert!(bridge.contains("fromRiina"));
    }

    #[test]
    fn test_generate_swift_c_bridge() {
        let bridge = generate_swift_c_bridge();
        assert!(bridge.contains("riina_cetak"));
        assert!(bridge.contains("riina_ios_log"));
        assert!(bridge.contains("riina_panic"));
        assert!(bridge.contains("riina_ios_panic"));
    }

    #[test]
    fn test_generate_info_plist_network() {
        let plist = generate_info_plist_keys(&["network"]);
        assert!(plist.contains("NSAppTransportSecurity"));
    }

    #[test]
    fn test_generate_info_plist_biometrics() {
        let plist = generate_info_plist_keys(&["biometrics"]);
        assert!(plist.contains("NSFaceIDUsageDescription"));
    }

    #[test]
    fn test_generate_info_plist_empty() {
        let plist = generate_info_plist_keys(&[]);
        assert!(plist.contains("CFBundleIdentifier"));
        assert!(!plist.contains("NSFaceIDUsageDescription"));
    }

    #[test]
    fn test_generate_podspec() {
        let spec = generate_podspec("RiinaLib", "0.2.0");
        assert!(spec.contains("s.name         = 'RiinaLib'"));
        assert!(spec.contains("s.version      = '0.2.0'"));
        assert!(spec.contains("Proprietary"));
    }

    #[test]
    fn test_generate_spm_package() {
        let pkg = generate_spm_package("RiinaLib");
        assert!(pkg.contains("swift-tools-version: 5.9"));
        assert!(pkg.contains("name: \"RiinaLib\""));
        assert!(pkg.contains("riina_output.c"));
        assert!(pkg.contains("riina_swift_bridge.c"));
    }
}
